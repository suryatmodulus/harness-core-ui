/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig, getUsingFetch, mutateUsingFetch, GetUsingFetchProps, MutateUsingFetchProps } from '../config'
export const SPEC_VERSION = '1.0'
export interface ACLAggregateFilter {
  resourceGroupIdentifiers?: string[]
  roleIdentifiers?: string[]
}

export type AbortFailureActionConfig = FailureStrategyActionConfig & {
  type: 'Abort'
}

export interface AccessControlCheckError {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
  correlationId?: string
  detailedMessage?: string
  failedPermissionChecks?: PermissionCheck[]
  message?: string
  metadata?: ErrorMetadataDTO
  responseMessages?: ResponseMessage[]
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface Account {
  accountEvents?: AccountEvent[]
  accountName: string
  accountPreferences?: AccountPreferences
  appId: string
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  ceAutoCollectK8sEvents?: boolean
  ceLicenseInfo?: CeLicenseInfo
  cloudCostEnabled?: boolean
  companyName: string
  createdAt?: number
  createdBy?: EmbeddedUser
  createdFromNG?: boolean
  dataRetentionDurationMs?: number
  defaultExperience?: 'NG' | 'CG'
  defaults?: {
    [key: string]: string
  }
  delegateConfiguration?: DelegateConfiguration
  forImport?: boolean
  harnessSupportAccessAllowed?: boolean
  lastUpdatedAt: number
  lastUpdatedBy?: EmbeddedUser
  licenseId?: string
  licenseInfo?: LicenseInfo
  localEncryptionEnabled?: boolean
  migratedToClusterUrl?: string
  nextGenEnabled?: boolean
  oauthEnabled?: boolean
  povAccount?: boolean
  ringName?: string
  serviceAccountConfig?: ServiceAccountConfig
  serviceGuardLimit?: number
  subdomainUrl?: string
  techStacks?: TechStack[]
  trialSignupOptions?: TrialSignupOptions
  twoFactorAdminEnforced?: boolean
  uuid: string
  whitelistedDomains?: string[]
}

export interface AccountDTO {
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  cluster?: string
  companyName?: string
  defaultExperience?: 'NG' | 'CG'
  identifier?: string
  name?: string
  nextGenEnabled?: boolean
  serviceAccountConfig?: ServiceAccountConfig
}

export interface AccountEvent {
  accountEventType?:
    | 'APP_CREATED'
    | 'SERVICE_CREATED'
    | 'ENV_CREATED'
    | 'WORKFLOW_CREATED'
    | 'WORKFLOW_DEPLOYED'
    | 'PIPELINE_DEPLOYED'
    | 'DELEGATE_INSTALLED'
    | 'CLOUD_PROVIDER_CREATED'
    | 'ARTIFACT_REPO_CREATED'
    | 'PIPELINE_CREATED'
    | 'ARTIFACT_STREAM_ADDED'
    | 'INFRA_MAPPING_ADDED'
    | 'INFRA_DEFINITION_ADDED'
    | 'CUSTOM'
  category?: string
  customMsg?: string
  properties?: {
    [key: string]: string
  }
}

export interface AccountLicenseDTO {
  accountId?: string
  allModuleLicenses?: {
    [key: string]: ModuleLicenseDTO[]
  }
  createdAt?: number
  lastUpdatedAt?: number
  moduleLicenses?: {
    [key: string]: ModuleLicenseDTO
  }
}

export interface AccountPermissions {
  permissions?: (
    | 'ACCOUNT'
    | 'LOGGED_IN'
    | 'DELEGATE'
    | 'NONE'
    | 'APP'
    | 'ALL_APP_ENTITIES'
    | 'ENV'
    | 'SERVICE'
    | 'WORKFLOW'
    | 'PIPELINE'
    | 'DEPLOYMENT'
    | 'APPLICATION_CREATE_DELETE'
    | 'USER_PERMISSION_MANAGEMENT'
    | 'ACCOUNT_MANAGEMENT'
    | 'PROVISIONER'
    | 'TEMPLATE_MANAGEMENT'
    | 'APP_TEMPLATE'
    | 'USER_PERMISSION_READ'
    | 'AUDIT_VIEWER'
    | 'TAG_MANAGEMENT'
    | 'CE_ADMIN'
    | 'CE_VIEWER'
    | 'MANAGE_CLOUD_PROVIDERS'
    | 'MANAGE_CONNECTORS'
    | 'MANAGE_APPLICATIONS'
    | 'MANAGE_APPLICATION_STACKS'
    | 'MANAGE_DELEGATES'
    | 'MANAGE_ALERT_NOTIFICATION_RULES'
    | 'MANAGE_DELEGATE_PROFILES'
    | 'MANAGE_CONFIG_AS_CODE'
    | 'MANAGE_SECRETS'
    | 'MANAGE_SECRET_MANAGERS'
    | 'MANAGE_SSH_AND_WINRM'
    | 'MANAGE_AUTHENTICATION_SETTINGS'
    | 'MANAGE_USER_AND_USER_GROUPS_AND_API_KEYS'
    | 'VIEW_USER_AND_USER_GROUPS_AND_API_KEYS'
    | 'MANAGE_IP_WHITELIST'
    | 'MANAGE_IP_WHITELISTING'
    | 'MANAGE_DEPLOYMENT_FREEZES'
    | 'ALLOW_DEPLOYMENTS_DURING_FREEZE'
    | 'MANAGE_PIPELINE_GOVERNANCE_STANDARDS'
    | 'MANAGE_API_KEYS'
    | 'MANAGE_TAGS'
    | 'MANAGE_ACCOUNT_DEFAULTS'
    | 'MANAGE_CUSTOM_DASHBOARDS'
    | 'CREATE_CUSTOM_DASHBOARDS'
    | 'MANAGE_RESTRICTED_ACCESS'
  )[]
}

export interface AccountPreferences {
  delegateSecretsCacheTTLInHours?: number
}

export interface AccountResourcesDTO {
  connectorsCount?: number
  delegatesCount?: number
  secretsCount?: number
  templatesCount?: number
}

export interface ActiveProjectsCountDTO {
  count?: number
}

export interface ActiveServiceInstanceSummary {
  changeRate?: number
  countDetails?: InstanceCountDetailsByEnvTypeBase
}

export interface Activity {
  accountIdentifier?: string
  activityStatus: 'SUCCESS' | 'FAILED'
  activityTime: number
  description?: string
  detail?: ActivityDetail
  referredEntity?: EntityDetail
  type: 'CONNECTIVITY_CHECK' | 'ENTITY_USAGE' | 'ENTITY_CREATION' | 'ENTITY_UPDATE'
}

export interface ActivityDetail {
  [key: string]: any
}

export interface ActivitySummary {
  endTime?: number
  failedActivitiesCount?: number
  get_id?: number
  heartBeatFailuresCount?: number
  startTime?: number
  successfulActivitiesCount?: number
}

export type AddOperation = PatchOperation & {
  value?: JsonNode
}

export type AddRuleYaml = PatchInstruction & {
  identifier: string
  spec: AddRuleYamlSpec
  type: 'AddRule'
}

export interface AddRuleYamlSpec {
  clauses?: Clause[]
  distribution?: DistributionYamlSpec
  priority?: number
  serve?: Serve
}

export type AddSegmentToVariationTargetMapYaml = PatchInstruction & {
  identifier: string
  spec: AddSegmentToVariationTargetMapYamlSpec
  type: 'AddSegmentToVariationTargetMap'
}

export interface AddSegmentToVariationTargetMapYamlSpec {
  segments: string[]
  variation: string
}

export type AddTargetsToVariationTargetMapYaml = PatchInstruction & {
  identifier: string
  spec: AddTargetsToVariationTargetMapYamlSpec
  type: 'AddTargetsToVariationTargetMap'
}

export interface AddTargetsToVariationTargetMapYamlSpec {
  targets: string[]
  variation: string
}

export interface AddUsers {
  emails: string[]
  roleBindings?: RoleBinding[]
  userGroups?: string[]
}

export interface AddUsersResponse {
  addUserResponseMap?: {
    [key: string]:
      | 'USER_INVITED_SUCCESSFULLY'
      | 'USER_ADDED_SUCCESSFULLY'
      | 'USER_ALREADY_ADDED'
      | 'USER_ALREADY_INVITED'
      | 'FAIL'
  }
}

export interface AggregateACLRequest {
  resourceGroupFilter?: string[]
  roleFilter?: string[]
  searchTerm?: string
}

export interface ApiKeyAggregateDTO {
  apiKey: ApiKeyDTO
  createdAt: number
  lastModifiedAt: number
  tokensCount?: number
}

export interface ApiKeyDTO {
  accountIdentifier: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  defaultTimeToExpireToken?: number
  description?: string
  identifier: string
  name: string
  orgIdentifier?: string
  parentIdentifier: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
}

export type AppDynamicsConnectorDTO = ConnectorConfigDTO & {
  accountname: string
  authType?: 'UsernamePassword' | 'ApiClientToken'
  clientId?: string
  clientSecretRef?: string
  controllerUrl: string
  delegateSelectors?: string[]
  passwordRef?: string
  username?: string
}

export type AppFilter = Filter & {
  filterType?: string
}

export interface AppPermission {
  actions?: (
    | 'ALL'
    | 'CREATE'
    | 'READ'
    | 'UPDATE'
    | 'DELETE'
    | 'EXECUTE'
    | 'EXECUTE_WORKFLOW'
    | 'EXECUTE_PIPELINE'
    | 'EXECUTE_WORKFLOW_ROLLBACK'
    | 'DEFAULT'
  )[]
  appFilter?: AppFilter
  entityFilter?: Filter
  permissionType?:
    | 'ACCOUNT'
    | 'LOGGED_IN'
    | 'DELEGATE'
    | 'NONE'
    | 'APP'
    | 'ALL_APP_ENTITIES'
    | 'ENV'
    | 'SERVICE'
    | 'WORKFLOW'
    | 'PIPELINE'
    | 'DEPLOYMENT'
    | 'APPLICATION_CREATE_DELETE'
    | 'USER_PERMISSION_MANAGEMENT'
    | 'ACCOUNT_MANAGEMENT'
    | 'PROVISIONER'
    | 'TEMPLATE_MANAGEMENT'
    | 'APP_TEMPLATE'
    | 'USER_PERMISSION_READ'
    | 'AUDIT_VIEWER'
    | 'TAG_MANAGEMENT'
    | 'CE_ADMIN'
    | 'CE_VIEWER'
    | 'MANAGE_CLOUD_PROVIDERS'
    | 'MANAGE_CONNECTORS'
    | 'MANAGE_APPLICATIONS'
    | 'MANAGE_APPLICATION_STACKS'
    | 'MANAGE_DELEGATES'
    | 'MANAGE_ALERT_NOTIFICATION_RULES'
    | 'MANAGE_DELEGATE_PROFILES'
    | 'MANAGE_CONFIG_AS_CODE'
    | 'MANAGE_SECRETS'
    | 'MANAGE_SECRET_MANAGERS'
    | 'MANAGE_SSH_AND_WINRM'
    | 'MANAGE_AUTHENTICATION_SETTINGS'
    | 'MANAGE_USER_AND_USER_GROUPS_AND_API_KEYS'
    | 'VIEW_USER_AND_USER_GROUPS_AND_API_KEYS'
    | 'MANAGE_IP_WHITELIST'
    | 'MANAGE_IP_WHITELISTING'
    | 'MANAGE_DEPLOYMENT_FREEZES'
    | 'ALLOW_DEPLOYMENTS_DURING_FREEZE'
    | 'MANAGE_PIPELINE_GOVERNANCE_STANDARDS'
    | 'MANAGE_API_KEYS'
    | 'MANAGE_TAGS'
    | 'MANAGE_ACCOUNT_DEFAULTS'
    | 'MANAGE_CUSTOM_DASHBOARDS'
    | 'CREATE_CUSTOM_DASHBOARDS'
    | 'MANAGE_RESTRICTED_ACCESS'
}

export type ApprovalStageConfig = StageInfoConfig & {
  execution: ExecutionElementConfig
}

export interface ApproverInputInfo {
  defaultValue?: string
  name?: string
}

export interface Approvers {
  disallowPipelineExecutor: boolean
  minimumCount: number
  userGroups: string[]
}

export interface ArtifactConfig {
  [key: string]: any
}

export interface ArtifactListConfig {
  metadata?: string
  primary?: PrimaryArtifact
  sidecars?: SidecarArtifactWrapper[]
}

export interface ArtifactOverrideSetWrapper {
  overrideSet?: ArtifactOverrideSets
}

export interface ArtifactOverrideSets {
  artifacts?: ArtifactListConfig
  identifier?: string
}

export interface ArtifactSummary {
  displayName?: string
  type?: string
}

export interface ArtifactoryAuthCredentials {
  [key: string]: any
}

export interface ArtifactoryAuthentication {
  spec?: ArtifactoryAuthCredentials
  type: 'UsernamePassword' | 'Anonymous'
}

export type ArtifactoryConnector = ConnectorConfigDTO & {
  artifactoryServerUrl: string
  auth?: ArtifactoryAuthentication
  delegateSelectors?: string[]
}

export type ArtifactoryUsernamePasswordAuth = ArtifactoryAuthCredentials & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface ArtifactsSummary {
  primary?: ArtifactSummary
  sidecars?: ArtifactSummary[]
}

export type AuditFilterProperties = FilterProperties & {
  actions?: (
    | 'CREATE'
    | 'UPDATE'
    | 'RESTORE'
    | 'DELETE'
    | 'UPSERT'
    | 'INVITE'
    | 'RESEND_INVITE'
    | 'REVOKE_INVITE'
    | 'ADD_COLLABORATOR'
    | 'REMOVE_COLLABORATOR'
    | 'REVOKE_TOKEN'
    | 'ADD_MEMBERSHIP'
    | 'REMOVE_MEMBERSHIP'
  )[]
  endTime?: number
  environments?: Environment[]
  modules?: ('CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE')[]
  principals?: Principal[]
  resources?: ResourceDTO[]
  scopes?: ResourceScopeDTO[]
  startTime?: number
}

export interface AuthenticationSettingsResponse {
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  ngAuthSettings?: NGAuthSettings[]
  twoFactorEnabled?: boolean
  whitelistedDomains?: string[]
}

export interface AuthorInfo {
  name?: string
  url?: string
}

export type AvailabilityRestrictionDTO = RestrictionDTO & {
  enabled?: boolean
}

export type AvailabilityRestrictionMetadataDTO = RestrictionMetadataDTO & {
  enabled?: boolean
}

export interface AwsCodeCommitAuthenticationDTO {
  spec: AwsCodeCommitCredentialsDTO
  type: 'HTTPS'
}

export type AwsCodeCommitConnectorDTO = ConnectorConfigDTO & {
  authentication: AwsCodeCommitAuthenticationDTO
  delegateSelectors?: string[]
  type: 'Repo' | 'Region'
  url: string
}

export interface AwsCodeCommitCredentialsDTO {
  [key: string]: any
}

export type AwsCodeCommitHttpsCredentialsDTO = AwsCodeCommitCredentialsDTO & {
  spec: AwsCodeCommitHttpsCredentialsSpecDTO
  type: 'AWSCredentials'
}

export interface AwsCodeCommitHttpsCredentialsSpecDTO {
  [key: string]: any
}

export type AwsCodeCommitSCMDTO = SourceCodeManagerDTO & {
  authentication: AwsCodeCommitAuthenticationDTO
}

export type AwsCodeCommitSecretKeyAccessKeyDTO = AwsCodeCommitHttpsCredentialsSpecDTO & {
  accessKey?: string
  accessKeyRef?: string
  secretKeyRef: string
}

export type AwsConnector = ConnectorConfigDTO & {
  credential: AwsCredential
  delegateSelectors?: string[]
}

export interface AwsCredential {
  crossAccountAccess?: CrossAccountAccess
  spec?: AwsCredentialSpec
  type: 'InheritFromDelegate' | 'ManualConfig' | 'Irsa'
}

export interface AwsCredentialSpec {
  [key: string]: any
}

export interface AwsCurAttributes {
  region?: string
  reportName: string
  s3BucketName: string
  s3Prefix?: string
}

export interface AwsKmsConnectorCredential {
  spec?: AwsKmsCredentialSpec
  type: 'AssumeIAMRole' | 'AssumeSTSRole' | 'ManualConfig'
}

export type AwsKmsConnectorDTO = ConnectorConfigDTO & {
  credential?: AwsKmsConnectorCredential
  default?: boolean
  delegateSelectors?: string[]
  kmsArn: string
  region?: string
}

export interface AwsKmsCredentialSpec {
  [key: string]: any
}

export type AwsKmsCredentialSpecAssumeIAM = AwsKmsCredentialSpec & {
  delegateSelectors: string[]
}

export type AwsKmsCredentialSpecAssumeSTS = AwsKmsCredentialSpec & {
  assumeStsRoleDuration?: number
  delegateSelectors: string[]
  externalName?: string
  roleArn: string
}

export type AwsKmsCredentialSpecManualConfig = AwsKmsCredentialSpec & {
  accessKey: string
  secretKey: string
}

export type AwsManualConfigSpec = AwsCredentialSpec & {
  accessKey?: string
  accessKeyRef?: string
  secretKeyRef: string
}

export type AwsSMCredentialSpecAssumeIAM = AwsSecretManagerCredentialSpec & { [key: string]: any }

export type AwsSMCredentialSpecAssumeSTS = AwsSecretManagerCredentialSpec & {
  assumeStsRoleDuration?: number
  externalId?: string
  roleArn: string
}

export type AwsSMCredentialSpecManualConfig = AwsSecretManagerCredentialSpec & {
  accessKey: string
  secretKey: string
}

export interface AwsSecretManagerCredential {
  spec?: AwsSecretManagerCredentialSpec
  type: 'AssumeIAMRole' | 'AssumeSTSRole' | 'ManualConfig'
}

export interface AwsSecretManagerCredentialSpec {
  [key: string]: any
}

export type AwsSecretManagerDTO = ConnectorConfigDTO & {
  credential: AwsSecretManagerCredential
  default?: boolean
  delegateSelectors?: string[]
  region: string
  secretNamePrefix?: string
}

export type AzureDevOpsSCMDTO = SourceCodeManagerDTO & {
  authentication?: GithubAuthentication
}

export type AzureKeyVaultConnectorDTO = ConnectorConfigDTO & {
  azureEnvironmentType?: 'AZURE' | 'AZURE_US_GOVERNMENT'
  clientId: string
  default?: boolean
  delegateSelectors?: string[]
  secretKey: string
  subscription: string
  tenantId: string
  vaultName: string
}

export type AzureKeyVaultMetadataRequestSpecDTO = SecretManagerMetadataRequestSpecDTO & {
  azureEnvironmentType?: 'AZURE' | 'AZURE_US_GOVERNMENT'
  clientId: string
  delegateSelectors?: string[]
  secretKey: string
  subscription: string
  tenantId: string
}

export type AzureKeyVaultMetadataSpecDTO = SecretManagerMetadataSpecDTO & {
  vaultNames?: string[]
}

export interface BarrierInfoConfig {
  identifier: string
  name: string
}

export type BarrierStepInfo = StepSpecType & {
  barrierRef: string
}

export interface BaseSSHSpecDTO {
  [key: string]: any
}

export interface BillingExportSpec {
  containerName: string
  directoryName: string
  reportName: string
  storageAccountName: string
  subscriptionId: string
}

export interface BitbucketApiAccess {
  spec: BitbucketApiAccessSpecDTO
  type: 'UsernameToken'
}

export interface BitbucketApiAccessSpecDTO {
  [key: string]: any
}

export interface BitbucketAuthentication {
  spec: BitbucketCredentialsDTO
  type: 'Http' | 'Ssh'
}

export type BitbucketConnector = ConnectorConfigDTO & {
  apiAccess?: BitbucketApiAccess
  authentication: BitbucketAuthentication
  delegateSelectors?: string[]
  type: 'Account' | 'Repo'
  url: string
  validationRepo?: string
}

export interface BitbucketCredentialsDTO {
  [key: string]: any
}

export type BitbucketHttpCredentials = BitbucketCredentialsDTO & {
  spec: BitbucketHttpCredentialsSpecDTO
  type: 'UsernamePassword'
}

export interface BitbucketHttpCredentialsSpecDTO {
  [key: string]: any
}

export type BitbucketSCMDTO = SourceCodeManagerDTO & {
  authentication?: BitbucketAuthentication
}

export type BitbucketSshCredentials = BitbucketCredentialsDTO & {
  sshKeyRef: string
}

export type BitbucketStore = StoreConfig & {
  branch?: string
  commitId?: string
  connectorRef: string
  folderPath?: string
  gitFetchType: 'Branch' | 'Commit'
  metadata?: string
  paths?: string[]
  repoName?: string
}

export type BitbucketUsernamePassword = BitbucketHttpCredentialsSpecDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type BitbucketUsernameTokenApiAccess = BitbucketApiAccessSpecDTO & {
  tokenRef: string
  username?: string
  usernameRef?: string
}

export type BranchBuildSpec = BuildSpec & {
  branch: string
}

export interface Build {
  spec: BuildSpec
  type: 'branch' | 'tag' | 'PR'
}

export interface BuildIdAndInstanceCount {
  buildId?: string
  count?: number
}

export interface BuildSpec {
  [key: string]: any
}

export type CDLicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalServiceInstances?: number
  totalWorkload?: number
}

export type CDModuleLicenseDTO = ModuleLicenseDTO & {
  cdLicenseType?: 'SERVICES' | 'SERVICE_INSTANCES'
  serviceInstances?: number
  workloads?: number
}

export interface CDPipelineModuleInfo {
  envIdentifiers?: string[]
  environmentTypes?: ('PreProduction' | 'Production')[]
  infrastructureTypes?: string[]
  serviceDefinitionTypes?: string[]
  serviceIdentifiers?: string[]
}

export interface CDStageModuleInfo {
  infraExecutionSummary?: InfraExecutionSummary
  nodeExecutionId?: string
  serviceInfo?: ServiceExecutionSummary
}

export type CEAwsConnector = ConnectorConfigDTO & {
  awsAccountId?: string
  crossAccountAccess: CrossAccountAccess
  curAttributes?: AwsCurAttributes
  featuresEnabled?: ('BILLING' | 'OPTIMIZATION' | 'VISIBILITY')[]
}

export type CEAzureConnector = ConnectorConfigDTO & {
  billingExportSpec?: BillingExportSpec
  featuresEnabled?: ('BILLING' | 'OPTIMIZATION' | 'VISIBILITY')[]
  subscriptionId: string
  tenantId: string
}

export type CEKubernetesClusterConfig = ConnectorConfigDTO & {
  connectorRef: string
  featuresEnabled?: ('BILLING' | 'OPTIMIZATION' | 'VISIBILITY')[]
}

export type CELicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalSpendLimit?: number
}

export type CEModuleLicenseDTO = ModuleLicenseDTO & {
  spendLimit?: number
}

export type CFLicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalClientMAUs?: number
  totalFeatureFlagUnits?: number
}

export type CFModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfClientMAUs?: number
  numberOfUsers?: number
}

export type CILicenseSummaryDTO = LicensesWithSummaryDTO & {
  totalDevelopers?: number
}

export type CIModuleLicenseDTO = ModuleLicenseDTO & {
  numberOfCommitters?: number
}

export interface CIProperties {
  codebase?: CodeBase
}

export type CVLicenseSummaryDTO = LicensesWithSummaryDTO & {}

export type CVModuleLicenseDTO = ModuleLicenseDTO & {}

export interface CcmConnectorFilter {
  awsAccountId?: string
  azureSubscriptionId?: string
  azureTenantId?: string
  featuresEnabled?: ('BILLING' | 'OPTIMIZATION' | 'VISIBILITY')[]
  gcpProjectId?: string
  k8sConnectorRef?: string
}

export interface CeLicenseInfo {
  expiryTime?: number
  licenseType?: 'FULL_TRIAL' | 'LIMITED_TRIAL' | 'PAID'
}

export interface Clause {
  attribute: string
  id: string
  negate: boolean
  op: string
  values: string[]
}

export interface ClauseYamlSpec {
  attribute?: string
  op: string
  values: string[]
}

export interface CodeBase {
  build: Build
  connectorRef: string
  depth?: number
  prCloneStrategy?: 'MergeCommit' | 'SourceBranch'
  repoName?: string
  resources?: ContainerResource
  sslVerify?: boolean
}

export interface Condition {
  key: string
  operator: 'equals' | 'not equals' | 'in' | 'not in'
  value: string
}

export type ConnectedArgoGitOpsInfoDTO = GitOpsInfoDTO & {
  adapterUrl: string
}

export interface ConnectivityCheckSummary {
  endTime?: number
  failureCount?: number
  startTime?: number
  successCount?: number
}

export interface Connector {
  connector?: ConnectorInfoDTO
}

export interface ConnectorActivityDetails {
  lastActivityTime?: number
}

export interface ConnectorCatalogueItem {
  category?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  connectors?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
  )[]
}

export interface ConnectorCatalogueResponse {
  catalogue?: ConnectorCatalogueItem[]
}

export interface ConnectorConfigDTO {
  [key: string]: any
}

export interface ConnectorConnectivityDetails {
  errorSummary?: string
  errors?: ErrorDetail[]
  lastConnectedAt?: number
  lastTestedAt?: number
  status?: 'SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN'
  testedAt?: number
}

export type ConnectorFilterProperties = FilterProperties & {
  categories?: (
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  )[]
  ccmConnectorFilter?: CcmConnectorFilter
  connectivityStatuses?: ('SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN')[]
  connectorIdentifiers?: string[]
  connectorNames?: string[]
  description?: string
  inheritingCredentialsFromDelegate?: boolean
  types?: (
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
  )[]
}

export interface ConnectorInfoDTO {
  description?: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec: ConnectorConfigDTO
  tags?: {
    [key: string]: string
  }
  type:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
}

export interface ConnectorResponse {
  activityDetails?: ConnectorActivityDetails
  connector?: ConnectorInfoDTO
  createdAt?: number
  entityValidityDetails?: EntityValidityDetails
  gitDetails?: EntityGitDetails
  harnessManaged?: boolean
  lastModifiedAt?: number
  status?: ConnectorConnectivityDetails
}

export interface ConnectorStatistics {
  statusStats?: ConnectorStatusStatistics[]
  typeStats?: ConnectorTypeStatistics[]
}

export interface ConnectorStatusStatistics {
  count?: number
  status?: 'SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN'
}

export interface ConnectorTypeStatistics {
  count?: number
  type?:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
}

export interface ConnectorValidationResult {
  delegateId?: string
  errorSummary?: string
  errors?: ErrorDetail[]
  status?: 'SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN'
  testedAt?: number
}

export interface ContainerResource {
  limits: Limits
}

export interface ContextElement {
  elementType?:
    | 'SERVICE'
    | 'INFRAMAPPING'
    | 'SERVICE_TEMPLATE'
    | 'TAG'
    | 'SHELL'
    | 'HOST'
    | 'INSTANCE'
    | 'STANDARD'
    | 'PARAM'
    | 'PARTITION'
    | 'OTHER'
    | 'FORK'
    | 'CONTAINER_SERVICE'
    | 'CLUSTER'
    | 'AWS_LAMBDA_FUNCTION'
    | 'AMI_SERVICE_SETUP'
    | 'AMI_SERVICE_DEPLOY'
    | 'ECS_SERVICE_SETUP'
    | 'AMI_SWITCH_ROUTES'
    | 'PCF_SERVICE_SETUP'
    | 'PCF_SERVICE_DEPLOY'
    | 'PCF_ROUTE_SWAP_ROLLBACK'
    | 'PCF_INSTANCE'
    | 'SPOTINST_SERVICE_SETUP'
    | 'SPOTINST_SERVICE_DEPLOY'
    | 'ARTIFACT'
    | 'ARTIFACT_VARIABLE'
    | 'HELM_DEPLOY'
    | 'CLOUD_FORMATION_PROVISION'
    | 'CLOUD_FORMATION_ROLLBACK'
    | 'CLOUD_FORMATION_DEPROVISION'
    | 'TERRAFORM_PROVISION'
    | 'SHELL_SCRIPT_PROVISION'
    | 'K8S'
    | 'TERRAFORM_INHERIT_PLAN'
    | 'TERRAGRUNT_INHERIT_PLAN'
    | 'AZURE_VMSS_SETUP'
    | 'AZURE_WEBAPP_SETUP'
    | 'HELM_CHART'
    | 'MANIFEST_VARIABLE'
  name?: string
  uuid?: string
}

export type CountInstanceSelection = InstanceSelectionBase & {
  count?: ParameterFieldString
}

export interface CreateInvite {
  inviteType: 'USER_INITIATED_INVITE' | 'ADMIN_INITIATED_INVITE' | 'SCIM_INITIATED_INVITE'
  roleBindings?: RoleBinding[]
  userGroups?: string[]
  users: string[]
}

export interface CreatePRDTO {
  prNumber?: number
}

export interface CriteriaSpec {
  [key: string]: any
}

export interface CriteriaSpecWrapper {
  spec: CriteriaSpec
  type: 'Jexl' | 'KeyValues'
}

export interface CrossAccountAccess {
  crossAccountRoleArn: string
  externalId?: string
}

export type CustomHealthConnectorDTO = ConnectorConfigDTO & {
  baseURL: string
  delegateSelectors?: string[]
  headers?: CustomHealthKeyAndValue[]
  method: 'GET' | 'POST'
  params?: CustomHealthKeyAndValue[]
  validationBody?: string
  validationPath?: string
}

export interface CustomHealthKeyAndValue {
  encryptedValueRef?: SecretRefData
  key: string
  value?: string
  valueEncrypted?: boolean
}

export type CustomRestrictionDTO = RestrictionDTO & { [key: string]: any }

export type CustomRestrictionMetadataDTO = RestrictionMetadataDTO & {}

export interface DOMConfiguration {
  parameterNames?: DOMStringList
}

export interface DOMImplementation {
  [key: string]: any
}

export interface DOMStringList {
  length?: number
}

export interface DashboardExecutionStatusInfo {
  active?: ExecutionStatusInfo[]
  failure?: ExecutionStatusInfo[]
  pending?: ExecutionStatusInfo[]
}

export interface DashboardWorkloadDeployment {
  workloadDeploymentInfoList?: WorkloadDeploymentInfo[]
}

export type DatadogConnectorDTO = ConnectorConfigDTO & {
  apiKeyRef: string
  applicationKeyRef: string
  delegateSelectors?: string[]
  url: string
}

export interface DelegateConfiguration {
  accountVersion?: boolean
  action?: 'SELF_DESTRUCT'
  delegateVersions?: string[]
}

export type DelegateFilterProperties = FilterProperties & {
  delegateGroupIdentifier?: string
  delegateName?: string
  delegateType?: string
  description?: string
  hostName?: string
  status?: 'ENABLED' | 'WAITING_FOR_APPROVAL' | 'DISABLED' | 'DELETED'
}

export interface DelegateMetaInfo {
  hostName?: string
  id?: string
}

export interface DelegateProfileDetailsNg {
  accountId?: string
  approvalRequired?: boolean
  createdAt?: number
  createdBy?: EmbeddedUserDetails
  description?: string
  identifier?: string
  lastUpdatedAt?: number
  lastUpdatedBy?: EmbeddedUserDetails
  name?: string
  numberOfDelegates?: number
  orgIdentifier?: string
  primary?: boolean
  projectIdentifier?: string
  scopingRules?: ScopingRuleDetailsNg[]
  selectors?: string[]
  startupScript?: string
  uuid?: string
}

export interface DelegateProfileFilterProperties {
  approvalRequired?: boolean
  description?: string
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
  identifier?: string
  name?: string
  selectors?: string[]
  tags?: {
    [key: string]: string
  }
}

export interface DelegateResponseData {
  [key: string]: any
}

export type DeleteManifestPathSpec = DeleteResourcesBaseSpec & {
  allManifestPaths?: boolean
  manifestPaths?: string[]
}

export type DeleteReleaseNameSpec = DeleteResourcesBaseSpec & {
  deleteNamespace?: boolean
}

export type DeleteResourceNameSpec = DeleteResourcesBaseSpec & {
  resourceNames: string[]
}

export interface DeleteResourcesBaseSpec {
  [key: string]: any
}

export interface DeleteResourcesWrapper {
  spec?: DeleteResourcesBaseSpec
  type?: 'ResourceName' | 'ReleaseName' | 'ManifestPath'
}

export interface Deployment {
  count?: number
}

export interface DeploymentChangeRates {
  failureRate?: number
  failureRateChangeRate?: number
  frequency?: number
  frequencyChangeRate?: number
}

export interface DeploymentCount {
  failure?: number
  success?: number
  total?: number
}

export interface DeploymentDateAndCount {
  deployments?: Deployment
  time?: number
}

export interface DeploymentInfo {
  count?: number
  countList?: DeploymentDateAndCount[]
  rate?: number
}

export type DeploymentStageConfig = StageInfoConfig & {
  execution: ExecutionElementConfig
  infrastructure: PipelineInfrastructure
  serviceConfig: ServiceConfig
}

export interface DeploymentStatsSummary {
  deploymentRate?: number
  deploymentRateChangeRate?: number
  failureRate?: number
  failureRateChangeRate?: number
  timeBasedDeploymentInfoList?: TimeBasedDeploymentInfo[]
  totalCount?: number
  totalCountChangeRate?: number
}

export interface DeploymentsInfo {
  deployments?: ExecutionStatusInfo[]
}

export interface Distribution {
  bucketBy: string
  variations: WeightedVariation[]
}

export interface DistributionYamlSpec {
  bucketBy: string
  clauses?: ClauseYamlSpec[]
  variations?: VariationYamlSpec[]
}

export interface DockerAuthCredentialsDTO {
  [key: string]: any
}

export interface DockerAuthenticationDTO {
  spec?: DockerAuthCredentialsDTO
  type: 'UsernamePassword' | 'Anonymous'
}

export interface DockerBuildDetailsDTO {
  buildUrl?: string
  imagePath?: string
  labels?: {
    [key: string]: string
  }
  metadata?: {
    [key: string]: string
  }
  tag?: string
}

export type DockerConnectorDTO = ConnectorConfigDTO & {
  auth?: DockerAuthenticationDTO
  delegateSelectors?: string[]
  dockerRegistryUrl: string
  providerType: 'DockerHub' | 'Harbor' | 'Quay' | 'Other'
}

export type DockerHubArtifactConfig = ArtifactConfig & {
  connectorRef: string
  imagePath: string
  metadata?: string
  tag?: string
  tagRegex?: string
}

export interface DockerRequestDTO {
  tag?: string
  tagRegex?: string
  tagsList?: string[]
}

export interface DockerResponseDTO {
  buildDetailsList?: DockerBuildDetailsDTO[]
}

export type DockerUserNamePasswordDTO = DockerAuthCredentialsDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface Document {
  attributes?: NamedNodeMap
  baseURI?: string
  childNodes?: NodeList
  doctype?: DocumentType
  documentElement?: Element
  documentURI?: string
  domConfig?: DOMConfiguration
  firstChild?: Node
  implementation?: DOMImplementation
  inputEncoding?: string
  lastChild?: Node
  localName?: string
  namespaceURI?: string
  nextSibling?: Node
  nodeName?: string
  nodeType?: number
  nodeValue?: string
  ownerDocument?: Document
  parentNode?: Node
  prefix?: string
  previousSibling?: Node
  strictErrorChecking?: boolean
  textContent?: string
  xmlEncoding?: string
  xmlStandalone?: boolean
  xmlVersion?: string
}

export interface DocumentType {
  attributes?: NamedNodeMap
  baseURI?: string
  childNodes?: NodeList
  entities?: NamedNodeMap
  firstChild?: Node
  internalSubset?: string
  lastChild?: Node
  localName?: string
  name?: string
  namespaceURI?: string
  nextSibling?: Node
  nodeName?: string
  nodeType?: number
  nodeValue?: string
  notations?: NamedNodeMap
  ownerDocument?: Document
  parentNode?: Node
  prefix?: string
  previousSibling?: Node
  publicId?: string
  systemId?: string
  textContent?: string
}

export type DurationRestrictionDTO = RestrictionDTO & {
  timeUnit?: TimeUnit
}

export type DurationRestrictionMetadataDTO = RestrictionMetadataDTO & {
  timeUnit?: TimeUnit
}

export type DynatraceConnectorDTO = ConnectorConfigDTO & {
  apiTokenRef: string
  delegateSelectors?: string[]
  url: string
}

export type EcrArtifactConfig = ArtifactConfig & {
  connectorRef: string
  imagePath: string
  metadata?: string
  region: string
  tag?: string
  tagRegex?: string
}

export interface EcrBuildDetailsDTO {
  buildUrl?: string
  imagePath?: string
  labels?: {
    [key: string]: string
  }
  metadata?: {
    [key: string]: string
  }
  tag?: string
}

export interface EcrListImagesDTO {
  images?: string[]
}

export interface EcrRequestDTO {
  region?: string
  tag?: string
  tagRegex?: string
  tagsList?: string[]
}

export interface EcrResponseDTO {
  buildDetailsList?: EcrBuildDetailsDTO[]
}

export interface EditionActionDTO {
  action?:
    | 'START_FREE'
    | 'START_TRIAL'
    | 'EXTEND_TRIAL'
    | 'SUBSCRIBE'
    | 'UPGRADE'
    | 'CONTACT_SALES'
    | 'CONTACT_SUPPORT'
    | 'MANAGE'
    | 'DISABLED_BY_TEAM'
    | 'DISABLED_BY_ENTERPRISE'
  reason?: string
}

export interface Element {
  attributes?: NamedNodeMap
  baseURI?: string
  childNodes?: NodeList
  firstChild?: Node
  lastChild?: Node
  localName?: string
  namespaceURI?: string
  nextSibling?: Node
  nodeName?: string
  nodeType?: number
  nodeValue?: string
  ownerDocument?: Document
  parentNode?: Node
  prefix?: string
  previousSibling?: Node
  schemaTypeInfo?: TypeInfo
  tagName?: string
  textContent?: string
}

export type EmailConfig = NotificationSettingConfig & {
  groupEmail?: string
}

export type EmailConfigDTO = NotificationSettingConfigDTO & {
  groupEmail: string
}

export interface EmbeddedUser {
  email?: string
  name?: string
  uuid?: string
}

export interface EmbeddedUserDetails {
  email?: string
  name?: string
  uuid?: string
}

export interface EntityDetail {
  entityRef?: EntityReference
  name?: string
  type?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
}

export interface EntityGitDetails {
  branch?: string
  filePath?: string
  objectId?: string
  repoIdentifier?: string
  repoName?: string
  rootFolder?: string
}

export interface EntityReference {
  accountIdentifier?: string
  branch?: string
  default?: boolean
  identifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoIdentifier?: string
}

export type EntityReferredByPipelineSetupUsageDetail = SetupUsageDetail & {
  identifier?: string
  referenceType?: string
}

export interface EntitySetupUsageDTO {
  accountIdentifier?: string
  createdAt?: number
  detail?: SetupUsageDetail
  referredByEntity: EntityDetail
  referredEntity?: EntityDetail
}

export interface EntityValidityDetails {
  invalidYaml?: string
  valid?: boolean
}

export interface EnvBuildIdAndInstanceCountInfo {
  buildIdAndInstanceCountList?: BuildIdAndInstanceCount[]
  envId?: string
  envName?: string
}

export interface EnvBuildIdAndInstanceCountInfoList {
  envBuildIdAndInstanceCountInfoList?: EnvBuildIdAndInstanceCountInfo[]
}

export interface EnvCount {
  newCount?: number
  totalCount?: number
}

export type EnvFilter = Filter & {
  filterTypes?: string[]
}

export interface EnvIdCountPair {
  count?: number
  envId?: string
}

export interface Environment {
  identifier: string
  type: 'PreProduction' | 'Production'
}

export interface EnvironmentRequestDTO {
  color?: string
  description?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  type: 'PreProduction' | 'Production'
  version?: number
}

export interface EnvironmentResponse {
  createdAt?: number
  environment?: EnvironmentResponseDTO
  lastModifiedAt?: number
}

export interface EnvironmentResponseDTO {
  accountId?: string
  color?: string
  deleted?: boolean
  description?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  type?: 'PreProduction' | 'Production'
  version?: number
}

export interface EnvironmentYaml {
  description?: string
  identifier: string
  name: string
  tags?: {
    [key: string]: string
  }
  type: 'PreProduction' | 'Production'
}

export interface Error {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
  correlationId?: string
  detailedMessage?: string
  message?: string
  metadata?: ErrorMetadataDTO
  responseMessages?: ResponseMessage[]
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ErrorDetail {
  code?: number
  message?: string
  reason?: string
}

export interface ErrorMetadataDTO {
  type?: string
}

export interface ExecutionDataValue {
  displayName?: string
  value?: { [key: string]: any }
}

export interface ExecutionDeployment {
  deployments?: DeploymentCount
  time?: number
}

export interface ExecutionDeploymentInfo {
  executionDeploymentList?: ExecutionDeployment[]
}

export interface ExecutionElementConfig {
  rollbackSteps?: ExecutionWrapperConfig[]
  steps: ExecutionWrapperConfig[]
}

export interface ExecutionStatusInfo {
  author?: AuthorInfo
  endTs?: number
  gitInfo?: GitInfo
  pipelineIdentifier?: string
  pipelineName?: string
  planExecutionId?: string
  serviceInfoList?: ServiceDeploymentInfo[]
  startTs?: number
  status?: string
  triggerType?: string
}

export interface ExecutionTarget {
  connectorRef?: string
  host?: string
  workingDirectory?: string
}

export interface ExecutionWrapperConfig {
  parallel?: ParallelStepElementConfig
  step?: StepElementConfig
  stepGroup?: StepGroupElementConfig
}

export interface Failure {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
  correlationId?: string
  errors?: ValidationError[]
  message?: string
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface FailureStrategyActionConfig {
  type: 'Ignore' | 'Retry' | 'MarkAsSuccess' | 'Abort' | 'StageRollback' | 'StepGroupRollback' | 'ManualIntervention'
}

export interface FailureStrategyConfig {
  onFailure: OnFailureConfig
}

export type FeatureFlagStageConfig = StageInfoConfig & {}

export interface FeatureRestrictionDetailListRequestDTO {
  names: (
    | 'TEST1'
    | 'TEST2'
    | 'TEST3'
    | 'TEST4'
    | 'TEST5'
    | 'TEST6'
    | 'TEST7'
    | 'PERSPECTIVES'
    | 'CCM_K8S_CLUSTERS'
    | 'CCM_AUTOSTOPPING_RULES'
    | 'MULTIPLE_ORGANIZATIONS'
    | 'MULTIPLE_PROJECTS'
    | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
    | 'INTEGRATED_APPROVALS_WITH_JIRA'
    | 'SECRET_MANAGERS'
    | 'DEPLOYMENTS'
    | 'INITIAL_DEPLOYMENTS'
    | 'DEPLOYMENTS_PER_MONTH'
    | 'SERVICES'
    | 'BUILDS'
    | 'SAML_SUPPORT'
    | 'OAUTH_SUPPORT'
    | 'LDAP_SUPPORT'
    | 'TWO_FACTOR_AUTH_SUPPORT'
    | 'CUSTOM_ROLES'
    | 'CUSTOM_RESOURCE_GROUPS'
    | 'MAX_TOTAL_BUILDS'
    | 'MAX_BUILDS_PER_MONTH'
    | 'ACTIVE_COMMITTERS'
    | 'TEST_INTELLIGENCE'
    | 'TEMPLATE_SERVICE'
    | 'K8S_BG_SWAP_SERVICES'
    | 'K8S_BLUE_GREEN_DEPLOY'
    | 'K8S_APPLY'
    | 'K8S_DELETE'
    | 'K8S_CANARY_DELETE'
    | 'K8S_ROLLING_DEPLOY'
    | 'K8S_CANARY_DEPLOY'
    | 'K8S_SCALE'
    | 'K8S_ROLLING_ROLLBACK'
    | 'TERRAFORM_APPLY'
    | 'TERRAFORM_PLAN'
    | 'TERRAFORM_DESTROY'
    | 'TERRAFORM_ROLLBACK'
    | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
  )[]
}

export interface FeatureRestrictionDetailRequestDTO {
  name:
    | 'TEST1'
    | 'TEST2'
    | 'TEST3'
    | 'TEST4'
    | 'TEST5'
    | 'TEST6'
    | 'TEST7'
    | 'PERSPECTIVES'
    | 'CCM_K8S_CLUSTERS'
    | 'CCM_AUTOSTOPPING_RULES'
    | 'MULTIPLE_ORGANIZATIONS'
    | 'MULTIPLE_PROJECTS'
    | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
    | 'INTEGRATED_APPROVALS_WITH_JIRA'
    | 'SECRET_MANAGERS'
    | 'DEPLOYMENTS'
    | 'INITIAL_DEPLOYMENTS'
    | 'DEPLOYMENTS_PER_MONTH'
    | 'SERVICES'
    | 'BUILDS'
    | 'SAML_SUPPORT'
    | 'OAUTH_SUPPORT'
    | 'LDAP_SUPPORT'
    | 'TWO_FACTOR_AUTH_SUPPORT'
    | 'CUSTOM_ROLES'
    | 'CUSTOM_RESOURCE_GROUPS'
    | 'MAX_TOTAL_BUILDS'
    | 'MAX_BUILDS_PER_MONTH'
    | 'ACTIVE_COMMITTERS'
    | 'TEST_INTELLIGENCE'
    | 'TEMPLATE_SERVICE'
    | 'K8S_BG_SWAP_SERVICES'
    | 'K8S_BLUE_GREEN_DEPLOY'
    | 'K8S_APPLY'
    | 'K8S_DELETE'
    | 'K8S_CANARY_DELETE'
    | 'K8S_ROLLING_DEPLOY'
    | 'K8S_CANARY_DEPLOY'
    | 'K8S_SCALE'
    | 'K8S_ROLLING_ROLLBACK'
    | 'TERRAFORM_APPLY'
    | 'TERRAFORM_PLAN'
    | 'TERRAFORM_DESTROY'
    | 'TERRAFORM_ROLLBACK'
    | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
}

export interface FeatureRestrictionDetailsDTO {
  allowed?: boolean
  description?: string
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
  name?:
    | 'TEST1'
    | 'TEST2'
    | 'TEST3'
    | 'TEST4'
    | 'TEST5'
    | 'TEST6'
    | 'TEST7'
    | 'PERSPECTIVES'
    | 'CCM_K8S_CLUSTERS'
    | 'CCM_AUTOSTOPPING_RULES'
    | 'MULTIPLE_ORGANIZATIONS'
    | 'MULTIPLE_PROJECTS'
    | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
    | 'INTEGRATED_APPROVALS_WITH_JIRA'
    | 'SECRET_MANAGERS'
    | 'DEPLOYMENTS'
    | 'INITIAL_DEPLOYMENTS'
    | 'DEPLOYMENTS_PER_MONTH'
    | 'SERVICES'
    | 'BUILDS'
    | 'SAML_SUPPORT'
    | 'OAUTH_SUPPORT'
    | 'LDAP_SUPPORT'
    | 'TWO_FACTOR_AUTH_SUPPORT'
    | 'CUSTOM_ROLES'
    | 'CUSTOM_RESOURCE_GROUPS'
    | 'MAX_TOTAL_BUILDS'
    | 'MAX_BUILDS_PER_MONTH'
    | 'ACTIVE_COMMITTERS'
    | 'TEST_INTELLIGENCE'
    | 'TEMPLATE_SERVICE'
    | 'K8S_BG_SWAP_SERVICES'
    | 'K8S_BLUE_GREEN_DEPLOY'
    | 'K8S_APPLY'
    | 'K8S_DELETE'
    | 'K8S_CANARY_DELETE'
    | 'K8S_ROLLING_DEPLOY'
    | 'K8S_CANARY_DEPLOY'
    | 'K8S_SCALE'
    | 'K8S_ROLLING_ROLLBACK'
    | 'TERRAFORM_APPLY'
    | 'TERRAFORM_PLAN'
    | 'TERRAFORM_DESTROY'
    | 'TERRAFORM_ROLLBACK'
    | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
  restriction?: RestrictionDTO
  restrictionType?:
    | 'AVAILABILITY'
    | 'STATIC_LIMIT'
    | 'RATE_LIMIT'
    | 'CUSTOM'
    | 'DURATION'
    | 'LICENSE_RATE_LIMIT'
    | 'LICENSE_STATIC_LIMIT'
}

export interface FeatureRestrictionMetadataDTO {
  edition?: 'COMMUNITY' | 'FREE' | 'TEAM' | 'ENTERPRISE'
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
  name?:
    | 'TEST1'
    | 'TEST2'
    | 'TEST3'
    | 'TEST4'
    | 'TEST5'
    | 'TEST6'
    | 'TEST7'
    | 'PERSPECTIVES'
    | 'CCM_K8S_CLUSTERS'
    | 'CCM_AUTOSTOPPING_RULES'
    | 'MULTIPLE_ORGANIZATIONS'
    | 'MULTIPLE_PROJECTS'
    | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
    | 'INTEGRATED_APPROVALS_WITH_JIRA'
    | 'SECRET_MANAGERS'
    | 'DEPLOYMENTS'
    | 'INITIAL_DEPLOYMENTS'
    | 'DEPLOYMENTS_PER_MONTH'
    | 'SERVICES'
    | 'BUILDS'
    | 'SAML_SUPPORT'
    | 'OAUTH_SUPPORT'
    | 'LDAP_SUPPORT'
    | 'TWO_FACTOR_AUTH_SUPPORT'
    | 'CUSTOM_ROLES'
    | 'CUSTOM_RESOURCE_GROUPS'
    | 'MAX_TOTAL_BUILDS'
    | 'MAX_BUILDS_PER_MONTH'
    | 'ACTIVE_COMMITTERS'
    | 'TEST_INTELLIGENCE'
    | 'TEMPLATE_SERVICE'
    | 'K8S_BG_SWAP_SERVICES'
    | 'K8S_BLUE_GREEN_DEPLOY'
    | 'K8S_APPLY'
    | 'K8S_DELETE'
    | 'K8S_CANARY_DELETE'
    | 'K8S_ROLLING_DEPLOY'
    | 'K8S_CANARY_DEPLOY'
    | 'K8S_SCALE'
    | 'K8S_ROLLING_ROLLBACK'
    | 'TERRAFORM_APPLY'
    | 'TERRAFORM_PLAN'
    | 'TERRAFORM_DESTROY'
    | 'TERRAFORM_ROLLBACK'
    | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
  restrictionMetadata?: {
    [key: string]: RestrictionMetadataDTO
  }
}

export interface FeedbackFormDTO {
  accountId?: string
  email?: string
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
  score?: number
  suggestion?: string
}

export interface FieldValues {
  fieldValues?: {
    [key: string]: string[]
  }
}

export interface Filter {
  ids?: string[]
}

export interface FilterDTO {
  filterProperties: FilterProperties
  filterVisibility?: 'EveryOne' | 'OnlyCreator'
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface FilterProperties {
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
  tags?: {
    [key: string]: string
  }
}

export type FlagConfigurationStepInfo = StepSpecType & {
  environment: string
  feature: string
  instructions: PatchInstruction[]
}

export interface FlowControlConfig {
  barriers?: BarrierInfoConfig[]
}

export interface GatewayAccountRequestDTO {
  accountName?: string
  companyName?: string
  createdFromNG?: boolean
  defaultExperience?: 'NG' | 'CG'
  nextGenEnabled?: boolean
  uuid?: string
}

export interface GcpBillingExportSpec {
  datasetId: string
  tableId: string
}

export type GcpCloudCostConnector = ConnectorConfigDTO & {
  billingExportSpec?: GcpBillingExportSpec
  featuresEnabled?: ('BILLING' | 'OPTIMIZATION' | 'VISIBILITY')[]
  projectId: string
  serviceAccountEmail: string
}

export type GcpConnector = ConnectorConfigDTO & {
  credential?: GcpConnectorCredential
  delegateSelectors?: string[]
}

export interface GcpConnectorCredential {
  spec?: GcpCredentialSpec
  type: 'InheritFromDelegate' | 'ManualConfig'
}

export interface GcpCredentialSpec {
  [key: string]: any
}

export type GcpKmsConnectorDTO = ConnectorConfigDTO & {
  credentials: string
  default?: boolean
  delegateSelectors?: string[]
  keyName?: string
  keyRing?: string
  projectId?: string
  region?: string
}

export type GcpManualDetails = GcpCredentialSpec & {
  secretKeyRef: string
}

export interface GcpResponseDTO {
  clusterNames?: string[]
}

export type GcrArtifactConfig = ArtifactConfig & {
  connectorRef: string
  imagePath: string
  metadata?: string
  registryHostname: string
  tag?: string
  tagRegex?: string
}

export interface GcrBuildDetailsDTO {
  buildUrl?: string
  imagePath?: string
  labels?: {
    [key: string]: string
  }
  metadata?: {
    [key: string]: string
  }
  tag?: string
}

export interface GcrRequestDTO {
  registryHostname?: string
  tag?: string
  tagRegex?: string
  tagsList?: string[]
}

export interface GcrResponseDTO {
  buildDetailsList?: GcrBuildDetailsDTO[]
}

export type GcsStoreConfig = StoreConfig & {
  bucketName?: string
  connectorRef?: string
  folderPath?: string
  metadata?: string
}

export type GenericEntityFilter = Filter & {
  filterType?: string
}

export interface GitAuthenticationDTO {
  [key: string]: any
}

export interface GitBranchDTO {
  branchName?: string
  branchSyncStatus?: 'SYNCED' | 'SYNCING' | 'UNSYNCED'
}

export interface GitBranchListDTO {
  branches?: PageGitBranchDTO
  defaultBranch?: GitBranchDTO
}

export type GitConfigDTO = ConnectorConfigDTO & {
  branchName?: string
  connectionType: 'Account' | 'Repo'
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
  spec: GitAuthenticationDTO
  type: 'Http' | 'Ssh'
  url: string
  validationRepo?: string
}

export interface GitEnabledDTO {
  connectivityMode?: 'MANAGER' | 'DELEGATE'
  gitSyncEnabled?: boolean
}

export interface GitEntityBranchFilterSummaryProperties {
  entityTypes?: (
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  )[]
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
  searchTerm?: string
}

export interface GitEntityFilterProperties {
  entityTypes?: (
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  )[]
  gitSyncConfigIdentifiers?: string[]
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
  searchTerm?: string
}

export interface GitFileContent {
  content?: string
  objectId?: string
}

export interface GitFullSyncConfigDTO {
  accountIdentifier?: string
  baseBranch?: string
  branch?: string
  createPullRequest?: boolean
  message?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoIdentifier?: string
}

export interface GitFullSyncConfigRequestDTO {
  baseBranch?: string
  branch: string
  createPullRequest?: boolean
  message?: string
  repoIdentifier: string
}

export interface GitFullSyncEntityInfoDTO {
  accountIdentifier?: string
  branch?: string
  entityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  errorMessages?: string[]
  filePath?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repo?: string
  retryCount?: number
  syncStatus?: 'QUEUED' | 'PUSHED' | 'FAILED'
}

export type GitHTTPAuthenticationDTO = GitAuthenticationDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface GitInfo {
  commit?: string
  commitID?: string
  eventType?: string
  repoName?: string
  sourceBranch?: string
  targetBranch?: string
}

export type GitLabStore = StoreConfig & {
  branch?: string
  commitId?: string
  connectorRef: string
  folderPath?: string
  gitFetchType: 'Branch' | 'Commit'
  metadata?: string
  paths?: string[]
  repoName?: string
}

export interface GitOpsInfoDTO {
  type?: 'CONNECTED_ARGO_PROVIDER' | 'MANAGED_ARGO_PROVIDER'
}

export interface GitOpsProvider {
  description?: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec: GitOpsInfoDTO
  tags?: {
    [key: string]: string
  }
}

export interface GitPRCreateRequest {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  sourceBranch: string
  targetBranch: string
  title: string
  useUserFromToken?: boolean
  yamlGitConfigRef: string
}

export type GitSSHAuthenticationDTO = GitAuthenticationDTO & {
  sshKeyRef: string
}

export type GitStore = StoreConfig & {
  branch?: string
  commitId?: string
  connectorRef: string
  folderPath?: string
  gitFetchType: 'Branch' | 'Commit'
  metadata?: string
  paths?: string[]
  repoName?: string
}

export interface GitSyncConfig {
  branch?: string
  gitConnectorRef?: string
  gitConnectorType: 'Github' | 'Gitlab' | 'Bitbucket'
  gitSyncFolderConfigDTOs?: GitSyncFolderConfigDTO[]
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repo?: string
}

export interface GitSyncEntityDTO {
  accountId?: string
  branch?: string
  entityGitPath?: string
  entityIdentifier?: string
  entityName?: string
  entityReference?: EntityReference
  entityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  folderPath?: string
  gitConnectorId?: string
  repoProviderType?: 'github' | 'gitlab' | 'bitbucket' | 'unknown'
  repoUrl?: string
}

export interface GitSyncEntityListDTO {
  count?: number
  entityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  gitSyncEntities?: GitSyncEntityDTO[]
}

export interface GitSyncErrorAggregateByCommitDTO {
  branchName?: string
  commitMessage?: string
  createdAt?: number
  errorsForSummaryView?: GitSyncErrorDTO[]
  failedCount?: number
  gitCommitId?: string
  repoId?: string
}

export interface GitSyncErrorCountDTO {
  connectivityErrorCount?: number
  gitToHarnessErrorCount?: number
}

export interface GitSyncErrorDTO {
  accountIdentifier?: string
  additionalErrorDetails?: GitSyncErrorDetailsDTO
  branchName?: string
  changeType?: 'ADD' | 'RENAME' | 'MODIFY' | 'DELETE' | 'NONE'
  completeFilePath?: string
  createdAt?: number
  entityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  errorType?: 'GIT_TO_HARNESS' | 'CONNECTIVITY_ISSUE' | 'FULL_SYNC'
  failureReason?: string
  repoId?: string
  repoUrl?: string
  scopes?: Scope[]
  status?: 'ACTIVE' | 'DISCARDED' | 'EXPIRED' | 'RESOLVED' | 'OVERRIDDEN'
}

export interface GitSyncErrorDetailsDTO {
  [key: string]: any
}

export interface GitSyncFolderConfigDTO {
  isDefault?: boolean
  rootFolder?: string
}

export interface GitSyncRepoFiles {
  gitSyncConfigIdentifier?: string
  gitSyncEntityLists?: GitSyncEntityListDTO[]
}

export interface GitSyncRepoFilesList {
  gitSyncRepoFilesList?: GitSyncRepoFiles[]
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
}

export interface GitSyncSettingsDTO {
  accountIdentifier: string
  executeOnDelegate: boolean
  organizationIdentifier: string
  projectIdentifier: string
}

export interface GithubApiAccess {
  spec?: GithubApiAccessSpecDTO
  type: 'GithubApp' | 'Token'
}

export interface GithubApiAccessSpecDTO {
  [key: string]: any
}

export type GithubAppSpec = GithubApiAccessSpecDTO & {
  applicationId: string
  installationId: string
  privateKeyRef: string
}

export interface GithubAuthentication {
  spec: GithubCredentialsDTO
  type: 'Http' | 'Ssh'
}

export type GithubConnector = ConnectorConfigDTO & {
  apiAccess?: GithubApiAccess
  authentication: GithubAuthentication
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
  type: 'Account' | 'Repo'
  url: string
  validationRepo?: string
}

export interface GithubCredentialsDTO {
  [key: string]: any
}

export type GithubHttpCredentials = GithubCredentialsDTO & {
  spec: GithubHttpCredentialsSpecDTO
  type: 'UsernamePassword' | 'UsernameToken'
}

export interface GithubHttpCredentialsSpecDTO {
  [key: string]: any
}

export type GithubSCMDTO = SourceCodeManagerDTO & {
  authentication?: GithubAuthentication
}

export type GithubSshCredentials = GithubCredentialsDTO & {
  sshKeyRef: string
}

export type GithubStore = StoreConfig & {
  branch?: string
  commitId?: string
  connectorRef: string
  folderPath?: string
  gitFetchType: 'Branch' | 'Commit'
  metadata?: string
  paths?: string[]
  repoName?: string
}

export type GithubTokenSpec = GithubApiAccessSpecDTO & {
  tokenRef: string
}

export type GithubUsernamePassword = GithubHttpCredentialsSpecDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type GithubUsernameToken = GithubHttpCredentialsSpecDTO & {
  tokenRef: string
  username?: string
  usernameRef?: string
}

export interface GitlabApiAccess {
  spec?: GitlabApiAccessSpecDTO
  type: 'Token'
}

export interface GitlabApiAccessSpecDTO {
  [key: string]: any
}

export interface GitlabAuthentication {
  spec: GitlabCredentialsDTO
  type: 'Http' | 'Ssh'
}

export type GitlabConnector = ConnectorConfigDTO & {
  apiAccess?: GitlabApiAccess
  authentication: GitlabAuthentication
  delegateSelectors?: string[]
  type: 'Account' | 'Repo'
  url: string
  validationRepo?: string
}

export interface GitlabCredentialsDTO {
  [key: string]: any
}

export type GitlabHttpCredentials = GitlabCredentialsDTO & {
  spec: GitlabHttpCredentialsSpecDTO
  type: 'UsernamePassword' | 'UsernameToken' | 'Kerberos'
}

export interface GitlabHttpCredentialsSpecDTO {
  [key: string]: any
}

export type GitlabKerberos = GitlabHttpCredentialsSpecDTO & {
  kerberosKeyRef: string
}

export type GitlabSCMDTO = SourceCodeManagerDTO & {
  authentication: GitlabAuthentication
}

export type GitlabSshCredentials = GitlabCredentialsDTO & {
  sshKeyRef: string
}

export type GitlabTokenSpec = GitlabApiAccessSpecDTO & {
  tokenRef: string
}

export type GitlabUsernamePassword = GitlabHttpCredentialsSpecDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type GitlabUsernameToken = GitlabHttpCredentialsSpecDTO & {
  tokenRef: string
  username?: string
  usernameRef?: string
}

export interface GitopsProviderResponse {
  description?: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec: GitOpsInfoDTO
  tags?: {
    [key: string]: string
  }
}

export type HarnessApprovalStepInfo = StepSpecType & {
  approvalMessage: string
  approverInputs?: ApproverInputInfo[]
  approvers: Approvers
  includePipelineExecutionHistory: boolean
}

export interface HarnessServiceInfoNG {
  envId?: string
  infraMappingId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceId?: string
}

export interface HealthDeploymentDashboard {
  healthDeploymentInfo?: HealthDeploymentInfo
}

export interface HealthDeploymentInfo {
  failure?: DeploymentInfo
  success?: DeploymentInfo
  total?: TotalDeploymentInfo
}

export type HelmChartManifest = ManifestAttributes & {
  chartName?: string
  chartVersion?: string
  commandFlags?: HelmManifestCommandFlag[]
  helmVersion?: 'V2' | 'V3'
  metadata?: string
  skipResourceVersioning?: boolean
  store?: StoreConfigWrapper
}

export type HelmDeployStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export interface HelmManifestCommandFlag {
  commandType:
    | 'Fetch'
    | 'Template'
    | 'Pull'
    | 'Install'
    | 'Upgrade'
    | 'Rollback'
    | 'History'
    | 'Delete'
    | 'Uninstall'
    | 'List'
  flag?: string
}

export type HelmRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
}

export interface HoldingScope {
  nodeSetupId: string
  scope: string
}

export interface HttpHeaderConfig {
  key?: string
  value?: string
}

export interface HttpHelmAuthCredentialsDTO {
  [key: string]: any
}

export interface HttpHelmAuthenticationDTO {
  spec?: HttpHelmAuthCredentialsDTO
  type: 'UsernamePassword' | 'Anonymous'
}

export type HttpHelmConnectorDTO = ConnectorConfigDTO & {
  auth?: HttpHelmAuthenticationDTO
  delegateSelectors?: string[]
  helmRepoUrl: string
}

export type HttpHelmUsernamePasswordDTO = HttpHelmAuthCredentialsDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type HttpStateExecutionData = DelegateResponseData & {
  assertionStatement?: string
  assertionStatus?: string
  delegateMetaInfo?: DelegateMetaInfo
  document?: Document
  element?: ContextElement
  endTs?: number
  errorMsg?: string
  executionDetails?: {
    [key: string]: ExecutionDataValue
  }
  executionSummary?: {
    [key: string]: ExecutionDataValue
  }
  header?: string
  headers?: KeyValuePair[]
  httpMethod?: string
  httpResponseBody?: string
  httpResponseCode?: number
  httpUrl?: string
  startTs?: number
  stateName?: string
  stateParams?: {
    [key: string]: { [key: string]: any }
  }
  stateType?: string
  status?:
    | 'ABORTED'
    | 'DISCONTINUING'
    | 'ERROR'
    | 'FAILED'
    | 'NEW'
    | 'PAUSED'
    | 'PAUSING'
    | 'QUEUED'
    | 'RESUMED'
    | 'RUNNING'
    | 'SCHEDULED'
    | 'STARTING'
    | 'SUCCESS'
    | 'WAITING'
    | 'SKIPPED'
    | 'ABORTING'
    | 'REJECTED'
    | 'EXPIRED'
    | 'PREPARING'
  templateVariable?: {
    [key: string]: { [key: string]: any }
  }
  useProxy?: boolean
  waitInterval?: number
  warningMessage?: string
}

export type HttpStepInfo = StepSpecType & {
  assertion?: string
  delegateSelectors?: string[]
  headers?: HttpHeaderConfig[]
  method: string
  outputVariables?: NGVariable[]
  requestBody?: string
  url: string
}

export type HttpStoreConfig = StoreConfig & {
  connectorRef?: string
  metadata?: string
}

export type IdentifierRef = EntityReference & {
  isDefault?: boolean
  metadata?: {
    [key: string]: string
  }
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type IgnoreFailureActionConfig = FailureStrategyActionConfig & {
  type: 'Ignore'
}

export interface InfraExecutionSummary {
  identifier?: string
  name?: string
  type?: string
}

export interface InfraOverrides {
  environment?: EnvironmentYaml
  infrastructureDefinition?: InfrastructureDef
}

export interface InfraUseFromStage {
  overrides?: InfraOverrides
  stage: string
}

export interface Infrastructure {
  [key: string]: any
}

export interface InfrastructureDef {
  provisioner?: ExecutionElementConfig
  spec: Infrastructure
  type: 'KubernetesDirect' | 'KubernetesGcp'
}

export interface InfrastructureDetails {
  [key: string]: any
}

export type InlineTerraformBackendConfigSpec = TerraformBackendConfigSpec & {
  content?: string
}

export type InlineTerraformVarFileSpec = TerraformVarFileSpec & {
  content?: string
}

export type InputSetReference = EntityReference & {
  isDefault?: boolean
  pipelineIdentifier?: string
}

export interface InputSetValidator {
  parameters?: string
  validatorType?: 'ALLOWED_VALUES' | 'REGEX'
}

export interface InstanceCountDetailsByEnvTypeAndServiceId {
  instanceCountDetailsByEnvTypeBaseMap?: {
    [key: string]: InstanceCountDetailsByEnvTypeBase
  }
}

export interface InstanceCountDetailsByEnvTypeBase {
  nonProdInstances?: number
  prodInstances?: number
  totalInstances?: number
}

export interface InstanceDetailsByBuildId {
  buildId?: string
  instances?: InstanceDetailsDTO[]
}

export interface InstanceDetailsDTO {
  artifactName?: string
  connectorRef?: string
  deployedAt?: number
  deployedById?: string
  deployedByName?: string
  infrastructureDetails?: InfrastructureDetails
  pipelineExecutionName?: string
  podName?: string
  terraformInstance?: string
}

export interface InstanceSelectionBase {
  [key: string]: any
}

export interface InstanceSelectionWrapper {
  spec?: InstanceSelectionBase
  type?: 'Count' | 'Percentage'
}

export interface InstancesByBuildIdList {
  instancesByBuildIdList?: InstanceDetailsByBuildId[]
}

export interface Invite {
  accountIdentifier: string
  approved?: boolean
  email: string
  id: string
  inviteType: 'USER_INITIATED_INVITE' | 'ADMIN_INITIATED_INVITE' | 'SCIM_INITIATED_INVITE'
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  roleBindings?: RoleBinding[]
  userGroups?: string[]
}

export type JexlCriteriaSpec = CriteriaSpec & {
  expression: string
}

export type JiraApprovalStepInfo = StepSpecType & {
  approvalCriteria: CriteriaSpecWrapper
  connectorRef: string
  delegateSelectors?: string[]
  issueKey: string
  rejectionCriteria?: CriteriaSpecWrapper
}

export type JiraConnector = ConnectorConfigDTO & {
  delegateSelectors?: string[]
  jiraUrl: string
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type JiraCreateStepInfo = StepSpecType & {
  connectorRef: string
  delegateSelectors?: string[]
  fields?: JiraField[]
  issueType: string
  projectKey: string
}

export interface JiraField {
  name?: string
  value: string
}

export interface JiraFieldAllowedValueNG {
  id?: string
  name?: string
  value?: string
}

export interface JiraFieldNG {
  allowedValues: JiraFieldAllowedValueNG[]
  custom?: boolean
  key: string
  name: string
  required?: boolean
  schema: JiraFieldSchemaNG
}

export interface JiraFieldSchemaNG {
  array?: boolean
  customType?: string
  type: 'string' | 'number' | 'date' | 'datetime' | 'timetracking' | 'option'
  typeStr: string
}

export interface JiraIssueCreateMetadataNG {
  projects?: {
    [key: string]: JiraProjectNG
  }
}

export interface JiraIssueTypeNG {
  description?: string
  fields: {
    [key: string]: JiraFieldNG
  }
  id: string
  name: string
  statuses: JiraStatusNG[]
  subTask?: boolean
}

export interface JiraIssueUpdateMetadataNG {
  fields: {
    [key: string]: JiraFieldNG
  }
}

export interface JiraProjectBasicNG {
  id: string
  key: string
  name: string
}

export interface JiraProjectNG {
  id: string
  issuetypes: {
    [key: string]: JiraIssueTypeNG
  }
  key: string
  name: string
}

export interface JiraStatusCategoryNG {
  id: number
  key: string
  name: string
}

export interface JiraStatusNG {
  id: string
  name: string
  statusCategory?: JiraStatusCategoryNG
}

export type JiraUpdateStepInfo = StepSpecType & {
  connectorRef: string
  delegateSelectors?: string[]
  fields?: JiraField[]
  issueKey: string
  transitionTo?: TransitionTo
}

export interface JsonNode {
  array?: boolean
  bigDecimal?: boolean
  bigInteger?: boolean
  binary?: boolean
  boolean?: boolean
  containerNode?: boolean
  double?: boolean
  float?: boolean
  floatingPointNumber?: boolean
  int?: boolean
  integralNumber?: boolean
  long?: boolean
  missingNode?: boolean
  nodeType?: 'ARRAY' | 'BINARY' | 'BOOLEAN' | 'MISSING' | 'NULL' | 'NUMBER' | 'OBJECT' | 'POJO' | 'STRING'
  null?: boolean
  number?: boolean
  object?: boolean
  pojo?: boolean
  short?: boolean
  textual?: boolean
  valueNode?: boolean
}

export type K8SDirectInfrastructure = Infrastructure & {
  connectorRef: string
  namespace: string
  releaseName: string
}

export type K8sApplyStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  filePaths?: string[]
  skipDryRun?: boolean
  skipSteadyStateCheck?: boolean
}

export type K8sBGSwapServicesStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  skipDryRun?: boolean
}

export type K8sBlueGreenStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  skipDryRun?: boolean
}

export type K8sCanaryDeleteStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  skipDryRun?: boolean
}

export type K8sCanaryStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  instanceSelection: InstanceSelectionWrapper
  skipDryRun?: boolean
}

export type K8sDeleteStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  deleteResources: DeleteResourcesWrapper
  skipDryRun?: boolean
}

export type K8sGcpInfrastructure = Infrastructure & {
  cluster: string
  connectorRef: string
  metadata?: string
  namespace: string
  releaseName: string
}

export type K8sInfrastructureDetails = InfrastructureDetails & {
  namespace?: string
  releaseName?: string
}

export type K8sManifest = ManifestAttributes & {
  metadata?: string
  skipResourceVersioning?: ParameterFieldBoolean
  store?: StoreConfigWrapper
}

export type K8sRollingRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  skipDryRun?: boolean
}

export type K8sRollingStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  skipDryRun?: boolean
}

export type K8sScaleStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  instanceSelection: InstanceSelectionWrapper
  skipDryRun?: boolean
  skipSteadyStateCheck?: boolean
  workload: string
}

export type KerberosConfigDTO = BaseSSHSpecDTO & {
  principal: string
  realm: string
  spec?: TGTGenerationSpecDTO
  tgtGenerationMethod?: 'KeyTabFilePath' | 'Password'
}

export interface KeyValuePair {
  key?: string
  value?: string
}

export type KeyValuesCriteriaSpec = CriteriaSpec & {
  conditions: Condition[]
  matchAnyCondition?: boolean
}

export interface KubernetesAuthCredentialDTO {
  [key: string]: any
}

export interface KubernetesAuthDTO {
  spec: KubernetesAuthCredentialDTO
  type: 'UsernamePassword' | 'ClientKeyCert' | 'ServiceAccount' | 'OpenIdConnect'
}

export type KubernetesClientKeyCertDTO = KubernetesAuthCredentialDTO & {
  caCertRef?: string
  clientCertRef: string
  clientKeyAlgo?: string
  clientKeyPassphraseRef?: string
  clientKeyRef: string
}

export type KubernetesClusterConfigDTO = ConnectorConfigDTO & {
  credential: KubernetesCredentialDTO
  delegateSelectors?: string[]
}

export type KubernetesClusterDetailsDTO = KubernetesCredentialSpecDTO & {
  auth: KubernetesAuthDTO
  masterUrl: string
}

export interface KubernetesCredentialDTO {
  spec?: KubernetesCredentialSpecDTO
  type: 'InheritFromDelegate' | 'ManualConfig'
}

export interface KubernetesCredentialSpecDTO {
  [key: string]: any
}

export type KubernetesOpenIdConnectDTO = KubernetesAuthCredentialDTO & {
  oidcClientIdRef: string
  oidcIssuerUrl?: string
  oidcPasswordRef: string
  oidcScopes?: string
  oidcSecretRef?: string
  oidcUsername?: string
  oidcUsernameRef?: string
}

export type KubernetesServiceAccountDTO = KubernetesAuthCredentialDTO & {
  serviceAccountTokenRef: string
}

export type KubernetesServiceSpec = ServiceSpec & {
  metadata?: string
}

export type KubernetesUserNamePasswordDTO = KubernetesAuthCredentialDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type KustomizeManifest = ManifestAttributes & {
  metadata?: string
  pluginPath?: string
  skipResourceVersioning?: ParameterFieldBoolean
  store?: StoreConfigWrapper
}

export type KustomizePatchesManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export type LDAPSettings = NGAuthSettings & {
  connectionSettings: LdapConnectionSettings
  groupSettingsList?: LdapGroupSettings[]
  identifier: string
  userSettingsList?: LdapUserSettings[]
}

export interface LandingDashboardRequestCD {
  orgProjectIdentifiers: OrgProjectIdentifier[]
}

export interface LastWorkloadInfo {
  deploymentType?: string
  endTime?: number
  startTime?: number
  status?: string
}

export interface LdapConnectionSettings {
  bindDN?: string
  bindPassword?: string
  connectTimeout?: number
  host: string
  maxReferralHops?: number
  port?: number
  referralsEnabled?: boolean
  responseTimeout?: number
  sslEnabled?: boolean
  useRecursiveGroupMembershipSearch?: boolean
}

export interface LdapGroupSettings {
  baseDN?: string
  descriptionAttr?: string
  nameAttr?: string
  referencedUserAttr?: string
  searchFilter?: string
  userMembershipAttr?: string
}

export type LdapSettings = SSOSettings & {
  connectionSettings: LdapConnectionSettings
  cronExpression?: string
  groupSettings?: LdapGroupSettings
  groupSettingsList?: LdapGroupSettings[]
  userSettings?: LdapUserSettings
  userSettingsList?: LdapUserSettings[]
}

export interface LdapUserSettings {
  baseDN?: string
  displayNameAttr?: string
  emailAttr?: string
  groupMembershipAttr?: string
  searchFilter?: string
  uidAttr?: string
}

export interface LicenseInfo {
  accountStatus?: string
  accountType?: string
  expiryTime?: number
  licenseUnits?: number
}

export type LicenseRateLimitRestrictionDTO = RestrictionDTO & {
  count?: number
  fieldName?: string
  limit?: number
  timeUnit?: TimeUnit
}

export type LicenseRateLimitRestrictionMetadataDTO = RestrictionMetadataDTO & {
  fieldName?: string
  limit?: number
  timeUnit?: TimeUnit
}

export type LicenseStaticLimitRestrictionDTO = RestrictionDTO & {
  count?: number
  fieldName?: string
  limit?: number
}

export type LicenseStaticLimitRestrictionMetadataDTO = RestrictionMetadataDTO & {
  fieldName?: string
  limit?: number
}

export interface LicenseUsageDTO {
  accountIdentifier?: string
  module?: string
  timestamp?: number
}

export interface LicensesWithSummaryDTO {
  edition?: 'COMMUNITY' | 'FREE' | 'TEAM' | 'ENTERPRISE'
  licenseType?: 'TRIAL' | 'PAID'
  maxExpiryTime?: number
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
}

export interface Limits {
  cpu?: string
  memory?: string
}

export type LocalConnectorDTO = ConnectorConfigDTO & {
  default?: boolean
}

export interface LoginSettings {
  accountId: string
  lastUpdatedAt?: number
  lastUpdatedBy?: EmbeddedUser
  passwordExpirationPolicy: PasswordExpirationPolicy
  passwordStrengthPolicy: PasswordStrengthPolicy
  userLockoutPolicy: UserLockoutPolicy
  uuid: string
}

export interface LoginTypeResponse {
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  defaultExperience?: 'NG' | 'CG'
  oauthEnabled?: boolean
  showCaptcha?: boolean
  ssorequest?: SSORequest
}

export type ManagedArgoGitOpsInfoDTO = GitOpsInfoDTO & {
  namespace: string
}

export interface ManifestAttributes {
  [key: string]: any
}

export interface ManifestConfig {
  identifier: string
  spec: ManifestAttributes
  type:
    | 'HelmChart'
    | 'K8sManifest'
    | 'Kustomize'
    | 'KustomizePatches'
    | 'OpenshiftParam'
    | 'OpenshiftTemplate'
    | 'Values'
}

export interface ManifestConfigWrapper {
  manifest?: ManifestConfig
}

export interface ManifestOverrideSetWrapper {
  overrideSet?: ManifestOverrideSets
}

export interface ManifestOverrideSets {
  identifier?: string
  manifests?: ManifestConfigWrapper[]
}

export interface ManualFailureSpecConfig {
  onTimeout: OnTimeoutConfig
  timeout: string
}

export type ManualInterventionFailureActionConfig = FailureStrategyActionConfig & {
  spec: ManualFailureSpecConfig
  type: 'ManualIntervention'
}

export type MarkAsSuccessFailureActionConfig = FailureStrategyActionConfig & {
  type: 'MarkAsSuccess'
}

export interface Member {
  display?: string
  ref?: string
  value?: string
}

export type MicrosoftTeamsConfig = NotificationSettingConfig & {
  microsoftTeamsWebhookUrl?: string
}

export type MicrosoftTeamsConfigDTO = NotificationSettingConfigDTO & {
  microsoftTeamsWebhookUrl: string
}

export interface ModuleLicenseDTO {
  accountIdentifier?: string
  createdAt?: number
  edition?: 'COMMUNITY' | 'FREE' | 'TEAM' | 'ENTERPRISE'
  expiryTime?: number
  id?: string
  lastModifiedAt?: number
  licenseType?: 'TRIAL' | 'PAID'
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
  startTime?: number
  status?: 'ACTIVE' | 'DELETED' | 'EXPIRED'
}

export interface NGAuthSettings {
  settingsType?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
}

export interface NGProperties {
  ci?: CIProperties
}

export interface NGTag {
  key: string
  value: string
}

export interface NGVariable {
  description?: string
  metadata?: string
  name?: string
  required?: boolean
  type?: 'String' | 'Number' | 'Secret'
}

export interface NGVariableOverrideSetWrapper {
  overrideSet?: NGVariableOverrideSets
}

export interface NGVariableOverrideSets {
  identifier?: string
  variables?: NGVariable[]
}

export interface NamedNodeMap {
  length?: number
}

export type NativeHelmServiceSpec = ServiceSpec & {
  metadata?: string
}

export type NewRelicConnectorDTO = ConnectorConfigDTO & {
  apiKeyRef: string
  delegateSelectors?: string[]
  newRelicAccountId: string
  url: string
}

export interface NexusAuthCredentials {
  [key: string]: any
}

export interface NexusAuthentication {
  spec?: NexusAuthCredentials
  type: 'UsernamePassword' | 'Anonymous'
}

export type NexusConnector = ConnectorConfigDTO & {
  auth?: NexusAuthentication
  delegateSelectors?: string[]
  nexusServerUrl: string
  version: string
}

export type NexusUsernamePasswordAuth = NexusAuthCredentials & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface NgSmtpDTO {
  accountId?: string
  name: string
  uuid?: string
  value: SmtpConfigDTO
}

export interface Node {
  attributes?: NamedNodeMap
  baseURI?: string
  childNodes?: NodeList
  firstChild?: Node
  lastChild?: Node
  localName?: string
  namespaceURI?: string
  nextSibling?: Node
  nodeName?: string
  nodeType?: number
  nodeValue?: string
  ownerDocument?: Document
  parentNode?: Node
  prefix?: string
  previousSibling?: Node
  textContent?: string
}

export interface NodeList {
  length?: number
}

export interface NotificationChannelWrapper {
  spec?: PmsNotificationChannel
  type?: string
}

export interface NotificationRules {
  enabled?: boolean
  name?: string
  notificationMethod?: NotificationChannelWrapper
  pipelineEvents?: PipelineEvent[]
}

export interface NotificationSettingConfig {
  type: 'EMAIL' | 'SLACK' | 'PAGERDUTY' | 'MSTEAMS'
}

export interface NotificationSettingConfigDTO {
  type?: 'EMAIL' | 'SLACK' | 'PAGERDUTY' | 'MSTEAMS'
}

export interface NotificationSettings {
  emailAddresses: string[]
  microsoftTeamsWebhookUrl?: string
  pagerDutyIntegrationKey?: string
  sendMailToNewMembers?: boolean
  slackConfig: SlackNotificationSetting
  useIndividualEmails?: boolean
}

export type NumberNGVariable = NGVariable & {
  default?: number
  name?: string
  type?: 'Number'
  value: number
}

export interface OAuthSettings {
  allowedProviders?: ('AZURE' | 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'GOOGLE' | 'LINKEDIN')[]
  filter?: string
  settingsType?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
}

export interface OAuthSignupDTO {
  email?: string
  name?: string
  utmInfo?: UtmInfo
}

export type OauthSettings = SSOSettings & {
  allowedProviders?: ('AZURE' | 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'GOOGLE' | 'LINKEDIN')[]
  filter?: string
}

export type OktaAddOperation = PatchOperation & {
  value?: JsonNode
}

export type OktaRemoveOperation = PatchOperation & {
  value?: JsonNode
}

export type OktaReplaceOperation = PatchOperation & {
  value?: JsonNode
}

export interface OnFailureConfig {
  action: FailureStrategyActionConfig
  errors: (
    | 'Unknown'
    | 'AllErrors'
    | 'Authentication'
    | 'Connectivity'
    | 'Timeout'
    | 'Authorization'
    | 'Verification'
    | 'DelegateProvisioning'
  )[]
}

export interface OnRetryFailureConfig {
  action?: FailureStrategyActionConfig
}

export interface OnTimeoutConfig {
  action?: FailureStrategyActionConfig
}

export type OpenshiftManifest = ManifestAttributes & {
  metadata?: string
  skipResourceVersioning?: ParameterFieldBoolean
  store?: StoreConfigWrapper
}

export type OpenshiftParamManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export interface OrgProjectIdentifier {
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface Organization {
  description?: string
  identifier: string
  name: string
  tags?: {
    [key: string]: string
  }
}

export interface OrganizationAggregateDTO {
  admins?: UserMetadataDTO[]
  collaborators?: UserMetadataDTO[]
  connectorsCount?: number
  delegatesCount?: number
  organizationResponse: OrganizationResponse
  projectsCount?: number
  secretsCount?: number
  templatesCount?: number
}

export interface OrganizationRequest {
  organization: Organization
}

export interface OrganizationResponse {
  createdAt?: number
  harnessManaged?: boolean
  lastModifiedAt?: number
  organization: Organization
}

export type PRBuildSpec = BuildSpec & {
  number: string
}

export interface Page {
  content?: { [key: string]: any }[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageActivity {
  content?: Activity[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PageActivitySummary {
  content?: ActivitySummary[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PageApiKeyAggregateDTO {
  content?: ApiKeyAggregateDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageConnectorResponse {
  content?: ConnectorResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageEntitySetupUsageDTO {
  content?: EntitySetupUsageDTO[]
  empty?: boolean
  first?: boolean
  last?: boolean
  number?: number
  numberOfElements?: number
  pageable?: Pageable
  size?: number
  sort?: Sort
  totalElements?: number
  totalPages?: number
}

export interface PageEnvironmentResponse {
  content?: EnvironmentResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageEnvironmentResponseDTO {
  content?: EnvironmentResponseDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageFilterDTO {
  content?: FilterDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageGitBranchDTO {
  content?: GitBranchDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageGitFullSyncEntityInfoDTO {
  content?: GitFullSyncEntityInfoDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageGitSyncEntityListDTO {
  content?: GitSyncEntityListDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageGitSyncErrorAggregateByCommitDTO {
  content?: GitSyncErrorAggregateByCommitDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageGitSyncErrorDTO {
  content?: GitSyncErrorDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageGitopsProviderResponse {
  content?: GitopsProviderResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageInvite {
  content?: Invite[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageOrganizationAggregateDTO {
  content?: OrganizationAggregateDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageOrganizationResponse {
  content?: OrganizationResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageProject {
  content?: Project[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageProjectAggregateDTO {
  content?: ProjectAggregateDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageProjectResponse {
  content?: ProjectResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageRoleAssignmentResponse {
  content?: RoleAssignmentResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageSecretResponseWrapper {
  content?: SecretResponseWrapper[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageServiceAccountAggregateDTO {
  content?: ServiceAccountAggregateDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageServiceResponse {
  content?: ServiceResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageServiceResponseDTO {
  content?: ServiceResponseDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageTokenAggregateDTO {
  content?: TokenAggregateDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageUserAggregate {
  content?: UserAggregate[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageUserGroupAggregateDTO {
  content?: UserGroupAggregateDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageUserGroupDTO {
  content?: UserGroupDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageUserMetadataDTO {
  content?: UserMetadataDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface Pageable {
  offset?: number
  pageNumber?: number
  pageSize?: number
  paged?: boolean
  sort?: Sort
  unpaged?: boolean
}

export type PagerDutyConfig = NotificationSettingConfig & {
  pagerDutyKey?: string
}

export type PagerDutyConfigDTO = NotificationSettingConfigDTO & {
  pagerDutyKey: string
}

export type PagerDutyConnectorDTO = ConnectorConfigDTO & {
  apiTokenRef: string
  delegateSelectors?: string[]
}

export type ParallelStageElementConfig = StageElementWrapperConfig[]

export type ParallelStepElementConfig = ExecutionWrapperConfig[]

export interface ParameterField {
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: { [key: string]: any }
}

export interface ParameterFieldBoolean {
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: boolean
}

export interface ParameterFieldString {
  expression?: boolean
  expressionValue?: string
  inputSetValidator?: InputSetValidator
  jsonResponseField?: boolean
  responseField?: string
  typeString?: boolean
  value?: string
}

export interface PartialSchemaDTO {
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
  namespace?: string
  nodeName?: string
  nodeType?: string
  schema?: JsonNode
}

export interface PasswordChangeDTO {
  currentPassword?: string
  newPassword?: string
}

export interface PasswordExpirationPolicy {
  daysBeforePasswordExpires?: number
  daysBeforeUserNotifiedOfPasswordExpiration?: number
  enabled?: boolean
}

export interface PasswordStrengthPolicy {
  enabled?: boolean
  minNumberOfCharacters?: number
  minNumberOfDigits?: number
  minNumberOfLowercaseCharacters?: number
  minNumberOfSpecialCharacters?: number
  minNumberOfUppercaseCharacters?: number
}

export interface PatchInstruction {
  type?:
    | 'SetFeatureFlagState'
    | 'SetOnVariation'
    | 'SetOffVariation'
    | 'SetDefaultVariations'
    | 'AddRule'
    | 'UpdateRule'
    | 'AddTargetsToVariationTargetMap'
    | 'RemoveTargetsToVariationTargetMap'
    | 'AddSegmentToVariationTargetMap'
    | 'RemoveSegmentsToVariationTargetMap'
}

export interface PatchOperation {
  path?: string
}

export interface PatchRequest {
  Operations: PatchOperation[]
  externalId?: string
  id?: string
  meta?: JsonNode
  schemas: string[]
}

export type PercentageInstanceSelection = InstanceSelectionBase & {
  percentage?: ParameterFieldString
}

export interface PermissionCheck {
  permission?: string
  resourceIdentifier?: string
  resourceScope?: ResourceScope
  resourceType?: string
}

export interface PipelineConfig {
  pipeline?: PipelineInfoConfig
}

export interface PipelineEvent {
  forStages?: string[]
  type?:
    | 'AllEvents'
    | 'PipelineStart'
    | 'PipelineSuccess'
    | 'PipelineFailed'
    | 'PipelineEnd'
    | 'PipelinePaused'
    | 'StageSuccess'
    | 'StageFailed'
    | 'StageStart'
    | 'StepFailed'
}

export interface PipelineExecutionDashboardInfo {
  accountIdentifier?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  planExecutionId?: string
  projectIdentifier?: string
  startTs?: number
}

export type PipelineFilterProperties = FilterProperties & {
  description?: string
  moduleProperties?: {
    [key: string]: { [key: string]: any }
  }
  name?: string
  pipelineIdentifiers?: string[]
  pipelineTags?: NGTag[]
}

export interface PipelineInfoConfig {
  description?: string
  flowControl?: FlowControlConfig
  identifier: string
  name: string
  notificationRules?: NotificationRules[]
  orgIdentifier?: string
  projectIdentifier?: string
  properties?: NGProperties
  stages?: StageElementWrapperConfig[]
  tags?: {
    [key: string]: string
  }
  timeout?: string
  variables?: NGVariable[]
}

export interface PipelineInfrastructure {
  allowSimultaneousDeployments?: boolean
  environment?: EnvironmentYaml
  environmentRef?: string
  infrastructureDefinition?: InfrastructureDef
  infrastructureKey?: string
  useFromStage?: InfraUseFromStage
}

export interface PipelinesExecutionDashboardInfo {
  failed24HrsExecutions?: PipelineExecutionDashboardInfo[]
  pendingApprovalExecutions?: PipelineExecutionDashboardInfo[]
  pendingManualInterventionExecutions?: PipelineExecutionDashboardInfo[]
  runningExecutions?: PipelineExecutionDashboardInfo[]
}

export type PmsEmailChannel = PmsNotificationChannel & {
  recipients?: string[]
  userGroups?: string[]
}

export type PmsMSTeamChannel = PmsNotificationChannel & {
  msTeamKeys?: string[]
  userGroups?: string[]
}

export interface PmsNotificationChannel {
  [key: string]: any
}

export type PmsPagerDutyChannel = PmsNotificationChannel & {
  integrationKey?: string
  userGroups?: string[]
}

export type PmsSlackChannel = PmsNotificationChannel & {
  userGroups?: string[]
  webhookUrl?: string
}

export interface PollingResponseDTO {
  pollingResponse?: string[]
}

export interface PrimaryArtifact {
  spec: ArtifactConfig
  type: 'DockerRegistry' | 'Gcr' | 'Ecr'
}

export interface Principal {
  identifier: string
  type: 'USER' | 'USER_GROUP' | 'SERVICE' | 'API_KEY' | 'SERVICE_ACCOUNT'
}

export interface Project {
  color?: string
  description?: string
  identifier: string
  modules?: ('CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE')[]
  name: string
  orgIdentifier?: string
  tags?: {
    [key: string]: string
  }
}

export interface ProjectAggregateDTO {
  admins?: UserMetadataDTO[]
  collaborators?: UserMetadataDTO[]
  harnessManagedOrg?: boolean
  organization?: Organization
  projectResponse: ProjectResponse
}

export interface ProjectDashBoardInfo {
  accountId?: string
  deploymentsCount?: number
  deploymentsCountChangeRate?: number
  failedDeploymentsCount?: number
  orgIdentifier?: string
  projectIdentifier?: string
  successDeploymentsCount?: number
}

export interface ProjectRequest {
  project: Project
}

export interface ProjectResponse {
  createdAt?: number
  lastModifiedAt?: number
  project: Project
}

export interface ProjectsDashboardInfo {
  projectDashBoardInfoList?: ProjectDashBoardInfo[]
}

export type PrometheusConnectorDTO = ConnectorConfigDTO & {
  delegateSelectors?: string[]
  url: string
}

export interface RateLimitProtection {
  incorrectAttemptTimestamps?: number[]
  lastNotificationSentToSecOpsAt?: number
  lastNotificationSentToUserAt?: number
  totalIncorrectAttempts?: number
}

export type RateLimitRestrictionDTO = RestrictionDTO & {
  count?: number
  limit?: number
  timeUnit?: TimeUnit
}

export type RateLimitRestrictionMetadataDTO = RestrictionMetadataDTO & {
  allowedIfEqual?: boolean
  limit?: number
  timeUnit?: TimeUnit
}

export type RemoteTerraformVarFileSpec = TerraformVarFileSpec & {
  store: StoreConfigWrapper
}

export type RemoveOperation = PatchOperation & {
  value?: JsonNode
}

export type RemoveSegmentToVariationTargetMapYaml = PatchInstruction & {
  identifier: string
  spec: RemoveSegmentToVariationTargetMapYamlSpec
  type: 'RemoveSegmentToVariationTargetMap'
}

export interface RemoveSegmentToVariationTargetMapYamlSpec {
  segments: string[]
  variation: string
}

export type RemoveTargetsToVariationTargetMapYaml = PatchInstruction & {
  identifier: string
  spec: RemoveTargetsToVariationTargetMapYamlSpec
  type: 'RemoveTargetsToVariationTargetMap'
}

export interface RemoveTargetsToVariationTargetMapYamlSpec {
  targets: string[]
  variation: string
}

export type ReplaceOperation = PatchOperation & {
  value?: JsonNode
}

export type ResourceConstraintStepInfo = StepSpecType & {
  acquireMode: 'ENSURE' | 'ACCUMULATE'
  holdingScope: HoldingScope
  name: string
  permits: number
  resourceUnit: string
}

export interface ResourceDTO {
  identifier: string
  labels?: {
    [key: string]: string
  }
  type:
    | 'ORGANIZATION'
    | 'PROJECT'
    | 'USER_GROUP'
    | 'SECRET'
    | 'RESOURCE_GROUP'
    | 'USER'
    | 'ROLE'
    | 'ROLE_ASSIGNMENT'
    | 'PIPELINE'
    | 'TRIGGER'
    | 'TEMPLATE'
    | 'INPUT_SET'
    | 'DELEGATE_CONFIGURATION'
    | 'SERVICE'
    | 'ENVIRONMENT'
    | 'DELEGATE'
    | 'SERVICE_ACCOUNT'
    | 'CONNECTOR'
    | 'API_KEY'
    | 'TOKEN'
    | 'DELEGATE_TOKEN'
}

export interface ResourceGroup {
  identifier?: string
  name?: string
}

export interface ResourceScope {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ResourceScopeDTO {
  accountIdentifier?: string
  labels?: {
    [key: string]: string
  }
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface Response {
  correlationId?: string
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAccountDTO {
  correlationId?: string
  data?: AccountDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAccountLicenseDTO {
  correlationId?: string
  data?: AccountLicenseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAccountResourcesDTO {
  correlationId?: string
  data?: AccountResourcesDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseActiveProjectsCountDTO {
  correlationId?: string
  data?: ActiveProjectsCountDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseActiveServiceInstanceSummary {
  correlationId?: string
  data?: ActiveServiceInstanceSummary
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAddUsersResponse {
  correlationId?: string
  data?: AddUsersResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseApiKeyAggregateDTO {
  correlationId?: string
  data?: ApiKeyAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseApiKeyDTO {
  correlationId?: string
  data?: ApiKeyDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBoolean {
  correlationId?: string
  data?: boolean
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCDPipelineModuleInfo {
  correlationId?: string
  data?: CDPipelineModuleInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCDStageModuleInfo {
  correlationId?: string
  data?: CDStageModuleInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseConnectivityCheckSummary {
  correlationId?: string
  data?: ConnectivityCheckSummary
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseConnectorCatalogueResponse {
  correlationId?: string
  data?: ConnectorCatalogueResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseConnectorResponse {
  correlationId?: string
  data?: ConnectorResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseConnectorStatistics {
  correlationId?: string
  data?: ConnectorStatistics
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseConnectorValidationResult {
  correlationId?: string
  data?: ConnectorValidationResult
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCreatePRDTO {
  correlationId?: string
  data?: CreatePRDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardExecutionStatusInfo {
  correlationId?: string
  data?: DashboardExecutionStatusInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDashboardWorkloadDeployment {
  correlationId?: string
  data?: DashboardWorkloadDeployment
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDeploymentStatsSummary {
  correlationId?: string
  data?: DeploymentStatsSummary
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDeploymentsInfo {
  correlationId?: string
  data?: DeploymentsInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDockerBuildDetailsDTO {
  correlationId?: string
  data?: DockerBuildDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDockerResponseDTO {
  correlationId?: string
  data?: DockerResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEcrBuildDetailsDTO {
  correlationId?: string
  data?: EcrBuildDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEcrListImagesDTO {
  correlationId?: string
  data?: EcrListImagesDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEcrResponseDTO {
  correlationId?: string
  data?: EcrResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvBuildIdAndInstanceCountInfoList {
  correlationId?: string
  data?: EnvBuildIdAndInstanceCountInfoList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvCount {
  correlationId?: string
  data?: EnvCount
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvironmentResponse {
  correlationId?: string
  data?: EnvironmentResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseEnvironmentResponseDTO {
  correlationId?: string
  data?: EnvironmentResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseExecutionDeploymentInfo {
  correlationId?: string
  data?: ExecutionDeploymentInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFeatureRestrictionDetailsDTO {
  correlationId?: string
  data?: FeatureRestrictionDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFeatureRestrictionMetadataDTO {
  correlationId?: string
  data?: FeatureRestrictionMetadataDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFieldValues {
  correlationId?: string
  data?: FieldValues
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFilterDTO {
  correlationId?: string
  data?: FilterDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGcpResponseDTO {
  correlationId?: string
  data?: GcpResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGcrBuildDetailsDTO {
  correlationId?: string
  data?: GcrBuildDetailsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGcrResponseDTO {
  correlationId?: string
  data?: GcrResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitBranchListDTO {
  correlationId?: string
  data?: GitBranchListDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitFileContent {
  correlationId?: string
  data?: GitFileContent
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitFullSyncConfigDTO {
  correlationId?: string
  data?: GitFullSyncConfigDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitSyncErrorCountDTO {
  correlationId?: string
  data?: GitSyncErrorCountDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitSyncRepoFilesList {
  correlationId?: string
  data?: GitSyncRepoFilesList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitSyncSettingsDTO {
  correlationId?: string
  data?: GitSyncSettingsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseGitopsProviderResponse {
  correlationId?: string
  data?: GitopsProviderResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseHealthDeploymentDashboard {
  correlationId?: string
  data?: HealthDeploymentDashboard
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInstanceCountDetailsByEnvTypeAndServiceId {
  correlationId?: string
  data?: InstanceCountDetailsByEnvTypeAndServiceId
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInstancesByBuildIdList {
  correlationId?: string
  data?: InstancesByBuildIdList
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseInvite {
  correlationId?: string
  data?: Invite
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseJiraIssueCreateMetadataNG {
  correlationId?: string
  data?: JiraIssueCreateMetadataNG
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseJiraIssueUpdateMetadataNG {
  correlationId?: string
  data?: JiraIssueUpdateMetadataNG
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseJsonNode {
  correlationId?: string
  data?: JsonNode
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseLicenseUsageDTO {
  correlationId?: string
  data?: LicenseUsageDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseLicensesWithSummaryDTO {
  correlationId?: string
  data?: LicensesWithSummaryDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListApiKeyDTO {
  correlationId?: string
  data?: ApiKeyDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListConnectorResponse {
  correlationId?: string
  data?: ConnectorResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListEnvironmentResponse {
  correlationId?: string
  data?: EnvironmentResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListExecutionStatus {
  correlationId?: string
  data?: (
    | 'Running'
    | 'AsyncWaiting'
    | 'TaskWaiting'
    | 'TimedWaiting'
    | 'Failed'
    | 'Errored'
    | 'IgnoreFailed'
    | 'NotStarted'
    | 'Expired'
    | 'Aborted'
    | 'Discontinuing'
    | 'Queued'
    | 'Paused'
    | 'ResourceWaiting'
    | 'InterventionWaiting'
    | 'ApprovalWaiting'
    | 'Success'
    | 'Suspended'
    | 'Skipped'
    | 'Pausing'
    | 'ApprovalRejected'
    | 'NOT_STARTED'
    | 'INTERVENTION_WAITING'
    | 'APPROVAL_WAITING'
    | 'APPROVAL_REJECTED'
    | 'WAITING'
  )[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListFeatureRestrictionDetailsDTO {
  correlationId?: string
  data?: FeatureRestrictionDetailsDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListFeatureRestrictionMetadataDTO {
  correlationId?: string
  data?: FeatureRestrictionMetadataDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListGitSyncEntityListDTO {
  correlationId?: string
  data?: GitSyncEntityListDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListInviteOperationResponse {
  correlationId?: string
  data?: (
    | 'ACCOUNT_INVITE_ACCEPTED_NEED_PASSWORD'
    | 'ACCOUNT_INVITE_ACCEPTED'
    | 'USER_INVITED_SUCCESSFULLY'
    | 'USER_ALREADY_ADDED'
    | 'USER_ALREADY_INVITED'
    | 'FAIL'
    | 'INVITE_EXPIRED'
    | 'INVITE_INVALID'
  )[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListJiraProjectBasicNG {
  correlationId?: string
  data?: JiraProjectBasicNG[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListJiraStatusNG {
  correlationId?: string
  data?: JiraStatusNG[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListModuleLicenseDTO {
  correlationId?: string
  data?: ModuleLicenseDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListPartialSchemaDTO {
  correlationId?: string
  data?: PartialSchemaDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListProject {
  correlationId?: string
  data?: Project[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListRoleAssignmentResponse {
  correlationId?: string
  data?: RoleAssignmentResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceAccountDTO {
  correlationId?: string
  data?: ServiceAccountDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceDefinitionType {
  correlationId?: string
  data?: ('Kubernetes' | 'NativeHelm')[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceNowFieldNG {
  correlationId?: string
  data?: ServiceNowFieldNG[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceNowTicketTypeDTO {
  correlationId?: string
  data?: ServiceNowTicketTypeDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListServiceResponse {
  correlationId?: string
  data?: ServiceResponse[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListSourceCodeManagerDTO {
  correlationId?: string
  data?: SourceCodeManagerDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListString {
  correlationId?: string
  data?: string[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListUserGroupAggregateDTO {
  correlationId?: string
  data?: UserGroupAggregateDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListUserGroupDTO {
  correlationId?: string
  data?: UserGroupDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseLong {
  correlationId?: string
  data?: number
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapEditionSetEditionActionDTO {
  correlationId?: string
  data?: {
    [key: string]: EditionActionDTO[]
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapModuleTypeLong {
  correlationId?: string
  data?: {
    [key: string]: number
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapServiceDefinitionTypeListExecutionStrategyType {
  correlationId?: string
  data?: {
    [key: string]: ('Basic' | 'Canary' | 'BlueGreen' | 'Rolling' | 'Default')[]
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapStringString {
  correlationId?: string
  data?: {
    [key: string]: string
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'SECRET_MANAGER_ID_NOT_FOUND'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
    | 'ENTITY_REFERENCE_EXCEPTION'
  exception?: Throwable
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
  )[]
  level?: 'INFO' | 'ERROR'
  message?: string
}

export interface ResponseModuleLicenseDTO {
  correlationId?: string
  data?: ModuleLicenseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseNgSmtpDTO {
  correlationId?: string
  data?: NgSmtpDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOptionalHarnessServiceInfoNG {
  correlationId?: string
  data?: HarnessServiceInfoNG
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOptionalInvite {
  correlationId?: string
  data?: Invite
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOrganizationAggregateDTO {
  correlationId?: string
  data?: OrganizationAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOrganizationResponse {
  correlationId?: string
  data?: OrganizationResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageActivity {
  correlationId?: string
  data?: PageActivity
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageActivitySummary {
  correlationId?: string
  data?: PageActivitySummary
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageApiKeyAggregateDTO {
  correlationId?: string
  data?: PageApiKeyAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageConnectorResponse {
  correlationId?: string
  data?: PageConnectorResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageEntitySetupUsageDTO {
  correlationId?: string
  data?: PageEntitySetupUsageDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageEnvironmentResponse {
  correlationId?: string
  data?: PageEnvironmentResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageEnvironmentResponseDTO {
  correlationId?: string
  data?: PageEnvironmentResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageFilterDTO {
  correlationId?: string
  data?: PageFilterDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageGitFullSyncEntityInfoDTO {
  correlationId?: string
  data?: PageGitFullSyncEntityInfoDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageGitSyncEntityListDTO {
  correlationId?: string
  data?: PageGitSyncEntityListDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageGitSyncErrorAggregateByCommitDTO {
  correlationId?: string
  data?: PageGitSyncErrorAggregateByCommitDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageGitSyncErrorDTO {
  correlationId?: string
  data?: PageGitSyncErrorDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageGitopsProviderResponse {
  correlationId?: string
  data?: PageGitopsProviderResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageInvite {
  correlationId?: string
  data?: PageInvite
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageOrganizationAggregateDTO {
  correlationId?: string
  data?: PageOrganizationAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageOrganizationResponse {
  correlationId?: string
  data?: PageOrganizationResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageProject {
  correlationId?: string
  data?: PageProject
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageProjectAggregateDTO {
  correlationId?: string
  data?: PageProjectAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageProjectResponse {
  correlationId?: string
  data?: PageProjectResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageRoleAssignmentResponse {
  correlationId?: string
  data?: PageRoleAssignmentResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageSecretResponseWrapper {
  correlationId?: string
  data?: PageSecretResponseWrapper
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageServiceAccountAggregateDTO {
  correlationId?: string
  data?: PageServiceAccountAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageServiceResponse {
  correlationId?: string
  data?: PageServiceResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageServiceResponseDTO {
  correlationId?: string
  data?: PageServiceResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageTokenAggregateDTO {
  correlationId?: string
  data?: PageTokenAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageUserAggregate {
  correlationId?: string
  data?: PageUserAggregate
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageUserGroupAggregateDTO {
  correlationId?: string
  data?: PageUserGroupAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageUserGroupDTO {
  correlationId?: string
  data?: PageUserGroupDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageUserMetadataDTO {
  correlationId?: string
  data?: PageUserMetadataDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePasswordChangeResponse {
  correlationId?: string
  data?: 'PASSWORD_CHANGED' | 'INCORRECT_CURRENT_PASSWORD' | 'PASSWORD_STRENGTH_VIOLATED'
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelineConfig {
  correlationId?: string
  data?: PipelineConfig
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePipelinesExecutionDashboardInfo {
  correlationId?: string
  data?: PipelinesExecutionDashboardInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePollingResponseDTO {
  correlationId?: string
  data?: PollingResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseProjectAggregateDTO {
  correlationId?: string
  data?: ProjectAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseProjectResponse {
  correlationId?: string
  data?: ProjectResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseProjectsDashboardInfo {
  correlationId?: string
  data?: ProjectsDashboardInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRoleAssignmentAggregateResponse {
  correlationId?: string
  data?: RoleAssignmentAggregateResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseRoleAssignmentResponse {
  correlationId?: string
  data?: RoleAssignmentResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSaasGitDTO {
  correlationId?: string
  data?: SaasGitDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSecretManagerMetadataDTO {
  correlationId?: string
  data?: SecretManagerMetadataDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSecretResponseWrapper {
  correlationId?: string
  data?: SecretResponseWrapper
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSecretValidationResultDTO {
  correlationId?: string
  data?: SecretValidationResultDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceAccountAggregateDTO {
  correlationId?: string
  data?: ServiceAccountAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceAccountDTO {
  correlationId?: string
  data?: ServiceAccountDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceDeploymentInfoDTO {
  correlationId?: string
  data?: ServiceDeploymentInfoDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceDeploymentListInfo {
  correlationId?: string
  data?: ServiceDeploymentListInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceDetailsInfoDTO {
  correlationId?: string
  data?: ServiceDetailsInfoDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceHeaderInfo {
  correlationId?: string
  data?: ServiceHeaderInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceResponse {
  correlationId?: string
  data?: ServiceResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServiceResponseDTO {
  correlationId?: string
  data?: ServiceResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServicesCount {
  correlationId?: string
  data?: ServicesCount
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseServicesDashboardInfo {
  correlationId?: string
  data?: ServicesDashboardInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSetHelmCommandFlagType {
  correlationId?: string
  data?: (
    | 'Fetch'
    | 'Template'
    | 'Pull'
    | 'Install'
    | 'Upgrade'
    | 'Rollback'
    | 'History'
    | 'Delete'
    | 'Uninstall'
    | 'List'
  )[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseSourceCodeManagerDTO {
  correlationId?: string
  data?: SourceCodeManagerDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseStepCategory {
  correlationId?: string
  data?: StepCategory
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseString {
  correlationId?: string
  data?: string
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTimeValuePairListDTOEnvIdCountPair {
  correlationId?: string
  data?: TimeValuePairListDTOEnvIdCountPair
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTimeValuePairListDTOInteger {
  correlationId?: string
  data?: TimeValuePairListDTOInteger
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTokenDTO {
  correlationId?: string
  data?: TokenDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTriggerFullSyncResponseDTO {
  correlationId?: string
  data?: TriggerFullSyncResponseDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTwoFactorAuthSettingsInfo {
  correlationId?: string
  data?: TwoFactorAuthSettingsInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseUserAggregate {
  correlationId?: string
  data?: UserAggregate
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseUserGroupAggregateDTO {
  correlationId?: string
  data?: UserGroupAggregateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseUserGroupDTO {
  correlationId?: string
  data?: UserGroupDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseUserInfo {
  correlationId?: string
  data?: UserInfo
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseValidationResultDTO {
  correlationId?: string
  data?: ValidationResultDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseYamlSchemaDetailsWrapper {
  correlationId?: string
  data?: YamlSchemaDetailsWrapper
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseYamlSnippets {
  correlationId?: string
  data?: YamlSnippets
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface RestResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: { [key: string]: any }
  responseMessages?: ResponseMessage[]
}

export interface RestResponseAuthenticationSettingsResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: AuthenticationSettingsResponse
  responseMessages?: ResponseMessage[]
}

export interface RestResponseBoolean {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: boolean
  responseMessages?: ResponseMessage[]
}

export interface RestResponseDelegateProfileDetailsNg {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateProfileDetailsNg
  responseMessages?: ResponseMessage[]
}

export interface RestResponseLoginSettings {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: LoginSettings
  responseMessages?: ResponseMessage[]
}

export interface RestResponseLoginTypeResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: LoginTypeResponse
  responseMessages?: ResponseMessage[]
}

export interface RestResponsePageResponseDelegateProfileDetailsNg {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: DelegateProfileDetailsNg[]
  responseMessages?: ResponseMessage[]
}

export interface RestResponsePasswordStrengthPolicy {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: PasswordStrengthPolicy
  responseMessages?: ResponseMessage[]
}

export interface RestResponseSSOConfig {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: SSOConfig
  responseMessages?: ResponseMessage[]
}

export interface RestResponseUserGroup {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: UserGroup
  responseMessages?: ResponseMessage[]
}

export interface RestResponseUserInfo {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: UserInfo
  responseMessages?: ResponseMessage[]
}

export interface RestResponseVerifyTokenResponseDTO {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: VerifyTokenResponseDTO
  responseMessages?: ResponseMessage[]
}

export interface RestResponseVoid {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: Void
  responseMessages?: ResponseMessage[]
}

export interface RestrictionDTO {
  [key: string]: any
}

export interface RestrictionMetadataDTO {
  restrictionType?:
    | 'AVAILABILITY'
    | 'STATIC_LIMIT'
    | 'RATE_LIMIT'
    | 'CUSTOM'
    | 'DURATION'
    | 'LICENSE_RATE_LIMIT'
    | 'LICENSE_STATIC_LIMIT'
}

export type RetryFailureActionConfig = FailureStrategyActionConfig & {
  spec: RetryFailureSpecConfig
  type: 'Retry'
}

export interface RetryFailureSpecConfig {
  onRetryFailure: OnRetryFailureConfig
  retryCount: number
  retryIntervals: string[]
}

export interface Role {
  allowedScopeLevels?: string[]
  description?: string
  identifier: string
  name: string
  permissions?: string[]
  tags?: {
    [key: string]: string
  }
}

export interface RoleAssignment {
  disabled?: boolean
  identifier?: string
  managed?: boolean
  principal: Principal
  resourceGroupIdentifier: string
  roleIdentifier: string
}

export interface RoleAssignmentAggregateResponse {
  resourceGroups?: ResourceGroup[]
  roleAssignments?: RoleAssignment[]
  roles?: RoleResponse[]
  scope?: Scope
}

export interface RoleAssignmentCreateRequest {
  roleAssignments?: RoleAssignment[]
}

export interface RoleAssignmentFilter {
  disabledFilter?: boolean[]
  harnessManagedFilter?: boolean[]
  principalFilter?: Principal[]
  principalTypeFilter?: ('USER' | 'USER_GROUP' | 'SERVICE' | 'API_KEY' | 'SERVICE_ACCOUNT')[]
  resourceGroupFilter?: string[]
  roleFilter?: string[]
}

export interface RoleAssignmentMetadataDTO {
  identifier: string
  managedRole: boolean
  managedRoleAssignment: boolean
  resourceGroupIdentifier: string
  resourceGroupName: string
  roleIdentifier: string
  roleName: string
}

export interface RoleAssignmentResponse {
  createdAt?: number
  harnessManaged?: boolean
  lastModifiedAt?: number
  roleAssignment: RoleAssignment
  scope: Scope
}

export interface RoleBinding {
  managedRole: boolean
  resourceGroupIdentifier?: string
  resourceGroupName?: string
  roleIdentifier: string
  roleName: string
}

export interface RoleResponse {
  createdAt?: number
  harnessManaged?: boolean
  lastModifiedAt?: number
  role: Role
  scope: Scope
}

export type S3StoreConfig = StoreConfig & {
  bucketName?: string
  connectorRef?: string
  folderPath?: string
  metadata?: string
  region?: string
}

export type SAMLSettings = NGAuthSettings & {
  authorizationEnabled?: boolean
  displayName?: string
  entityIdentifier?: string
  groupMembershipAttr?: string
  identifier: string
  logoutUrl?: string
  origin: string
}

export interface SSHAuthDTO {
  spec: BaseSSHSpecDTO
  type: 'SSH' | 'Kerberos'
}

export type SSHConfigDTO = BaseSSHSpecDTO & {
  credentialType: 'Password' | 'KeyPath' | 'KeyReference'
  spec: SSHCredentialSpecDTO
}

export interface SSHCredentialSpecDTO {
  [key: string]: any
}

export type SSHKeyPathCredentialDTO = SSHCredentialSpecDTO & {
  encryptedPassphrase?: string
  keyPath: string
  userName: string
}

export type SSHKeyReferenceCredentialDTO = SSHCredentialSpecDTO & {
  encryptedPassphrase?: string
  key?: string
  userName: string
}

export type SSHKeySpecDTO = SecretSpecDTO & {
  auth: SSHAuthDTO
  port?: number
}

export type SSHKeyValidationMetadata = SecretValidationMetaData & {
  host: string
}

export type SSHPasswordCredentialDTO = SSHCredentialSpecDTO & {
  password: string
  userName: string
}

export interface SSOConfig {
  accountId?: string
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
  ssoSettings?: SSOSettings[]
}

export interface SSORequest {
  idpRedirectUrl?: string
  oauthProviderType?: 'AZURE' | 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'GOOGLE' | 'LINKEDIN'
  oauthProviderTypes?: ('AZURE' | 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'GOOGLE' | 'LINKEDIN')[]
}

export interface SSOSettings {
  accountId?: string
  appId: string
  createdAt?: number
  createdBy?: EmbeddedUser
  displayName?: string
  lastUpdatedAt: number
  lastUpdatedBy?: EmbeddedUser
  nextIteration?: number
  nextIterations?: number[]
  type: 'SAML' | 'LDAP' | 'OAUTH'
  url?: string
  uuid: string
}

export interface SaasGitDTO {
  saasGit?: boolean
}

export interface SamlLinkGroupRequest {
  samlGroupName?: string
}

export type SamlSettings = SSOSettings & {
  accountId: string
  authorizationEnabled?: boolean
  entityIdentifier?: string
  groupMembershipAttr?: string
  logoutUrl?: string
  metaDataFile?: string
  origin: string
}

export type SampleErrorMetadataDTO = ErrorMetadataDTO & {
  sampleMap?: {
    [key: string]: string
  }
}

export interface ScimGroup {
  displayName?: string
  externalId?: string
  harnessScopes?: string
  id?: string
  members?: Member[]
  meta?: JsonNode
  schemas?: string[]
}

export interface ScimUser {
  active?: boolean
  displayName?: string
  emails?: JsonNode
  externalId?: string
  groups?: JsonNode
  id?: string
  meta?: JsonNode
  name?: JsonNode
  password?: JsonNode
  roles?: JsonNode
  schemas?: string[]
  userName?: string
}

export interface Scope {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ScopingRuleDetailsNg {
  description?: string
  environmentIds?: string[]
  environmentTypeId?: string
}

export type ScriptStateExecutionData = DelegateResponseData & {
  activityId?: string
  delegateMetaInfo?: DelegateMetaInfo
  element?: ContextElement
  endTs?: number
  errorMsg?: string
  executionDetails?: {
    [key: string]: ExecutionDataValue
  }
  executionSummary?: {
    [key: string]: ExecutionDataValue
  }
  name?: string
  secretOutputVars?: string[]
  startTs?: number
  stateName?: string
  stateParams?: {
    [key: string]: { [key: string]: any }
  }
  stateType?: string
  status?:
    | 'ABORTED'
    | 'DISCONTINUING'
    | 'ERROR'
    | 'FAILED'
    | 'NEW'
    | 'PAUSED'
    | 'PAUSING'
    | 'QUEUED'
    | 'RESUMED'
    | 'RUNNING'
    | 'SCHEDULED'
    | 'STARTING'
    | 'SUCCESS'
    | 'WAITING'
    | 'SKIPPED'
    | 'ABORTING'
    | 'REJECTED'
    | 'EXPIRED'
    | 'PREPARING'
  sweepingOutputEnvVariables?: {
    [key: string]: string
  }
  templateVariable?: {
    [key: string]: { [key: string]: any }
  }
  waitInterval?: number
}

export interface SecretDTOV2 {
  description?: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec: SecretSpecDTO
  tags?: {
    [key: string]: string
  }
  type: 'SecretFile' | 'SecretText' | 'SSHKey'
}

export type SecretFileSpecDTO = SecretSpecDTO & {
  secretManagerIdentifier: string
}

export interface SecretManagerMetadataDTO {
  encryptionType?:
    | 'LOCAL'
    | 'KMS'
    | 'GCP_KMS'
    | 'AWS_SECRETS_MANAGER'
    | 'AZURE_VAULT'
    | 'CYBERARK'
    | 'VAULT'
    | 'GCP_SECRETS_MANAGER'
    | 'CUSTOM'
    | 'VAULT_SSH'
  spec?: SecretManagerMetadataSpecDTO
}

export interface SecretManagerMetadataRequestDTO {
  encryptionType:
    | 'LOCAL'
    | 'KMS'
    | 'GCP_KMS'
    | 'AWS_SECRETS_MANAGER'
    | 'AZURE_VAULT'
    | 'CYBERARK'
    | 'VAULT'
    | 'GCP_SECRETS_MANAGER'
    | 'CUSTOM'
    | 'VAULT_SSH'
  identifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec: SecretManagerMetadataRequestSpecDTO
}

export interface SecretManagerMetadataRequestSpecDTO {
  [key: string]: any
}

export interface SecretManagerMetadataSpecDTO {
  [key: string]: any
}

export type SecretNGVariable = NGVariable & {
  default?: string
  name?: string
  type?: 'Secret'
  value: string
}

export interface SecretRefData {
  decryptedValue?: string[]
  identifier?: string
  null?: boolean
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type SecretReferredByConnectorSetupUsageDetail = SetupUsageDetail & {
  fieldName?: string
}

export interface SecretRequestWrapper {
  secret: SecretDTOV2
}

export interface SecretResourceFilterDTO {
  identifiers?: string[]
  includeSecretsFromEverySubScope?: boolean
  searchTerm?: string
  secretTypes?: ('SecretFile' | 'SecretText' | 'SSHKey')[]
  sourceCategory?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
}

export interface SecretResponseWrapper {
  createdAt?: number
  draft?: boolean
  secret: SecretDTOV2
  updatedAt?: number
}

export interface SecretSpecDTO {
  errorMessageForInvalidYaml?: string
}

export type SecretTextSpecDTO = SecretSpecDTO & {
  secretManagerIdentifier: string
  value?: string
  valueType: 'Inline' | 'Reference'
}

export interface SecretValidationMetaData {
  type: 'SecretFile' | 'SecretText' | 'SSHKey'
}

export interface SecretValidationResultDTO {
  message?: string
  success?: boolean
}

export interface Serve {
  distribution?: Distribution
  variation?: string
}

export interface ServiceAccountAggregateDTO {
  createdAt: number
  lastModifiedAt: number
  roleAssignmentsMetadataDTO?: RoleAssignmentMetadataDTO[]
  serviceAccount: ServiceAccountDTO
  tokensCount?: number
}

export interface ServiceAccountConfig {
  apiKeyLimit?: number
  tokenLimit?: number
}

export interface ServiceAccountDTO {
  accountIdentifier: string
  description?: string
  email: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
}

export interface ServiceConfig {
  service?: ServiceYaml
  serviceDefinition?: ServiceDefinition
  serviceRef?: string
  stageOverrides?: StageOverridesConfig
  useFromStage?: ServiceUseFromStage
}

export interface ServiceDashboardInfo {
  accountIdentifier?: string
  failureDeploymentsCount?: number
  identifier?: string
  instancesCount?: number
  instancesCountChangeRate?: number
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  successDeploymentsCount?: number
  totalDeploymentsChangeRate?: number
  totalDeploymentsCount?: number
}

export interface ServiceDefinition {
  spec: ServiceSpec
  type: 'Kubernetes' | 'NativeHelm'
}

export interface ServiceDeployment {
  deployments?: DeploymentCount
  rate?: DeploymentChangeRates
  time?: number
}

export interface ServiceDeploymentInfo {
  serviceName?: string
  serviceTag?: string
}

export interface ServiceDeploymentInfoDTO {
  serviceDeploymentList?: ServiceDeployment[]
}

export interface ServiceDeploymentListInfo {
  endTime?: number
  failureRate?: number
  failureRateChangeRate?: number
  frequency?: number
  frequencyChangeRate?: number
  serviceDeploymentList?: ServiceDeployment[]
  startTime?: number
  totalDeployments?: number
  totalDeploymentsChangeRate?: number
}

export interface ServiceDetailsDTO {
  deploymentTypeList?: string[]
  description?: string
  failureRate?: number
  failureRateChangeRate?: number
  frequency?: number
  frequencyChangeRate?: number
  instanceCountDetails?: InstanceCountDetailsByEnvTypeBase
  lastPipelineExecuted?: ServicePipelineInfo
  serviceIdentifier?: string
  serviceName?: string
  successRate?: number
  successRateChangeRate?: number
  tags?: {
    [key: string]: string
  }
  totalDeploymentChangeRate?: number
  totalDeployments?: number
}

export interface ServiceDetailsInfoDTO {
  serviceDeploymentDetailsList?: ServiceDetailsDTO[]
}

export interface ServiceExecutionSummary {
  artifacts?: ArtifactsSummary
  deploymentType?: string
  displayName?: string
  identifier?: string
}

export interface ServiceHeaderInfo {
  createdAt?: number
  deploymentTypes?: string[]
  description?: string
  identifier?: string
  lastModifiedAt?: number
  name?: string
}

export type ServiceNowApprovalStepInfo = StepSpecType & {
  approvalCriteria: CriteriaSpecWrapper
  connectorRef: string
  delegateSelectors?: string[]
  rejectionCriteria?: CriteriaSpecWrapper
  ticketNumber: string
  ticketType: string
}

export type ServiceNowConnector = ConnectorConfigDTO & {
  delegateSelectors?: string[]
  passwordRef: string
  serviceNowUrl: string
  username?: string
  usernameRef?: string
}

export interface ServiceNowFieldAllowedValueNG {
  id?: string
  name?: string
  value?: string
}

export interface ServiceNowFieldNG {
  allowedValues: ServiceNowFieldAllowedValueNG[]
  custom?: boolean
  key: string
  name: string
  required?: boolean
  schema: ServiceNowFieldSchemaNG
}

export interface ServiceNowFieldSchemaNG {
  array?: boolean
  customType?: string
  type: 'glide_date_time' | 'integer' | 'boolean' | 'string'
  typeStr: string
}

export interface ServiceNowTicketTypeDTO {
  key: string
  name: string
}

export interface ServiceOverrides {
  description?: string
  name?: string
}

export interface ServicePipelineInfo {
  identifier?: string
  lastExecutedAt?: number
  name?: string
  pipelineExecutionId?: string
  status?: string
}

export interface ServiceRequestDTO {
  description?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface ServiceResponse {
  createdAt?: number
  lastModifiedAt?: number
  service?: ServiceResponseDTO
}

export interface ServiceResponseDTO {
  accountId?: string
  deleted?: boolean
  description?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
  tags?: {
    [key: string]: string
  }
  version?: number
}

export interface ServiceSpec {
  artifactOverrideSets?: ArtifactOverrideSetWrapper[]
  artifacts?: ArtifactListConfig
  manifestOverrideSets?: ManifestOverrideSetWrapper[]
  manifests?: ManifestConfigWrapper[]
  variableOverrideSets?: NGVariableOverrideSetWrapper[]
  variables?: NGVariable[]
}

export interface ServiceUseFromStage {
  metadata?: string
  overrides?: ServiceOverrides
  stage: string
}

export interface ServiceYaml {
  description?: string
  identifier: string
  name: string
  tags?: {
    [key: string]: string
  }
}

export interface ServicesCount {
  newCount?: number
  totalCount?: number
}

export interface ServicesDashboardInfo {
  serviceDashboardInfoList?: ServiceDashboardInfo[]
}

export type SetDefaultVariationsYaml = PatchInstruction & {
  identifier: string
  spec: SetDefaultVariationsYamlSpec
  type: 'SetDefaultVariations'
}

export interface SetDefaultVariationsYamlSpec {
  off: string
  on: string
}

export type SetFeatureFlagStateYaml = PatchInstruction & {
  identifier: string
  spec: SetFeatureFlagStateYamlSpec
  type: 'SetFeatureFlagState'
}

export interface SetFeatureFlagStateYamlSpec {
  state: string
}

export type SetOffVariationYaml = PatchInstruction & {
  identifier: string
  spec: SetOffVariationYamlSpec
  type: 'SetOffVariation'
}

export interface SetOffVariationYamlSpec {
  variation: string
}

export type SetOnVariationYaml = PatchInstruction & {
  identifier: string
  spec: SetOnVariationYamlSpec
  type: 'SetOnVariation'
}

export interface SetOnVariationYamlSpec {
  variation: string
}

export interface SetupUsageDetail {
  [key: string]: any
}

export interface ShellScriptBaseSource {
  type?: string
}

export type ShellScriptInlineSource = ShellScriptBaseSource & {
  script?: string
}

export interface ShellScriptSourceWrapper {
  spec: ShellScriptBaseSource
  type: string
}

export type ShellScriptStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  environmentVariables?: NGVariable[]
  executionTarget?: ExecutionTarget
  metadata?: string
  onDelegate: boolean
  outputVariables?: NGVariable[]
  shell: 'Bash' | 'PowerShell'
  source: ShellScriptSourceWrapper
}

export interface SidecarArtifact {
  identifier: string
  spec: ArtifactConfig
  type: 'DockerRegistry' | 'Gcr' | 'Ecr'
}

export interface SidecarArtifactWrapper {
  sidecar?: SidecarArtifact
}

export interface SignupDTO {
  billingFrequency?: 'MONTHLY' | 'YEARLY'
  edition?: 'COMMUNITY' | 'FREE' | 'TEAM' | 'ENTERPRISE'
  email?: string
  intent?: string
  password?: string
  signupAction?: 'REGULAR' | 'TRIAL' | 'SUBSCRIBE'
  utmInfo?: UtmInfo
}

export type SlackConfig = NotificationSettingConfig & {
  slackWebhookUrl?: string
}

export type SlackConfigDTO = NotificationSettingConfigDTO & {
  slackWebhookUrl: string
}

export interface SlackNotificationSetting {
  name?: string
  outgoingWebhookUrl: string
}

export interface SmtpConfigDTO {
  fromAddress?: string
  host: string
  password?: string[]
  port: number
  startTLS?: boolean
  useSSL?: boolean
  username?: string
}

export interface Sort {
  empty?: boolean
  sorted?: boolean
  unsorted?: boolean
}

export interface SourceCodeManagerAuthentication {
  [key: string]: any
}

export interface SourceCodeManagerDTO {
  accountIdentifier?: string
  authentication?: SourceCodeManagerAuthentication
  createdAt?: number
  id?: string
  lastModifiedAt?: number
  name: string
  type?: 'BITBUCKET' | 'GITHUB' | 'GITLAB' | 'AWS_CODE_COMMIT' | 'AZURE_DEV_OPS'
  userIdentifier?: string
}

export type SplunkConnectorDTO = ConnectorConfigDTO & {
  accountId: string
  delegateSelectors?: string[]
  passwordRef: string
  splunkUrl: string
  username?: string
}

export interface StackTraceElement {
  className?: string
  fileName?: string
  lineNumber?: number
  methodName?: string
  nativeMethod?: boolean
}

export interface StageElementConfig {
  description?: string
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  spec?: StageInfoConfig
  tags?: {
    [key: string]: string
  }
  template?: TemplateLinkConfig
  type?: string
  variables?: NGVariable[]
  when?: StageWhenCondition
}

export interface StageElementWrapperConfig {
  parallel?: ParallelStageElementConfig
  stage?: StageElementConfig
}

export interface StageInfoConfig {
  execution?: ExecutionElementConfig
}

export interface StageOverridesConfig {
  artifacts?: ArtifactListConfig
  manifests?: ManifestConfigWrapper[]
  useArtifactOverrideSets?: string[]
  useManifestOverrideSets?: string[]
  useVariableOverrideSets?: string[]
  variables?: NGVariable[]
}

export type StageRollbackFailureActionConfig = FailureStrategyActionConfig & {
  type: 'StageRollback'
}

export interface StageWhenCondition {
  condition?: string
  pipelineStatus: 'Success' | 'Failure' | 'All'
}

export interface StartTrialDTO {
  edition: 'COMMUNITY' | 'FREE' | 'TEAM' | 'ENTERPRISE'
  moduleType: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
}

export type StaticLimitRestrictionDTO = RestrictionDTO & {
  count?: number
  limit?: number
}

export type StaticLimitRestrictionMetadataDTO = RestrictionMetadataDTO & {
  allowedIfEqual?: boolean
  limit?: number
}

export interface StepCategory {
  name?: string
  stepCategories?: StepCategory[]
  stepsData?: StepData[]
}

export interface StepData {
  name?: string
  type?:
    | 'APPLY'
    | 'SCALE'
    | 'STAGE_DEPLOYMENT'
    | 'K8sRollingDeploy'
    | 'K8sRollingRollback'
    | 'HelmDeploy'
    | 'HelmRollback'
    | 'K8sBGSwapServices'
    | 'K8sDelete'
    | 'K8sCanaryDelete'
    | 'K8sCanaryDeploy'
    | 'TerraformApply'
    | 'TerraformPlan'
    | 'TerraformDestroy'
    | 'TerraformRollback'
    | 'CREATE_STACK'
    | 'DELETE_STACK'
    | 'SHELL_SCRIPT_PROVISIONER'
    | 'JIRA'
    | 'SERVICENOW'
    | 'EMAIL'
    | 'BARRIERS'
    | 'NEW_RELIC_DEPLOYMENT_MAKER'
    | 'TEMPLATIZED_SECRET_MANAGER'
}

export interface StepElementConfig {
  description?: string
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name: string
  spec?: StepSpecType
  timeout?: string
  type: string
  when?: StepWhenCondition
}

export interface StepGroupElementConfig {
  failureStrategies?: FailureStrategyConfig[]
  identifier: string
  name?: string
  steps: ExecutionWrapperConfig[]
  when?: StepWhenCondition
}

export type StepGroupFailureActionConfig = FailureStrategyActionConfig & {
  type: 'StepGroupRollback'
}

export interface StepSpecType {
  [key: string]: any
}

export interface StepWhenCondition {
  condition?: string
  stageStatus: 'Success' | 'Failure' | 'All'
}

export interface StoreConfig {
  [key: string]: any
}

export interface StoreConfigWrapper {
  metadata?: string
  spec: StoreConfig
  type: 'Git' | 'Github' | 'Bitbucket' | 'GitLab' | 'Http' | 'S3' | 'Gcs'
}

export type StringNGVariable = NGVariable & {
  default?: string
  name?: string
  type?: 'String'
  value: string
}

export type SumoLogicConnectorDTO = ConnectorConfigDTO & {
  accessIdRef: string
  accessKeyRef: string
  delegateSelectors?: string[]
  url: string
}

export interface TGTGenerationSpecDTO {
  [key: string]: any
}

export type TGTKeyTabFilePathSpecDTO = TGTGenerationSpecDTO & {
  keyPath?: string
}

export type TGTPasswordSpecDTO = TGTGenerationSpecDTO & {
  password?: string
}

export type TagBuildSpec = BuildSpec & {
  tag: string
}

export interface TechStack {
  category?: string
  technology?: string
}

export type TemplateFilterProperties = FilterProperties & {
  childTypes?: string[]
  description?: string
  templateEntityTypes?: ('Step' | 'Stage')[]
  templateIdentifiers?: string[]
  templateNames?: string[]
}

export interface TemplateInputsErrorDTO {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export type TemplateInputsErrorMetadataDTO = ErrorMetadataDTO & {
  errorMap?: {
    [key: string]: TemplateInputsErrorDTO
  }
  errorYaml?: string
}

export interface TemplateLinkConfig {
  templateInputs?: JsonNode
  templateRef: string
  versionLabel?: string
}

export type TerraformApplyStepInfo = StepSpecType & {
  configuration: TerraformStepConfiguration
  delegateSelectors?: string[]
  metadata?: string
  provisionerIdentifier: string
}

export interface TerraformBackendConfig {
  spec?: TerraformBackendConfigSpec
  type?: string
}

export interface TerraformBackendConfigSpec {
  [key: string]: any
}

export interface TerraformConfigFilesWrapper {
  store: StoreConfigWrapper
}

export type TerraformDestroyStepInfo = StepSpecType & {
  configuration: TerraformStepConfiguration
  delegateSelectors?: string[]
  metadata?: string
  provisionerIdentifier: string
}

export interface TerraformExecutionData {
  backendConfig?: TerraformBackendConfig
  configFiles: TerraformConfigFilesWrapper
  environmentVariables?: NGVariable[]
  targets?: string[]
  varFiles?: TerraformVarFileWrapper[]
  workspace?: string
}

export interface TerraformPlanExecutionData {
  backendConfig?: TerraformBackendConfig
  command: 'Apply' | 'Destroy'
  configFiles: TerraformConfigFilesWrapper
  environmentVariables?: NGVariable[]
  secretManagerRef: string
  targets?: string[]
  varFiles?: TerraformVarFileWrapper[]
  workspace?: string
}

export type TerraformPlanStepInfo = StepSpecType & {
  configuration: TerraformPlanExecutionData
  delegateSelectors?: string[]
  provisionerIdentifier: string
}

export type TerraformRollbackStepInfo = StepSpecType & {
  delegateSelectors?: string[]
  provisionerIdentifier: string
}

export interface TerraformStepConfiguration {
  spec?: TerraformExecutionData
  type: 'Inline' | 'InheritFromPlan' | 'InheritFromApply'
}

export interface TerraformVarFile {
  identifier: string
  spec: TerraformVarFileSpec
  type: string
}

export interface TerraformVarFileSpec {
  type?: string
}

export interface TerraformVarFileWrapper {
  varFile: TerraformVarFile
}

export interface Throwable {
  cause?: Throwable
  localizedMessage?: string
  message?: string
  stackTrace?: StackTraceElement[]
  suppressed?: Throwable[]
}

export interface TimeBasedDeploymentInfo {
  epochTime?: number
  failedCount?: number
  failureRate?: number
  successCount?: number
  totalCount?: number
}

export interface TimeUnit {
  numberOfUnits?: number
  unit?:
    | 'NANOS'
    | 'MICROS'
    | 'MILLIS'
    | 'SECONDS'
    | 'MINUTES'
    | 'HOURS'
    | 'HALF_DAYS'
    | 'DAYS'
    | 'WEEKS'
    | 'MONTHS'
    | 'YEARS'
    | 'DECADES'
    | 'CENTURIES'
    | 'MILLENNIA'
    | 'ERAS'
    | 'FOREVER'
}

export interface TimeValuePair {
  timestamp?: number
  value?: { [key: string]: any }
}

export interface TimeValuePairEnvIdCountPair {
  timestamp?: number
  value?: EnvIdCountPair
}

export interface TimeValuePairInteger {
  timestamp?: number
  value?: number
}

export interface TimeValuePairListDTO {
  timeValuePairList?: TimeValuePairObject[]
}

export interface TimeValuePairListDTOEnvIdCountPair {
  timeValuePairList?: TimeValuePairEnvIdCountPair[]
}

export interface TimeValuePairListDTOInteger {
  timeValuePairList?: TimeValuePairInteger[]
}

export interface TimeValuePairObject {
  timestamp?: number
  value?: { [key: string]: any }
}

export interface TokenAggregateDTO {
  createdAt: number
  expiryAt: number
  lastModifiedAt: number
  token: TokenDTO
}

export interface TokenDTO {
  accountIdentifier: string
  apiKeyIdentifier: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  description?: string
  email?: string
  encodedPassword?: string
  identifier: string
  name: string
  orgIdentifier?: string
  parentIdentifier: string
  projectIdentifier?: string
  scheduledExpireTime?: number
  tags?: {
    [key: string]: string
  }
  username?: string
  valid?: boolean
  validFrom?: number
  validTo?: number
}

export interface TotalDeploymentInfo {
  count?: number
  countList?: DeploymentDateAndCount[]
  nonProduction?: number
  production?: number
}

export interface TransitionTo {
  status: string
  transitionName?: string
}

export interface TrialSignupOptions {
  assistedOption?: boolean
  productsSelected?: ('CD' | 'CE' | 'CI')[]
}

export interface TriggerFullSyncResponseDTO {
  isFullSyncTriggered?: boolean
}

export interface TwoFactorAdminOverrideSettings {
  adminOverrideTwoFactorEnabled?: boolean
}

export interface TwoFactorAuthSettingsInfo {
  email?: string
  mechanism?: 'TOTP'
  totpSecretKey?: string
  totpqrurl?: string
  twoFactorAuthenticationEnabled?: boolean
  userId?: string
}

export interface TypeInfo {
  typeName?: string
  typeNamespace?: string
}

export type UpdateRuleYaml = PatchInstruction & {
  identifier: string
  spec: UpdateRuleYamlSpec
  type: 'UpdateRule'
}

export interface UpdateRuleYamlSpec {
  bucketBy: string
  ruleID: string
  serve?: Serve
  variations?: VariationYamlSpec[]
}

export interface User {
  accountIds?: string[]
  accountName?: string
  accounts?: Account[]
  appId: string
  companyName?: string
  createdAt?: number
  createdBy?: EmbeddedUser
  defaultAccountId?: string
  disabled?: boolean
  email?: string
  emailVerified?: boolean
  externalUserId?: string
  familyName?: string
  firstLogin?: boolean
  givenName?: string
  imported?: boolean
  lastAccountId?: string
  lastAppId?: string
  lastLogin?: number
  lastUpdatedAt: number
  lastUpdatedBy?: EmbeddedUser
  name?: string
  oauthProvider?: string
  password?: string[]
  passwordExpired?: boolean
  pendingAccounts?: Account[]
  rateLimitProtection?: RateLimitProtection
  reportedSegmentTracks?: string[]
  statsFetchedOn?: number
  supportAccounts?: Account[]
  token?: string
  twoFactorAuthenticationEnabled?: boolean
  twoFactorAuthenticationMechanism?: 'TOTP'
  twoFactorJwtToken?: string
  userGroups?: UserGroup[]
  userLocked?: boolean
  userLockoutInfo?: UserLockoutInfo
  utmInfo?: UtmInfo
  uuid: string
}

export interface UserAggregate {
  roleAssignmentMetadata: RoleAssignmentMetadataDTO[]
  user: UserMetadataDTO
}

export interface UserFilter {
  identifiers?: string[]
  parentFilter?: 'NO_PARENT_SCOPES' | 'INCLUDE_PARENT_SCOPES' | 'STRICTLY_PARENT_SCOPES'
  searchTerm?: string
}

export interface UserGroup {
  accountIdentifier: string
  createdAt?: number
  deleted?: boolean
  description: string
  externallyManaged?: boolean
  harnessManaged?: boolean
  id?: string
  identifier?: string
  isSsoLinked?: boolean
  lastModifiedAt?: number
  linkedSsoDisplayName?: string
  linkedSsoId?: string
  linkedSsoType?: 'SAML' | 'LDAP' | 'OAUTH'
  name?: string
  notificationConfigs: NotificationSettingConfig[]
  orgIdentifier?: string
  projectIdentifier?: string
  ssoGroupId?: string
  ssoGroupName?: string
  tags: NGTag[]
  users: string[]
  version?: number
}

export interface UserGroupAggregateDTO {
  lastModifiedAt?: number
  roleAssignmentsMetadataDTO?: RoleAssignmentMetadataDTO[]
  userGroupDTO: UserGroupDTO
  users?: UserMetadataDTO[]
}

export interface UserGroupDTO {
  accountIdentifier?: string
  description?: string
  externallyManaged?: boolean
  identifier: string
  linkedSsoDisplayName?: string
  linkedSsoId?: string
  name: string
  notificationConfigs?: NotificationSettingConfigDTO[]
  orgIdentifier?: string
  projectIdentifier?: string
  ssoGroupId?: string
  ssoGroupName?: string
  ssoLinked?: boolean
  tags?: {
    [key: string]: string
  }
  users?: string[]
}

export interface UserGroupFilterDTO {
  accountIdentifier?: string
  databaseIdFilter?: string[]
  identifierFilter?: string[]
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  userIdentifierFilter?: string[]
}

export interface UserInfo {
  accounts?: GatewayAccountRequestDTO[]
  admin?: boolean
  billingFrequency?: string
  defaultAccountId?: string
  disabled?: boolean
  edition?: string
  email?: string
  emailVerified?: boolean
  externallyManaged?: boolean
  intent?: string
  locked?: boolean
  name?: string
  signupAction?: string
  token?: string
  twoFactorAuthenticationEnabled?: boolean
  utmInfo?: UtmInfo
  uuid?: string
}

export interface UserLockoutInfo {
  numberOfFailedLoginAttempts?: number
  userLockedAt?: number
}

export interface UserLockoutPolicy {
  enableLockoutPolicy?: boolean
  lockOutPeriod?: number
  notifyUser?: boolean
  numberOfFailedAttemptsBeforeLockout?: number
  userGroupsToNotify?: UserGroup[]
}

export interface UserMetadataDTO {
  disabled?: boolean
  email: string
  externallyManaged?: boolean
  locked?: boolean
  name?: string
  uuid: string
}

export type UsernamePasswordSettings = NGAuthSettings & {
  loginSettings: LoginSettings
}

export interface UtmInfo {
  utmCampaign?: string
  utmContent?: string
  utmMedium?: string
  utmSource?: string
  utmTerm?: string
}

export interface ValidationError {
  error?: string
  fieldId?: string
}

export interface ValidationResultDTO {
  errorMessage?: string
  valid?: boolean
}

export type ValuesManifest = ManifestAttributes & {
  metadata?: string
  store?: StoreConfigWrapper
}

export interface VariationYamlSpec {
  variation: string
  weight: number
}

export type VaultAgentCredentialDTO = VaultCredentialDTO & {
  sinkPath?: string
}

export type VaultAppRoleCredentialDTO = VaultCredentialDTO & {
  appRoleId?: string
  secretId?: string
}

export type VaultAuthTokenCredentialDTO = VaultCredentialDTO & {
  authToken?: string
}

export type VaultConnectorDTO = ConnectorConfigDTO & {
  accessType?: 'APP_ROLE' | 'TOKEN' | 'VAULT_AGENT'
  appRoleId?: string
  authToken?: string
  basePath?: string
  default?: boolean
  delegateSelectors?: string[]
  namespace?: string
  readOnly?: boolean
  renewalIntervalMinutes?: number
  secretEngineManuallyConfigured?: boolean
  secretEngineName?: string
  secretEngineVersion?: number
  secretId?: string
  sinkPath?: string
  useVaultAgent?: boolean
  vaultUrl?: string
}

export interface VaultCredentialDTO {
  [key: string]: any
}

export type VaultMetadataRequestSpecDTO = SecretManagerMetadataRequestSpecDTO & {
  accessType: 'APP_ROLE' | 'TOKEN' | 'VAULT_AGENT'
  delegateSelectors?: string[]
  namespace?: string
  spec?: VaultCredentialDTO
  url: string
}

export type VaultMetadataSpecDTO = SecretManagerMetadataSpecDTO & {
  secretEngines?: VaultSecretEngineDTO[]
}

export interface VaultSecretEngineDTO {
  description?: string
  name?: string
  type?: string
  version?: number
}

export interface VerifyTokenResponseDTO {
  accountIdentifier?: string
}

export interface Void {
  [key: string]: any
}

export interface WeightedVariation {
  variation: string
  weight: number
}

export type WorkflowFilter = Filter & {
  filterTypes?: string[]
}

export interface WorkloadCountInfo {
  count?: number
}

export interface WorkloadDateCountInfo {
  date?: number
  execution?: WorkloadCountInfo
}

export interface WorkloadDeploymentInfo {
  deploymentTypeList?: string[]
  failureRate?: number
  failureRateChangeRate?: number
  frequency?: number
  frequencyChangeRate?: number
  lastExecuted?: LastWorkloadInfo
  lastPipelineExecutionId?: string
  percentSuccess?: number
  rateSuccess?: number
  serviceId?: string
  serviceName?: string
  totalDeploymentChangeRate?: number
  totalDeployments?: number
  workload?: WorkloadDateCountInfo[]
}

export interface YamlGroup {
  group?: string
}

export interface YamlSchemaDetailsWrapper {
  yamlSchemaWithDetailsList?: YamlSchemaWithDetails[]
}

export interface YamlSchemaMetadata {
  featureFlags?: string[]
  modulesSupported?: ('CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE')[]
  yamlGroup: YamlGroup
}

export interface YamlSchemaWithDetails {
  availableAtAccountLevel?: boolean
  availableAtOrgLevel?: boolean
  availableAtProjectLevel?: boolean
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
  schema?: JsonNode
  schemaClassName?: string
  yamlSchemaMetadata?: YamlSchemaMetadata
}

export interface YamlSnippetMetaData {
  description?: string
  iconTag?: string
  identifier?: string
  name?: string
  tags?: string[]
  version?: string
}

export interface YamlSnippets {
  yamlSnippets?: YamlSnippetMetaData[]
}

export type AccountDTORequestBody = AccountDTO

export type ApiKeyDTORequestBody = ApiKeyDTO

export type ConnectorRequestBody = Connector

export type DelegateProfileDetailsNgRequestBody = DelegateProfileDetailsNg

export type DockerRequestDTORequestBody = DockerRequestDTO

export type EcrRequestDTORequestBody = EcrRequestDTO

export type EnvironmentRequestDTORequestBody = EnvironmentRequestDTO

export type FilterDTORequestBody = FilterDTO

export type GcrRequestDTORequestBody = GcrRequestDTO

export type GitFullSyncConfigRequestDTORequestBody = GitFullSyncConfigRequestDTO

export type GitOpsProviderRequestBody = GitOpsProvider

export type GitSyncConfigRequestBody = GitSyncConfig

export type GitSyncSettingsDTORequestBody = GitSyncSettingsDTO

export type LandingDashboardRequestCDRequestBody = LandingDashboardRequestCD

export type NgSmtpDTORequestBody = NgSmtpDTO

export type OrganizationRequestRequestBody = OrganizationRequest

export type PatchRequestRequestBody = PatchRequest

export type ProjectRequestRequestBody = ProjectRequest

export type RoleAssignmentFilterRequestBody = RoleAssignmentFilter

export type ScimGroupRequestBody = ScimGroup

export type ScimUserRequestBody = ScimUser

export type ScopingRuleDetailsNgArrayRequestBody = ScopingRuleDetailsNg[]

export type SecretRequestWrapperRequestBody = SecretRequestWrapper

export type SecretRequestWrapper2RequestBody = void

export type ServiceAccountDTORequestBody = ServiceAccountDTO

export type ServiceRequestDTORequestBody = ServiceRequestDTO

export type ServiceRequestDTOArrayRequestBody = ServiceRequestDTO[]

export type SignupDTORequestBody = SignupDTO

export type SourceCodeManagerDTORequestBody = SourceCodeManagerDTO

export type StartTrialDTORequestBody = StartTrialDTO

export type TokenDTORequestBody = TokenDTO

export type UserFilterRequestBody = UserFilter

export type UserGroupDTORequestBody = UserGroupDTO

export type YamlSchemaDetailsWrapperRequestBody = YamlSchemaDetailsWrapper

export type GetBuildDetailsForEcrWithYamlBodyRequestBody = string

export type UnsubscribeBodyRequestBody = string[]

export type UpdateWhitelistedDomainsBodyRequestBody = string[]

export type UploadSamlMetaDataRequestBody = void

export interface GetAccountNGPathParams {
  accountIdentifier: string
}

export type GetAccountNGProps = Omit<
  GetProps<ResponseAccountDTO, Failure | Error, void, GetAccountNGPathParams>,
  'path'
> &
  GetAccountNGPathParams

/**
 * Get Account
 */
export const GetAccountNG = ({ accountIdentifier, ...props }: GetAccountNGProps) => (
  <Get<ResponseAccountDTO, Failure | Error, void, GetAccountNGPathParams>
    path={`/accounts/${accountIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAccountNGProps = Omit<
  UseGetProps<ResponseAccountDTO, Failure | Error, void, GetAccountNGPathParams>,
  'path'
> &
  GetAccountNGPathParams

/**
 * Get Account
 */
export const useGetAccountNG = ({ accountIdentifier, ...props }: UseGetAccountNGProps) =>
  useGet<ResponseAccountDTO, Failure | Error, void, GetAccountNGPathParams>(
    (paramsInPath: GetAccountNGPathParams) => `/accounts/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Get Account
 */
export const getAccountNGPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseAccountDTO, Failure | Error, void, GetAccountNGPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAccountDTO, Failure | Error, void, GetAccountNGPathParams>(
    getConfig('ng/api'),
    `/accounts/${accountIdentifier}`,
    props,
    signal
  )

export interface UpdateAccountDefaultExperienceNGPathParams {
  accountIdentifier: string
}

export type UpdateAccountDefaultExperienceNGProps = Omit<
  MutateProps<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountDefaultExperienceNGPathParams
  >,
  'path' | 'verb'
> &
  UpdateAccountDefaultExperienceNGPathParams

/**
 * Update Default Experience
 */
export const UpdateAccountDefaultExperienceNG = ({
  accountIdentifier,
  ...props
}: UpdateAccountDefaultExperienceNGProps) => (
  <Mutate<ResponseAccountDTO, Failure | Error, void, AccountDTORequestBody, UpdateAccountDefaultExperienceNGPathParams>
    verb="PUT"
    path={`/accounts/${accountIdentifier}/default-experience`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateAccountDefaultExperienceNGProps = Omit<
  UseMutateProps<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountDefaultExperienceNGPathParams
  >,
  'path' | 'verb'
> &
  UpdateAccountDefaultExperienceNGPathParams

/**
 * Update Default Experience
 */
export const useUpdateAccountDefaultExperienceNG = ({
  accountIdentifier,
  ...props
}: UseUpdateAccountDefaultExperienceNGProps) =>
  useMutate<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountDefaultExperienceNGPathParams
  >(
    'PUT',
    (paramsInPath: UpdateAccountDefaultExperienceNGPathParams) =>
      `/accounts/${paramsInPath.accountIdentifier}/default-experience`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Update Default Experience
 */
export const updateAccountDefaultExperienceNGPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountDefaultExperienceNGPathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountDefaultExperienceNGPathParams
  >('PUT', getConfig('ng/api'), `/accounts/${accountIdentifier}/default-experience`, props, signal)

export interface UpdateAccountNameNGPathParams {
  accountIdentifier: string
}

export type UpdateAccountNameNGProps = Omit<
  MutateProps<ResponseAccountDTO, Failure | Error, void, AccountDTORequestBody, UpdateAccountNameNGPathParams>,
  'path' | 'verb'
> &
  UpdateAccountNameNGPathParams

/**
 * Update Account Name
 */
export const UpdateAccountNameNG = ({ accountIdentifier, ...props }: UpdateAccountNameNGProps) => (
  <Mutate<ResponseAccountDTO, Failure | Error, void, AccountDTORequestBody, UpdateAccountNameNGPathParams>
    verb="PUT"
    path={`/accounts/${accountIdentifier}/name`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateAccountNameNGProps = Omit<
  UseMutateProps<ResponseAccountDTO, Failure | Error, void, AccountDTORequestBody, UpdateAccountNameNGPathParams>,
  'path' | 'verb'
> &
  UpdateAccountNameNGPathParams

/**
 * Update Account Name
 */
export const useUpdateAccountNameNG = ({ accountIdentifier, ...props }: UseUpdateAccountNameNGProps) =>
  useMutate<ResponseAccountDTO, Failure | Error, void, AccountDTORequestBody, UpdateAccountNameNGPathParams>(
    'PUT',
    (paramsInPath: UpdateAccountNameNGPathParams) => `/accounts/${paramsInPath.accountIdentifier}/name`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Update Account Name
 */
export const updateAccountNameNGPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseAccountDTO,
    Failure | Error,
    void,
    AccountDTORequestBody,
    UpdateAccountNameNGPathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseAccountDTO, Failure | Error, void, AccountDTORequestBody, UpdateAccountNameNGPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/accounts/${accountIdentifier}/name`,
    props,
    signal
  )

export interface ListActivitiesQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  startTime: number
  endTime: number
  status?: 'SUCCESS' | 'FAILED'
  referredEntityType:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  referredByEntityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
}

export type ListActivitiesProps = Omit<GetProps<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>, 'path'>

/**
 * Get Activities where this resource was used
 */
export const ListActivities = (props: ListActivitiesProps) => (
  <Get<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>
    path={`/activityHistory`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListActivitiesProps = Omit<
  UseGetProps<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>,
  'path'
>

/**
 * Get Activities where this resource was used
 */
export const useListActivities = (props: UseListActivitiesProps) =>
  useGet<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>(`/activityHistory`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Activities where this resource was used
 */
export const listActivitiesPromise = (
  props: GetUsingFetchProps<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageActivity, unknown, ListActivitiesQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory`,
    props,
    signal
  )

export interface GetConnectivitySummaryQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  startTime: number
  endTime: number
}

export type GetConnectivitySummaryProps = Omit<
  GetProps<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>,
  'path'
>

/**
 * Get ConnectivityCheck Summary
 */
export const GetConnectivitySummary = (props: GetConnectivitySummaryProps) => (
  <Get<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>
    path={`/activityHistory/connectivityCheckSummary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectivitySummaryProps = Omit<
  UseGetProps<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>,
  'path'
>

/**
 * Get ConnectivityCheck Summary
 */
export const useGetConnectivitySummary = (props: UseGetConnectivitySummaryProps) =>
  useGet<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>(
    `/activityHistory/connectivityCheckSummary`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ConnectivityCheck Summary
 */
export const getConnectivitySummaryPromise = (
  props: GetUsingFetchProps<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectivityCheckSummary, unknown, GetConnectivitySummaryQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory/connectivityCheckSummary`,
    props,
    signal
  )

export interface GetActivitiesSummaryQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  startTime: number
  endTime: number
  timeGroupType: 'HOUR' | 'DAY' | 'WEEK'
  referredEntityType:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  referredByEntityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
}

export type GetActivitiesSummaryProps = Omit<
  GetProps<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>,
  'path'
>

/**
 * Get Activities Summary
 */
export const GetActivitiesSummary = (props: GetActivitiesSummaryProps) => (
  <Get<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>
    path={`/activityHistory/summary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActivitiesSummaryProps = Omit<
  UseGetProps<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>,
  'path'
>

/**
 * Get Activities Summary
 */
export const useGetActivitiesSummary = (props: UseGetActivitiesSummaryProps) =>
  useGet<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>(`/activityHistory/summary`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Activities Summary
 */
export const getActivitiesSummaryPromise = (
  props: GetUsingFetchProps<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageActivitySummary, unknown, GetActivitiesSummaryQueryParams, void>(
    getConfig('ng/api'),
    `/activityHistory/summary`,
    props,
    signal
  )

export interface GetAccountResourcesCountQueryParams {
  accountIdentifier: string
}

export type GetAccountResourcesCountProps = Omit<
  GetProps<ResponseAccountResourcesDTO, Failure | Error, GetAccountResourcesCountQueryParams, void>,
  'path'
>

/**
 * Gets count of account resources
 */
export const GetAccountResourcesCount = (props: GetAccountResourcesCountProps) => (
  <Get<ResponseAccountResourcesDTO, Failure | Error, GetAccountResourcesCountQueryParams, void>
    path={`/aggregate/account-resources`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAccountResourcesCountProps = Omit<
  UseGetProps<ResponseAccountResourcesDTO, Failure | Error, GetAccountResourcesCountQueryParams, void>,
  'path'
>

/**
 * Gets count of account resources
 */
export const useGetAccountResourcesCount = (props: UseGetAccountResourcesCountProps) =>
  useGet<ResponseAccountResourcesDTO, Failure | Error, GetAccountResourcesCountQueryParams, void>(
    `/aggregate/account-resources`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets count of account resources
 */
export const getAccountResourcesCountPromise = (
  props: GetUsingFetchProps<ResponseAccountResourcesDTO, Failure | Error, GetAccountResourcesCountQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAccountResourcesDTO, Failure | Error, GetAccountResourcesCountQueryParams, void>(
    getConfig('ng/api'),
    `/aggregate/account-resources`,
    props,
    signal
  )

export interface GetUserGroupAggregateListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  searchTerm?: string
  userSize?: number
}

export type GetUserGroupAggregateListProps = Omit<
  GetProps<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>,
  'path'
>

/**
 * Get Aggregated User Group list
 */
export const GetUserGroupAggregateList = (props: GetUserGroupAggregateListProps) => (
  <Get<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>
    path={`/aggregate/acl/usergroups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupAggregateListProps = Omit<
  UseGetProps<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>,
  'path'
>

/**
 * Get Aggregated User Group list
 */
export const useGetUserGroupAggregateList = (props: UseGetUserGroupAggregateListProps) =>
  useGet<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>(
    `/aggregate/acl/usergroups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Aggregated User Group list
 */
export const getUserGroupAggregateListPromise = (
  props: GetUsingFetchProps<
    ResponsePageUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageUserGroupAggregateDTO, Failure | Error, GetUserGroupAggregateListQueryParams, void>(
    getConfig('ng/api'),
    `/aggregate/acl/usergroups`,
    props,
    signal
  )

export interface GetUserGroupAggregateListsWithFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetUserGroupAggregateListsWithFilterProps = Omit<
  MutateProps<
    ResponseListUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListsWithFilterQueryParams,
    AggregateACLRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Aggregated User Group list with filter
 */
export const GetUserGroupAggregateListsWithFilter = (props: GetUserGroupAggregateListsWithFilterProps) => (
  <Mutate<
    ResponseListUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListsWithFilterQueryParams,
    AggregateACLRequest,
    void
  >
    verb="POST"
    path={`/aggregate/acl/usergroups/filter`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupAggregateListsWithFilterProps = Omit<
  UseMutateProps<
    ResponseListUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListsWithFilterQueryParams,
    AggregateACLRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Aggregated User Group list with filter
 */
export const useGetUserGroupAggregateListsWithFilter = (props: UseGetUserGroupAggregateListsWithFilterProps) =>
  useMutate<
    ResponseListUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListsWithFilterQueryParams,
    AggregateACLRequest,
    void
  >('POST', `/aggregate/acl/usergroups/filter`, { base: getConfig('ng/api'), ...props })

/**
 * Get Aggregated User Group list with filter
 */
export const getUserGroupAggregateListsWithFilterPromise = (
  props: MutateUsingFetchProps<
    ResponseListUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListsWithFilterQueryParams,
    AggregateACLRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateListsWithFilterQueryParams,
    AggregateACLRequest,
    void
  >('POST', getConfig('ng/api'), `/aggregate/acl/usergroups/filter`, props, signal)

export interface GetUserGroupAggregateQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetUserGroupAggregatePathParams {
  identifier: string
}

export type GetUserGroupAggregateProps = Omit<
  GetProps<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >,
  'path'
> &
  GetUserGroupAggregatePathParams

/**
 * Get Aggregated User Group
 */
export const GetUserGroupAggregate = ({ identifier, ...props }: GetUserGroupAggregateProps) => (
  <Get<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >
    path={`/aggregate/acl/usergroups/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupAggregateProps = Omit<
  UseGetProps<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >,
  'path'
> &
  GetUserGroupAggregatePathParams

/**
 * Get Aggregated User Group
 */
export const useGetUserGroupAggregate = ({ identifier, ...props }: UseGetUserGroupAggregateProps) =>
  useGet<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >((paramsInPath: GetUserGroupAggregatePathParams) => `/aggregate/acl/usergroups/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Get Aggregated User Group
 */
export const getUserGroupAggregatePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseUserGroupAggregateDTO,
    Failure | Error,
    GetUserGroupAggregateQueryParams,
    GetUserGroupAggregatePathParams
  >(getConfig('ng/api'), `/aggregate/acl/usergroups/${identifier}`, props, signal)

export interface GetOrganizationAggregateDTOListQueryParams {
  accountIdentifier: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetOrganizationAggregateDTOListProps = Omit<
  GetProps<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get OrganizationAggregateDTO list
 */
export const GetOrganizationAggregateDTOList = (props: GetOrganizationAggregateDTOListProps) => (
  <Get<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>
    path={`/aggregate/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationAggregateDTOListProps = Omit<
  UseGetProps<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get OrganizationAggregateDTO list
 */
export const useGetOrganizationAggregateDTOList = (props: UseGetOrganizationAggregateDTOListProps) =>
  useGet<ResponsePageOrganizationAggregateDTO, Failure | Error, GetOrganizationAggregateDTOListQueryParams, void>(
    `/aggregate/organizations`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get OrganizationAggregateDTO list
 */
export const getOrganizationAggregateDTOListPromise = (
  props: GetUsingFetchProps<
    ResponsePageOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOListQueryParams,
    void
  >(getConfig('ng/api'), `/aggregate/organizations`, props, signal)

export interface GetOrganizationAggregateDTOQueryParams {
  accountIdentifier: string
}

export interface GetOrganizationAggregateDTOPathParams {
  identifier: string
}

export type GetOrganizationAggregateDTOProps = Omit<
  GetProps<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >,
  'path'
> &
  GetOrganizationAggregateDTOPathParams

/**
 * Gets an OrganizationAggregateDTO by identifier
 */
export const GetOrganizationAggregateDTO = ({ identifier, ...props }: GetOrganizationAggregateDTOProps) => (
  <Get<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >
    path={`/aggregate/organizations/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationAggregateDTOProps = Omit<
  UseGetProps<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >,
  'path'
> &
  GetOrganizationAggregateDTOPathParams

/**
 * Gets an OrganizationAggregateDTO by identifier
 */
export const useGetOrganizationAggregateDTO = ({ identifier, ...props }: UseGetOrganizationAggregateDTOProps) =>
  useGet<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >((paramsInPath: GetOrganizationAggregateDTOPathParams) => `/aggregate/organizations/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Gets an OrganizationAggregateDTO by identifier
 */
export const getOrganizationAggregateDTOPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseOrganizationAggregateDTO,
    Failure | Error,
    GetOrganizationAggregateDTOQueryParams,
    GetOrganizationAggregateDTOPathParams
  >(getConfig('ng/api'), `/aggregate/organizations/${identifier}`, props, signal)

export interface GetProjectAggregateDTOListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  hasModule?: boolean
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetProjectAggregateDTOListProps = Omit<
  GetProps<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get ProjectAggregateDTO list
 */
export const GetProjectAggregateDTOList = (props: GetProjectAggregateDTOListProps) => (
  <Get<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>
    path={`/aggregate/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectAggregateDTOListProps = Omit<
  UseGetProps<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>,
  'path'
>

/**
 * Get ProjectAggregateDTO list
 */
export const useGetProjectAggregateDTOList = (props: UseGetProjectAggregateDTOListProps) =>
  useGet<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>(
    `/aggregate/projects`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ProjectAggregateDTO list
 */
export const getProjectAggregateDTOListPromise = (
  props: GetUsingFetchProps<
    ResponsePageProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProjectAggregateDTO, Failure | Error, GetProjectAggregateDTOListQueryParams, void>(
    getConfig('ng/api'),
    `/aggregate/projects`,
    props,
    signal
  )

export interface GetProjectAggregateDTOQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export interface GetProjectAggregateDTOPathParams {
  identifier: string
}

export type GetProjectAggregateDTOProps = Omit<
  GetProps<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >,
  'path'
> &
  GetProjectAggregateDTOPathParams

/**
 * Gets a ProjectAggregateDTO by identifier
 */
export const GetProjectAggregateDTO = ({ identifier, ...props }: GetProjectAggregateDTOProps) => (
  <Get<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >
    path={`/aggregate/projects/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectAggregateDTOProps = Omit<
  UseGetProps<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >,
  'path'
> &
  GetProjectAggregateDTOPathParams

/**
 * Gets a ProjectAggregateDTO by identifier
 */
export const useGetProjectAggregateDTO = ({ identifier, ...props }: UseGetProjectAggregateDTOProps) =>
  useGet<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >((paramsInPath: GetProjectAggregateDTOPathParams) => `/aggregate/projects/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Gets a ProjectAggregateDTO by identifier
 */
export const getProjectAggregateDTOPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseProjectAggregateDTO,
    Failure | Error,
    GetProjectAggregateDTOQueryParams,
    GetProjectAggregateDTOPathParams
  >(getConfig('ng/api'), `/aggregate/projects/${identifier}`, props, signal)

export interface ListApiKeysQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
  identifiers?: string[]
}

export type ListApiKeysProps = Omit<
  GetProps<ResponseListApiKeyDTO, Failure | Error, ListApiKeysQueryParams, void>,
  'path'
>

/**
 * List api keys
 */
export const ListApiKeys = (props: ListApiKeysProps) => (
  <Get<ResponseListApiKeyDTO, Failure | Error, ListApiKeysQueryParams, void>
    path={`/apikey`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListApiKeysProps = Omit<
  UseGetProps<ResponseListApiKeyDTO, Failure | Error, ListApiKeysQueryParams, void>,
  'path'
>

/**
 * List api keys
 */
export const useListApiKeys = (props: UseListApiKeysProps) =>
  useGet<ResponseListApiKeyDTO, Failure | Error, ListApiKeysQueryParams, void>(`/apikey`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List api keys
 */
export const listApiKeysPromise = (
  props: GetUsingFetchProps<ResponseListApiKeyDTO, Failure | Error, ListApiKeysQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListApiKeyDTO, Failure | Error, ListApiKeysQueryParams, void>(
    getConfig('ng/api'),
    `/apikey`,
    props,
    signal
  )

export type CreateApiKeyProps = Omit<
  MutateProps<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create API key
 */
export const CreateApiKey = (props: CreateApiKeyProps) => (
  <Mutate<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, void>
    verb="POST"
    path={`/apikey`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateApiKeyProps = Omit<
  UseMutateProps<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create API key
 */
export const useCreateApiKey = (props: UseCreateApiKeyProps) =>
  useMutate<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, void>('POST', `/apikey`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create API key
 */
export const createApiKeyPromise = (
  props: MutateUsingFetchProps<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/apikey`,
    props,
    signal
  )

export interface ListAggregatedApiKeysQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
  identifiers?: string[]
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  searchTerm?: string
}

export type ListAggregatedApiKeysProps = Omit<
  GetProps<ResponsePageApiKeyAggregateDTO, Failure | Error, ListAggregatedApiKeysQueryParams, void>,
  'path'
>

/**
 * List api key
 */
export const ListAggregatedApiKeys = (props: ListAggregatedApiKeysProps) => (
  <Get<ResponsePageApiKeyAggregateDTO, Failure | Error, ListAggregatedApiKeysQueryParams, void>
    path={`/apikey/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListAggregatedApiKeysProps = Omit<
  UseGetProps<ResponsePageApiKeyAggregateDTO, Failure | Error, ListAggregatedApiKeysQueryParams, void>,
  'path'
>

/**
 * List api key
 */
export const useListAggregatedApiKeys = (props: UseListAggregatedApiKeysProps) =>
  useGet<ResponsePageApiKeyAggregateDTO, Failure | Error, ListAggregatedApiKeysQueryParams, void>(`/apikey/aggregate`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List api key
 */
export const listAggregatedApiKeysPromise = (
  props: GetUsingFetchProps<ResponsePageApiKeyAggregateDTO, Failure | Error, ListAggregatedApiKeysQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageApiKeyAggregateDTO, Failure | Error, ListAggregatedApiKeysQueryParams, void>(
    getConfig('ng/api'),
    `/apikey/aggregate`,
    props,
    signal
  )

export interface GetAggregatedApiKeyQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
}

export interface GetAggregatedApiKeyPathParams {
  identifier: string
}

export type GetAggregatedApiKeyProps = Omit<
  GetProps<ResponseApiKeyAggregateDTO, Failure | Error, GetAggregatedApiKeyQueryParams, GetAggregatedApiKeyPathParams>,
  'path'
> &
  GetAggregatedApiKeyPathParams

/**
 * Get API key
 */
export const GetAggregatedApiKey = ({ identifier, ...props }: GetAggregatedApiKeyProps) => (
  <Get<ResponseApiKeyAggregateDTO, Failure | Error, GetAggregatedApiKeyQueryParams, GetAggregatedApiKeyPathParams>
    path={`/apikey/aggregate/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAggregatedApiKeyProps = Omit<
  UseGetProps<
    ResponseApiKeyAggregateDTO,
    Failure | Error,
    GetAggregatedApiKeyQueryParams,
    GetAggregatedApiKeyPathParams
  >,
  'path'
> &
  GetAggregatedApiKeyPathParams

/**
 * Get API key
 */
export const useGetAggregatedApiKey = ({ identifier, ...props }: UseGetAggregatedApiKeyProps) =>
  useGet<ResponseApiKeyAggregateDTO, Failure | Error, GetAggregatedApiKeyQueryParams, GetAggregatedApiKeyPathParams>(
    (paramsInPath: GetAggregatedApiKeyPathParams) => `/apikey/aggregate/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get API key
 */
export const getAggregatedApiKeyPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseApiKeyAggregateDTO,
    Failure | Error,
    GetAggregatedApiKeyQueryParams,
    GetAggregatedApiKeyPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseApiKeyAggregateDTO,
    Failure | Error,
    GetAggregatedApiKeyQueryParams,
    GetAggregatedApiKeyPathParams
  >(getConfig('ng/api'), `/apikey/aggregate/${identifier}`, props, signal)

export interface DeleteApiKeyQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
}

export type DeleteApiKeyProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteApiKeyQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete API key
 */
export const DeleteApiKey = (props: DeleteApiKeyProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteApiKeyQueryParams, string, void>
    verb="DELETE"
    path={`/apikey`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteApiKeyProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteApiKeyQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete API key
 */
export const useDeleteApiKey = (props: UseDeleteApiKeyProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteApiKeyQueryParams, string, void>('DELETE', `/apikey`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete API key
 */
export const deleteApiKeyPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteApiKeyQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteApiKeyQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/apikey`,
    props,
    signal
  )

export interface UpdateApiKeyPathParams {
  identifier: string
}

export type UpdateApiKeyProps = Omit<
  MutateProps<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, UpdateApiKeyPathParams>,
  'path' | 'verb'
> &
  UpdateApiKeyPathParams

/**
 * Update API key
 */
export const UpdateApiKey = ({ identifier, ...props }: UpdateApiKeyProps) => (
  <Mutate<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, UpdateApiKeyPathParams>
    verb="PUT"
    path={`/apikey/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateApiKeyProps = Omit<
  UseMutateProps<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, UpdateApiKeyPathParams>,
  'path' | 'verb'
> &
  UpdateApiKeyPathParams

/**
 * Update API key
 */
export const useUpdateApiKey = ({ identifier, ...props }: UseUpdateApiKeyProps) =>
  useMutate<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, UpdateApiKeyPathParams>(
    'PUT',
    (paramsInPath: UpdateApiKeyPathParams) => `/apikey/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update API key
 */
export const updateApiKeyPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, UpdateApiKeyPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseApiKeyDTO, Failure | Error, void, ApiKeyDTORequestBody, UpdateApiKeyPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/apikey/${identifier}`,
    props,
    signal
  )

export interface GetBuildDetailsForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetBuildDetailsForDockerProps = Omit<
  GetProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker build details
 */
export const GetBuildDetailsForDocker = (props: GetBuildDetailsForDockerProps) => (
  <Get<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>
    path={`/artifacts/docker/getBuildDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForDockerProps = Omit<
  UseGetProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>,
  'path'
>

/**
 * Gets docker build details
 */
export const useGetBuildDetailsForDocker = (props: UseGetBuildDetailsForDockerProps) =>
  useGet<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>(
    `/artifacts/docker/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets docker build details
 */
export const getBuildDetailsForDockerPromise = (
  props: GetUsingFetchProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/getBuildDetails`,
    props,
    signal
  )

export interface GetBuildDetailsForDockerWithYamlQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetBuildDetailsForDockerWithYamlProps = Omit<
  MutateProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerWithYamlQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Gets docker build details with yaml input for expression resolution
 */
export const GetBuildDetailsForDockerWithYaml = (props: GetBuildDetailsForDockerWithYamlProps) => (
  <Mutate<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerWithYamlQueryParams, string, void>
    verb="POST"
    path={`/artifacts/docker/getBuildDetailsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForDockerWithYamlProps = Omit<
  UseMutateProps<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerWithYamlQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Gets docker build details with yaml input for expression resolution
 */
export const useGetBuildDetailsForDockerWithYaml = (props: UseGetBuildDetailsForDockerWithYamlProps) =>
  useMutate<ResponseDockerResponseDTO, Failure | Error, GetBuildDetailsForDockerWithYamlQueryParams, string, void>(
    'POST',
    `/artifacts/docker/getBuildDetailsV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets docker build details with yaml input for expression resolution
 */
export const getBuildDetailsForDockerWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetBuildDetailsForDockerWithYamlQueryParams,
    string,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetBuildDetailsForDockerWithYamlQueryParams,
    string,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/getBuildDetailsV2`, props, signal)

export interface GetLabelsForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetLabelsForDockerProps = Omit<
  MutateProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker labels
 */
export const GetLabelsForDocker = (props: GetLabelsForDockerProps) => (
  <Mutate<ResponseDockerResponseDTO, Failure | Error, GetLabelsForDockerQueryParams, DockerRequestDTORequestBody, void>
    verb="POST"
    path={`/artifacts/docker/getLabels`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLabelsForDockerProps = Omit<
  UseMutateProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker labels
 */
export const useGetLabelsForDocker = (props: UseGetLabelsForDockerProps) =>
  useMutate<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', `/artifacts/docker/getLabels`, { base: getConfig('ng/api'), ...props })

/**
 * Gets docker labels
 */
export const getLabelsForDockerPromise = (
  props: MutateUsingFetchProps<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDockerResponseDTO,
    Failure | Error,
    GetLabelsForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/getLabels`, props, signal)

export interface GetLastSuccessfulBuildForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetLastSuccessfulBuildForDockerProps = Omit<
  MutateProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker last successful build
 */
export const GetLastSuccessfulBuildForDocker = (props: GetLastSuccessfulBuildForDockerProps) => (
  <Mutate<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/docker/getLastSuccessfulBuild`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForDockerProps = Omit<
  UseMutateProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets docker last successful build
 */
export const useGetLastSuccessfulBuildForDocker = (props: UseGetLastSuccessfulBuildForDockerProps) =>
  useMutate<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', `/artifacts/docker/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets docker last successful build
 */
export const getLastSuccessfulBuildForDockerPromise = (
  props: MutateUsingFetchProps<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDockerBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/getLastSuccessfulBuild`, props, signal)

export interface ValidateArtifactForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactForDockerProps = Omit<
  MutateProps<
    ResponseBoolean,
    Failure | Error,
    ValidateArtifactForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate docker artifact with tag/tagregx if given
 */
export const ValidateArtifactForDocker = (props: ValidateArtifactForDockerProps) => (
  <Mutate<ResponseBoolean, Failure | Error, ValidateArtifactForDockerQueryParams, DockerRequestDTORequestBody, void>
    verb="POST"
    path={`/artifacts/docker/validateArtifact`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactForDockerProps = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | Error,
    ValidateArtifactForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate docker artifact with tag/tagregx if given
 */
export const useValidateArtifactForDocker = (props: UseValidateArtifactForDockerProps) =>
  useMutate<ResponseBoolean, Failure | Error, ValidateArtifactForDockerQueryParams, DockerRequestDTORequestBody, void>(
    'POST',
    `/artifacts/docker/validateArtifact`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker artifact with tag/tagregx if given
 */
export const validateArtifactForDockerPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    ValidateArtifactForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    ValidateArtifactForDockerQueryParams,
    DockerRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/docker/validateArtifact`, props, signal)

export interface ValidateArtifactServerForDockerQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactServerForDockerProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker artifact server
 */
export const ValidateArtifactServerForDocker = (props: ValidateArtifactServerForDockerProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>
    path={`/artifacts/docker/validateArtifactServer`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForDockerProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker artifact server
 */
export const useValidateArtifactServerForDocker = (props: UseValidateArtifactServerForDockerProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>(
    `/artifacts/docker/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker artifact server
 */
export const validateArtifactServerForDockerPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactServerForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/validateArtifactServer`,
    props,
    signal
  )

export interface ValidateArtifactImageForDockerQueryParams {
  imagePath?: string
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactImageForDockerProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker image
 */
export const ValidateArtifactImageForDocker = (props: ValidateArtifactImageForDockerProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>
    path={`/artifacts/docker/validateArtifactSource`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactImageForDockerProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>,
  'path'
>

/**
 * Validate docker image
 */
export const useValidateArtifactImageForDocker = (props: UseValidateArtifactImageForDockerProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>(
    `/artifacts/docker/validateArtifactSource`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate docker image
 */
export const validateArtifactImageForDockerPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactImageForDockerQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/docker/validateArtifactSource`,
    props,
    signal
  )

export interface GetBuildDetailsForEcrQueryParams {
  imagePath: string
  region: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetBuildDetailsForEcrProps = Omit<
  GetProps<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>,
  'path'
>

/**
 * Gets ecr build details
 */
export const GetBuildDetailsForEcr = (props: GetBuildDetailsForEcrProps) => (
  <Get<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>
    path={`/artifacts/ecr/getBuildDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForEcrProps = Omit<
  UseGetProps<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>,
  'path'
>

/**
 * Gets ecr build details
 */
export const useGetBuildDetailsForEcr = (props: UseGetBuildDetailsForEcrProps) =>
  useGet<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>(
    `/artifacts/ecr/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets ecr build details
 */
export const getBuildDetailsForEcrPromise = (
  props: GetUsingFetchProps<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEcrResponseDTO, Failure | Error, GetBuildDetailsForEcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/ecr/getBuildDetails`,
    props,
    signal
  )

export interface GetBuildDetailsForEcrWithYamlQueryParams {
  imagePath: string
  region: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetBuildDetailsForEcrWithYamlProps = Omit<
  MutateProps<
    ResponseEcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForEcrWithYamlQueryParams,
    GetBuildDetailsForEcrWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr build details with yaml expression
 */
export const GetBuildDetailsForEcrWithYaml = (props: GetBuildDetailsForEcrWithYamlProps) => (
  <Mutate<
    ResponseEcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForEcrWithYamlQueryParams,
    GetBuildDetailsForEcrWithYamlBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/ecr/getBuildDetailsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForEcrWithYamlProps = Omit<
  UseMutateProps<
    ResponseEcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForEcrWithYamlQueryParams,
    GetBuildDetailsForEcrWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr build details with yaml expression
 */
export const useGetBuildDetailsForEcrWithYaml = (props: UseGetBuildDetailsForEcrWithYamlProps) =>
  useMutate<
    ResponseEcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForEcrWithYamlQueryParams,
    GetBuildDetailsForEcrWithYamlBodyRequestBody,
    void
  >('POST', `/artifacts/ecr/getBuildDetailsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets ecr build details with yaml expression
 */
export const getBuildDetailsForEcrWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseEcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForEcrWithYamlQueryParams,
    GetBuildDetailsForEcrWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForEcrWithYamlQueryParams,
    GetBuildDetailsForEcrWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/ecr/getBuildDetailsV2`, props, signal)

export interface GetImagesListForEcrQueryParams {
  region: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetImagesListForEcrProps = Omit<
  GetProps<ResponseEcrListImagesDTO, Failure | Error, GetImagesListForEcrQueryParams, void>,
  'path'
>

/**
 * Gets ecr images
 */
export const GetImagesListForEcr = (props: GetImagesListForEcrProps) => (
  <Get<ResponseEcrListImagesDTO, Failure | Error, GetImagesListForEcrQueryParams, void>
    path={`/artifacts/ecr/getImages`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetImagesListForEcrProps = Omit<
  UseGetProps<ResponseEcrListImagesDTO, Failure | Error, GetImagesListForEcrQueryParams, void>,
  'path'
>

/**
 * Gets ecr images
 */
export const useGetImagesListForEcr = (props: UseGetImagesListForEcrProps) =>
  useGet<ResponseEcrListImagesDTO, Failure | Error, GetImagesListForEcrQueryParams, void>(`/artifacts/ecr/getImages`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets ecr images
 */
export const getImagesListForEcrPromise = (
  props: GetUsingFetchProps<ResponseEcrListImagesDTO, Failure | Error, GetImagesListForEcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEcrListImagesDTO, Failure | Error, GetImagesListForEcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/ecr/getImages`,
    props,
    signal
  )

export interface GetLastSuccessfulBuildForEcrQueryParams {
  imagePath: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetLastSuccessfulBuildForEcrProps = Omit<
  MutateProps<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr last successful build
 */
export const GetLastSuccessfulBuildForEcr = (props: GetLastSuccessfulBuildForEcrProps) => (
  <Mutate<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/ecr/getLastSuccessfulBuild`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForEcrProps = Omit<
  UseMutateProps<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets ecr last successful build
 */
export const useGetLastSuccessfulBuildForEcr = (props: UseGetLastSuccessfulBuildForEcrProps) =>
  useMutate<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >('POST', `/artifacts/ecr/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets ecr last successful build
 */
export const getLastSuccessfulBuildForEcrPromise = (
  props: MutateUsingFetchProps<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/ecr/getLastSuccessfulBuild`, props, signal)

export interface ValidateArtifactForEcrQueryParams {
  imagePath: string
  region: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactForEcrProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, EcrRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate Ecr Artifact
 */
export const ValidateArtifactForEcr = (props: ValidateArtifactForEcrProps) => (
  <Mutate<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, EcrRequestDTORequestBody, void>
    verb="POST"
    path={`/artifacts/ecr/validateArtifact`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactForEcrProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, EcrRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate Ecr Artifact
 */
export const useValidateArtifactForEcr = (props: UseValidateArtifactForEcrProps) =>
  useMutate<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, EcrRequestDTORequestBody, void>(
    'POST',
    `/artifacts/ecr/validateArtifact`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Ecr Artifact
 */
export const validateArtifactForEcrPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    ValidateArtifactForEcrQueryParams,
    EcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactForEcrQueryParams, EcrRequestDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/artifacts/ecr/validateArtifact`,
    props,
    signal
  )

export interface ValidateArtifactServerForEcrQueryParams {
  imagePath: string
  connectorRef: string
  region: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactServerForEcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>,
  'path'
>

/**
 * Validate ecr artifact server
 */
export const ValidateArtifactServerForEcr = (props: ValidateArtifactServerForEcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>
    path={`/artifacts/ecr/validateArtifactServer`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForEcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>,
  'path'
>

/**
 * Validate ecr artifact server
 */
export const useValidateArtifactServerForEcr = (props: UseValidateArtifactServerForEcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>(
    `/artifacts/ecr/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate ecr artifact server
 */
export const validateArtifactServerForEcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactServerForEcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/ecr/validateArtifactServer`,
    props,
    signal
  )

export interface ValidateArtifactImageForEcrQueryParams {
  imagePath: string
  region: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactImageForEcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>,
  'path'
>

/**
 * Validate Ecr image
 */
export const ValidateArtifactImageForEcr = (props: ValidateArtifactImageForEcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>
    path={`/artifacts/ecr/validateArtifactSource`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactImageForEcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>,
  'path'
>

/**
 * Validate Ecr image
 */
export const useValidateArtifactImageForEcr = (props: UseValidateArtifactImageForEcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>(
    `/artifacts/ecr/validateArtifactSource`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Ecr image
 */
export const validateArtifactImageForEcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactImageForEcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/ecr/validateArtifactSource`,
    props,
    signal
  )

export interface GetBuildDetailsForGcrQueryParams {
  imagePath: string
  registryHostname: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetBuildDetailsForGcrProps = Omit<
  GetProps<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>,
  'path'
>

/**
 * Gets gcr build details
 */
export const GetBuildDetailsForGcr = (props: GetBuildDetailsForGcrProps) => (
  <Get<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>
    path={`/artifacts/gcr/getBuildDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForGcrProps = Omit<
  UseGetProps<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>,
  'path'
>

/**
 * Gets gcr build details
 */
export const useGetBuildDetailsForGcr = (props: UseGetBuildDetailsForGcrProps) =>
  useGet<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>(
    `/artifacts/gcr/getBuildDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets gcr build details
 */
export const getBuildDetailsForGcrPromise = (
  props: GetUsingFetchProps<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGcrResponseDTO, Failure | Error, GetBuildDetailsForGcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/gcr/getBuildDetails`,
    props,
    signal
  )

export interface GetBuildDetailsForGcrWithYamlQueryParams {
  imagePath: string
  registryHostname: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  pipelineIdentifier: string
  fqnPath: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetBuildDetailsForGcrWithYamlProps = Omit<
  MutateProps<
    ResponseGcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForGcrWithYamlQueryParams,
    GetBuildDetailsForEcrWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets gcr build details with Yaml expression
 */
export const GetBuildDetailsForGcrWithYaml = (props: GetBuildDetailsForGcrWithYamlProps) => (
  <Mutate<
    ResponseGcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForGcrWithYamlQueryParams,
    GetBuildDetailsForEcrWithYamlBodyRequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/gcr/getBuildDetailsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBuildDetailsForGcrWithYamlProps = Omit<
  UseMutateProps<
    ResponseGcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForGcrWithYamlQueryParams,
    GetBuildDetailsForEcrWithYamlBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets gcr build details with Yaml expression
 */
export const useGetBuildDetailsForGcrWithYaml = (props: UseGetBuildDetailsForGcrWithYamlProps) =>
  useMutate<
    ResponseGcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForGcrWithYamlQueryParams,
    GetBuildDetailsForEcrWithYamlBodyRequestBody,
    void
  >('POST', `/artifacts/gcr/getBuildDetailsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets gcr build details with Yaml expression
 */
export const getBuildDetailsForGcrWithYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseGcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForGcrWithYamlQueryParams,
    GetBuildDetailsForEcrWithYamlBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGcrResponseDTO,
    Failure | Error,
    GetBuildDetailsForGcrWithYamlQueryParams,
    GetBuildDetailsForEcrWithYamlBodyRequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/gcr/getBuildDetailsV2`, props, signal)

export interface GetLastSuccessfulBuildForGcrQueryParams {
  imagePath: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetLastSuccessfulBuildForGcrProps = Omit<
  MutateProps<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets gcr last successful build
 */
export const GetLastSuccessfulBuildForGcr = (props: GetLastSuccessfulBuildForGcrProps) => (
  <Mutate<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/artifacts/gcr/getLastSuccessfulBuild`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastSuccessfulBuildForGcrProps = Omit<
  UseMutateProps<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets gcr last successful build
 */
export const useGetLastSuccessfulBuildForGcr = (props: UseGetLastSuccessfulBuildForGcrProps) =>
  useMutate<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >('POST', `/artifacts/gcr/getLastSuccessfulBuild`, { base: getConfig('ng/api'), ...props })

/**
 * Gets gcr last successful build
 */
export const getLastSuccessfulBuildForGcrPromise = (
  props: MutateUsingFetchProps<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGcrBuildDetailsDTO,
    Failure | Error,
    GetLastSuccessfulBuildForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/artifacts/gcr/getLastSuccessfulBuild`, props, signal)

export interface ValidateArtifactForGcrQueryParams {
  imagePath: string
  registryHostname: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactForGcrProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, GcrRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate Gcr Artifact
 */
export const ValidateArtifactForGcr = (props: ValidateArtifactForGcrProps) => (
  <Mutate<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, GcrRequestDTORequestBody, void>
    verb="POST"
    path={`/artifacts/gcr/validateArtifact`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactForGcrProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, GcrRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate Gcr Artifact
 */
export const useValidateArtifactForGcr = (props: UseValidateArtifactForGcrProps) =>
  useMutate<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, GcrRequestDTORequestBody, void>(
    'POST',
    `/artifacts/gcr/validateArtifact`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Gcr Artifact
 */
export const validateArtifactForGcrPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    ValidateArtifactForGcrQueryParams,
    GcrRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactForGcrQueryParams, GcrRequestDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/artifacts/gcr/validateArtifact`,
    props,
    signal
  )

export interface ValidateArtifactServerForGcrQueryParams {
  imagePath: string
  connectorRef: string
  registryHostname: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactServerForGcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>,
  'path'
>

/**
 * Validate gcr artifact server
 */
export const ValidateArtifactServerForGcr = (props: ValidateArtifactServerForGcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>
    path={`/artifacts/gcr/validateArtifactServer`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactServerForGcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>,
  'path'
>

/**
 * Validate gcr artifact server
 */
export const useValidateArtifactServerForGcr = (props: UseValidateArtifactServerForGcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>(
    `/artifacts/gcr/validateArtifactServer`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate gcr artifact server
 */
export const validateArtifactServerForGcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactServerForGcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/gcr/validateArtifactServer`,
    props,
    signal
  )

export interface ValidateArtifactImageForGcrQueryParams {
  imagePath: string
  registryHostname: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type ValidateArtifactImageForGcrProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>,
  'path'
>

/**
 * Validate Gcr image
 */
export const ValidateArtifactImageForGcr = (props: ValidateArtifactImageForGcrProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>
    path={`/artifacts/gcr/validateArtifactSource`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateArtifactImageForGcrProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>,
  'path'
>

/**
 * Validate Gcr image
 */
export const useValidateArtifactImageForGcr = (props: UseValidateArtifactImageForGcrProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>(
    `/artifacts/gcr/validateArtifactSource`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Gcr image
 */
export const validateArtifactImageForGcrPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateArtifactImageForGcrQueryParams, void>(
    getConfig('ng/api'),
    `/artifacts/gcr/validateArtifactSource`,
    props,
    signal
  )

export interface GetAuthenticationSettingsQueryParams {
  accountIdentifier: string
}

export type GetAuthenticationSettingsProps = Omit<
  GetProps<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>,
  'path'
>

/**
 * Get authentication settings for an account
 */
export const GetAuthenticationSettings = (props: GetAuthenticationSettingsProps) => (
  <Get<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>
    path={`/authentication-settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAuthenticationSettingsProps = Omit<
  UseGetProps<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>,
  'path'
>

/**
 * Get authentication settings for an account
 */
export const useGetAuthenticationSettings = (props: UseGetAuthenticationSettingsProps) =>
  useGet<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>(
    `/authentication-settings`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get authentication settings for an account
 */
export const getAuthenticationSettingsPromise = (
  props: GetUsingFetchProps<
    RestResponseAuthenticationSettingsResponse,
    unknown,
    GetAuthenticationSettingsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseAuthenticationSettingsResponse, unknown, GetAuthenticationSettingsQueryParams, void>(
    getConfig('ng/api'),
    `/authentication-settings`,
    props,
    signal
  )

export interface DeleteSamlMetaDataQueryParams {
  accountIdentifier: string
}

export type DeleteSamlMetaDataProps = Omit<
  MutateProps<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete SAML Config
 */
export const DeleteSamlMetaData = (props: DeleteSamlMetaDataProps) => (
  <Mutate<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>
    verb="DELETE"
    path={`/authentication-settings/delete-saml-metadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSamlMetaDataProps = Omit<
  UseMutateProps<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete SAML Config
 */
export const useDeleteSamlMetaData = (props: UseDeleteSamlMetaDataProps) =>
  useMutate<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>(
    'DELETE',
    `/authentication-settings/delete-saml-metadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete SAML Config
 */
export const deleteSamlMetaDataPromise = (
  props: MutateUsingFetchProps<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseSSOConfig, unknown, DeleteSamlMetaDataQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/authentication-settings/delete-saml-metadata`,
    props,
    signal
  )

export interface GetPasswordStrengthSettingsQueryParams {
  accountIdentifier: string
}

export type GetPasswordStrengthSettingsProps = Omit<
  GetProps<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>,
  'path'
>

/**
 * Get Password strength settings
 */
export const GetPasswordStrengthSettings = (props: GetPasswordStrengthSettingsProps) => (
  <Get<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>
    path={`/authentication-settings/login-settings/password-strength`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPasswordStrengthSettingsProps = Omit<
  UseGetProps<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>,
  'path'
>

/**
 * Get Password strength settings
 */
export const useGetPasswordStrengthSettings = (props: UseGetPasswordStrengthSettingsProps) =>
  useGet<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>(
    `/authentication-settings/login-settings/password-strength`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Password strength settings
 */
export const getPasswordStrengthSettingsPromise = (
  props: GetUsingFetchProps<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePasswordStrengthPolicy, unknown, GetPasswordStrengthSettingsQueryParams, void>(
    getConfig('ng/api'),
    `/authentication-settings/login-settings/password-strength`,
    props,
    signal
  )

export interface PutLoginSettingsQueryParams {
  accountIdentifier?: string
}

export interface PutLoginSettingsPathParams {
  loginSettingsId: string
}

export type PutLoginSettingsProps = Omit<
  MutateProps<
    RestResponseLoginSettings,
    unknown,
    PutLoginSettingsQueryParams,
    LoginSettings,
    PutLoginSettingsPathParams
  >,
  'path' | 'verb'
> &
  PutLoginSettingsPathParams

/**
 * Update login settings - lockout, expiration, strength
 */
export const PutLoginSettings = ({ loginSettingsId, ...props }: PutLoginSettingsProps) => (
  <Mutate<RestResponseLoginSettings, unknown, PutLoginSettingsQueryParams, LoginSettings, PutLoginSettingsPathParams>
    verb="PUT"
    path={`/authentication-settings/login-settings/${loginSettingsId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutLoginSettingsProps = Omit<
  UseMutateProps<
    RestResponseLoginSettings,
    unknown,
    PutLoginSettingsQueryParams,
    LoginSettings,
    PutLoginSettingsPathParams
  >,
  'path' | 'verb'
> &
  PutLoginSettingsPathParams

/**
 * Update login settings - lockout, expiration, strength
 */
export const usePutLoginSettings = ({ loginSettingsId, ...props }: UsePutLoginSettingsProps) =>
  useMutate<RestResponseLoginSettings, unknown, PutLoginSettingsQueryParams, LoginSettings, PutLoginSettingsPathParams>(
    'PUT',
    (paramsInPath: PutLoginSettingsPathParams) =>
      `/authentication-settings/login-settings/${paramsInPath.loginSettingsId}`,
    { base: getConfig('ng/api'), pathParams: { loginSettingsId }, ...props }
  )

/**
 * Update login settings - lockout, expiration, strength
 */
export const putLoginSettingsPromise = (
  {
    loginSettingsId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseLoginSettings,
    unknown,
    PutLoginSettingsQueryParams,
    LoginSettings,
    PutLoginSettingsPathParams
  > & { loginSettingsId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseLoginSettings,
    unknown,
    PutLoginSettingsQueryParams,
    LoginSettings,
    PutLoginSettingsPathParams
  >('PUT', getConfig('ng/api'), `/authentication-settings/login-settings/${loginSettingsId}`, props, signal)

export interface RemoveOauthMechanismQueryParams {
  accountIdentifier: string
}

export type RemoveOauthMechanismProps = Omit<
  MutateProps<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Remove Oauth mechanism for an account
 */
export const RemoveOauthMechanism = (props: RemoveOauthMechanismProps) => (
  <Mutate<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>
    verb="DELETE"
    path={`/authentication-settings/oauth/remove-mechanism`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRemoveOauthMechanismProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Remove Oauth mechanism for an account
 */
export const useRemoveOauthMechanism = (props: UseRemoveOauthMechanismProps) =>
  useMutate<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>(
    'DELETE',
    `/authentication-settings/oauth/remove-mechanism`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Remove Oauth mechanism for an account
 */
export const removeOauthMechanismPromise = (
  props: MutateUsingFetchProps<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, RemoveOauthMechanismQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/authentication-settings/oauth/remove-mechanism`,
    props,
    signal
  )

export interface UpdateOauthProvidersQueryParams {
  accountIdentifier: string
}

export type UpdateOauthProvidersProps = Omit<
  MutateProps<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>,
  'path' | 'verb'
>

/**
 * Update Oauth providers for an account
 */
export const UpdateOauthProviders = (props: UpdateOauthProvidersProps) => (
  <Mutate<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>
    verb="PUT"
    path={`/authentication-settings/oauth/update-providers`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateOauthProvidersProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>,
  'path' | 'verb'
>

/**
 * Update Oauth providers for an account
 */
export const useUpdateOauthProviders = (props: UseUpdateOauthProvidersProps) =>
  useMutate<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>(
    'PUT',
    `/authentication-settings/oauth/update-providers`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update Oauth providers for an account
 */
export const updateOauthProvidersPromise = (
  props: MutateUsingFetchProps<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, UpdateOauthProvidersQueryParams, OAuthSettings, void>(
    'PUT',
    getConfig('ng/api'),
    `/authentication-settings/oauth/update-providers`,
    props,
    signal
  )

export interface GetSamlLoginTestQueryParams {
  accountId: string
}

export type GetSamlLoginTestProps = Omit<
  GetProps<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>,
  'path'
>

/**
 * Get SAML Login Test
 */
export const GetSamlLoginTest = (props: GetSamlLoginTestProps) => (
  <Get<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>
    path={`/authentication-settings/saml-login-test`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSamlLoginTestProps = Omit<
  UseGetProps<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>,
  'path'
>

/**
 * Get SAML Login Test
 */
export const useGetSamlLoginTest = (props: UseGetSamlLoginTestProps) =>
  useGet<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>(
    `/authentication-settings/saml-login-test`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get SAML Login Test
 */
export const getSamlLoginTestPromise = (
  props: GetUsingFetchProps<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponseLoginTypeResponse, unknown, GetSamlLoginTestQueryParams, void>(
    getConfig('ng/api'),
    `/authentication-settings/saml-login-test`,
    props,
    signal
  )

export interface UploadSamlMetaDataQueryParams {
  accountId: string
}

export type UploadSamlMetaDataProps = Omit<
  MutateProps<RestResponseSSOConfig, unknown, UploadSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create SAML Config
 */
export const UploadSamlMetaData = (props: UploadSamlMetaDataProps) => (
  <Mutate<RestResponseSSOConfig, unknown, UploadSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>
    verb="POST"
    path={`/authentication-settings/saml-metadata-upload`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUploadSamlMetaDataProps = Omit<
  UseMutateProps<RestResponseSSOConfig, unknown, UploadSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create SAML Config
 */
export const useUploadSamlMetaData = (props: UseUploadSamlMetaDataProps) =>
  useMutate<RestResponseSSOConfig, unknown, UploadSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>(
    'POST',
    `/authentication-settings/saml-metadata-upload`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create SAML Config
 */
export const uploadSamlMetaDataPromise = (
  props: MutateUsingFetchProps<
    RestResponseSSOConfig,
    unknown,
    UploadSamlMetaDataQueryParams,
    UploadSamlMetaDataRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseSSOConfig, unknown, UploadSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/authentication-settings/saml-metadata-upload`,
    props,
    signal
  )

export interface UpdateSamlMetaDataQueryParams {
  accountId: string
}

export type UpdateSamlMetaDataProps = Omit<
  MutateProps<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>,
  'path' | 'verb'
>

/**
 * Edit SAML Config
 */
export const UpdateSamlMetaData = (props: UpdateSamlMetaDataProps) => (
  <Mutate<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>
    verb="PUT"
    path={`/authentication-settings/saml-metadata-upload`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSamlMetaDataProps = Omit<
  UseMutateProps<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>,
  'path' | 'verb'
>

/**
 * Edit SAML Config
 */
export const useUpdateSamlMetaData = (props: UseUpdateSamlMetaDataProps) =>
  useMutate<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>(
    'PUT',
    `/authentication-settings/saml-metadata-upload`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Edit SAML Config
 */
export const updateSamlMetaDataPromise = (
  props: MutateUsingFetchProps<
    RestResponseSSOConfig,
    unknown,
    UpdateSamlMetaDataQueryParams,
    UploadSamlMetaDataRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseSSOConfig, unknown, UpdateSamlMetaDataQueryParams, UploadSamlMetaDataRequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/authentication-settings/saml-metadata-upload`,
    props,
    signal
  )

export interface SetTwoFactorAuthAtAccountLevelQueryParams {
  accountIdentifier: string
}

export type SetTwoFactorAuthAtAccountLevelProps = Omit<
  MutateProps<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >,
  'path' | 'verb'
>

/**
 * Set account level two factor auth setting
 */
export const SetTwoFactorAuthAtAccountLevel = (props: SetTwoFactorAuthAtAccountLevelProps) => (
  <Mutate<RestResponseBoolean, unknown, SetTwoFactorAuthAtAccountLevelQueryParams, TwoFactorAdminOverrideSettings, void>
    verb="PUT"
    path={`/authentication-settings/two-factor-admin-override-settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSetTwoFactorAuthAtAccountLevelProps = Omit<
  UseMutateProps<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >,
  'path' | 'verb'
>

/**
 * Set account level two factor auth setting
 */
export const useSetTwoFactorAuthAtAccountLevel = (props: UseSetTwoFactorAuthAtAccountLevelProps) =>
  useMutate<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >('PUT', `/authentication-settings/two-factor-admin-override-settings`, { base: getConfig('ng/api'), ...props })

/**
 * Set account level two factor auth setting
 */
export const setTwoFactorAuthAtAccountLevelPromise = (
  props: MutateUsingFetchProps<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseBoolean,
    unknown,
    SetTwoFactorAuthAtAccountLevelQueryParams,
    TwoFactorAdminOverrideSettings,
    void
  >('PUT', getConfig('ng/api'), `/authentication-settings/two-factor-admin-override-settings`, props, signal)

export interface UpdateAuthMechanismQueryParams {
  accountIdentifier: string
  authenticationMechanism?: 'USER_PASSWORD' | 'SAML' | 'LDAP' | 'OAUTH'
}

export type UpdateAuthMechanismProps = Omit<
  MutateProps<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Update Auth mechanism for an account
 */
export const UpdateAuthMechanism = (props: UpdateAuthMechanismProps) => (
  <Mutate<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>
    verb="PUT"
    path={`/authentication-settings/update-auth-mechanism`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateAuthMechanismProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Update Auth mechanism for an account
 */
export const useUpdateAuthMechanism = (props: UseUpdateAuthMechanismProps) =>
  useMutate<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>(
    'PUT',
    `/authentication-settings/update-auth-mechanism`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update Auth mechanism for an account
 */
export const updateAuthMechanismPromise = (
  props: MutateUsingFetchProps<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseBoolean, unknown, UpdateAuthMechanismQueryParams, void, void>(
    'PUT',
    getConfig('ng/api'),
    `/authentication-settings/update-auth-mechanism`,
    props,
    signal
  )

export interface UpdateWhitelistedDomainsQueryParams {
  accountIdentifier: string
}

export type UpdateWhitelistedDomainsProps = Omit<
  MutateProps<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update Whitelisted domains for an account
 */
export const UpdateWhitelistedDomains = (props: UpdateWhitelistedDomainsProps) => (
  <Mutate<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >
    verb="PUT"
    path={`/authentication-settings/whitelisted-domains`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateWhitelistedDomainsProps = Omit<
  UseMutateProps<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update Whitelisted domains for an account
 */
export const useUpdateWhitelistedDomains = (props: UseUpdateWhitelistedDomainsProps) =>
  useMutate<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >('PUT', `/authentication-settings/whitelisted-domains`, { base: getConfig('ng/api'), ...props })

/**
 * Update Whitelisted domains for an account
 */
export const updateWhitelistedDomainsPromise = (
  props: MutateUsingFetchProps<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseBoolean,
    unknown,
    UpdateWhitelistedDomainsQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    void
  >('PUT', getConfig('ng/api'), `/authentication-settings/whitelisted-domains`, props, signal)

export interface GetGCSBucketListQueryParams {
  connectorRef?: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetGCSBucketListProps = Omit<
  GetProps<ResponseMapStringString, Failure | Error, GetGCSBucketListQueryParams, void>,
  'path'
>

/**
 * Gets GCS buckets list
 */
export const GetGCSBucketList = (props: GetGCSBucketListProps) => (
  <Get<ResponseMapStringString, Failure | Error, GetGCSBucketListQueryParams, void>
    path={`/buckets/gcs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGCSBucketListProps = Omit<
  UseGetProps<ResponseMapStringString, Failure | Error, GetGCSBucketListQueryParams, void>,
  'path'
>

/**
 * Gets GCS buckets list
 */
export const useGetGCSBucketList = (props: UseGetGCSBucketListProps) =>
  useGet<ResponseMapStringString, Failure | Error, GetGCSBucketListQueryParams, void>(`/buckets/gcs`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets GCS buckets list
 */
export const getGCSBucketListPromise = (
  props: GetUsingFetchProps<ResponseMapStringString, Failure | Error, GetGCSBucketListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapStringString, Failure | Error, GetGCSBucketListQueryParams, void>(
    getConfig('ng/api'),
    `/buckets/gcs`,
    props,
    signal
  )

export interface GetBucketListForS3QueryParams {
  region: string
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetBucketListForS3Props = Omit<
  GetProps<ResponseMapStringString, Failure | Error, GetBucketListForS3QueryParams, void>,
  'path'
>

/**
 * Gets s3 buckets
 */
export const GetBucketListForS3 = (props: GetBucketListForS3Props) => (
  <Get<ResponseMapStringString, Failure | Error, GetBucketListForS3QueryParams, void>
    path={`/buckets/s3/getBuckets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBucketListForS3Props = Omit<
  UseGetProps<ResponseMapStringString, Failure | Error, GetBucketListForS3QueryParams, void>,
  'path'
>

/**
 * Gets s3 buckets
 */
export const useGetBucketListForS3 = (props: UseGetBucketListForS3Props) =>
  useGet<ResponseMapStringString, Failure | Error, GetBucketListForS3QueryParams, void>(`/buckets/s3/getBuckets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets s3 buckets
 */
export const getBucketListForS3Promise = (
  props: GetUsingFetchProps<ResponseMapStringString, Failure | Error, GetBucketListForS3QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapStringString, Failure | Error, GetBucketListForS3QueryParams, void>(
    getConfig('ng/api'),
    `/buckets/s3/getBuckets`,
    props,
    signal
  )

export interface GetConnectorListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  type?:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
  category?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  source_category?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetConnectorListProps = Omit<
  GetProps<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>,
  'path'
>

/**
 * Gets Connector list
 */
export const GetConnectorList = (props: GetConnectorListProps) => (
  <Get<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>
    path={`/connectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorListProps = Omit<
  UseGetProps<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>,
  'path'
>

/**
 * Gets Connector list
 */
export const useGetConnectorList = (props: UseGetConnectorListProps) =>
  useGet<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>(`/connectors`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Connector list
 */
export const getConnectorListPromise = (
  props: GetUsingFetchProps<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageConnectorResponse, Failure | Error, GetConnectorListQueryParams, void>(
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface CreateConnectorQueryParams {
  accountIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
}

export type CreateConnectorProps = Omit<
  MutateProps<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates a Connector
 */
export const CreateConnector = (props: CreateConnectorProps) => (
  <Mutate<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>
    verb="POST"
    path={`/connectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateConnectorProps = Omit<
  UseMutateProps<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Creates a Connector
 */
export const useCreateConnector = (props: UseCreateConnectorProps) =>
  useMutate<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>(
    'POST',
    `/connectors`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Creates a Connector
 */
export const createConnectorPromise = (
  props: MutateUsingFetchProps<
    ResponseConnectorResponse,
    Failure | Error,
    CreateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseConnectorResponse, Failure | Error, CreateConnectorQueryParams, ConnectorRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface UpdateConnectorQueryParams {
  accountIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
  baseBranch?: string
}

export type UpdateConnectorProps = Omit<
  MutateProps<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates a Connector
 */
export const UpdateConnector = (props: UpdateConnectorProps) => (
  <Mutate<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>
    verb="PUT"
    path={`/connectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateConnectorProps = Omit<
  UseMutateProps<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>,
  'path' | 'verb'
>

/**
 * Updates a Connector
 */
export const useUpdateConnector = (props: UseUpdateConnectorProps) =>
  useMutate<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>(
    'PUT',
    `/connectors`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Updates a Connector
 */
export const updateConnectorPromise = (
  props: MutateUsingFetchProps<
    ResponseConnectorResponse,
    Failure | Error,
    UpdateConnectorQueryParams,
    ConnectorRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseConnectorResponse, Failure | Error, UpdateConnectorQueryParams, ConnectorRequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface GetConnectorCatalogueQueryParams {
  accountIdentifier?: string
}

export type GetConnectorCatalogueProps = Omit<
  GetProps<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>,
  'path'
>

/**
 * Get Connector Catalogue
 */
export const GetConnectorCatalogue = (props: GetConnectorCatalogueProps) => (
  <Get<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>
    path={`/connectors/catalogue`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorCatalogueProps = Omit<
  UseGetProps<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>,
  'path'
>

/**
 * Get Connector Catalogue
 */
export const useGetConnectorCatalogue = (props: UseGetConnectorCatalogueProps) =>
  useGet<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>(
    `/connectors/catalogue`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Connector Catalogue
 */
export const getConnectorCataloguePromise = (
  props: GetUsingFetchProps<
    ResponseConnectorCatalogueResponse,
    Failure | Error,
    GetConnectorCatalogueQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectorCatalogueResponse, Failure | Error, GetConnectorCatalogueQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/catalogue`,
    props,
    signal
  )

export interface GetAllAllowedFieldValuesQueryParams {
  connectorType:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
}

export type GetAllAllowedFieldValuesProps = Omit<
  GetProps<ResponseFieldValues, Failure | Error, GetAllAllowedFieldValuesQueryParams, void>,
  'path'
>

/**
 * Get All Allowed field values for Connector Type
 */
export const GetAllAllowedFieldValues = (props: GetAllAllowedFieldValuesProps) => (
  <Get<ResponseFieldValues, Failure | Error, GetAllAllowedFieldValuesQueryParams, void>
    path={`/connectors/fieldValues`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAllAllowedFieldValuesProps = Omit<
  UseGetProps<ResponseFieldValues, Failure | Error, GetAllAllowedFieldValuesQueryParams, void>,
  'path'
>

/**
 * Get All Allowed field values for Connector Type
 */
export const useGetAllAllowedFieldValues = (props: UseGetAllAllowedFieldValuesProps) =>
  useGet<ResponseFieldValues, Failure | Error, GetAllAllowedFieldValuesQueryParams, void>(`/connectors/fieldValues`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get All Allowed field values for Connector Type
 */
export const getAllAllowedFieldValuesPromise = (
  props: GetUsingFetchProps<ResponseFieldValues, Failure | Error, GetAllAllowedFieldValuesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFieldValues, Failure | Error, GetAllAllowedFieldValuesQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/fieldValues`,
    props,
    signal
  )

export interface GetCEAwsTemplateQueryParams {
  eventsEnabled?: boolean
  curEnabled?: boolean
  optimizationEnabled?: boolean
}

export type GetCEAwsTemplateProps = Omit<
  MutateProps<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Get CCM Aws Connector Template URL Environment Wise
 */
export const GetCEAwsTemplate = (props: GetCEAwsTemplateProps) => (
  <Mutate<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>
    verb="POST"
    path={`/connectors/getceawstemplateurl`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCEAwsTemplateProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Get CCM Aws Connector Template URL Environment Wise
 */
export const useGetCEAwsTemplate = (props: UseGetCEAwsTemplateProps) =>
  useMutate<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>(
    'POST',
    `/connectors/getceawstemplateurl`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get CCM Aws Connector Template URL Environment Wise
 */
export const getCEAwsTemplatePromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, GetCEAwsTemplateQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/connectors/getceawstemplateurl`,
    props,
    signal
  )

export interface GetConnectorListV2QueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  searchTerm?: string
  orgIdentifier?: string
  projectIdentifier?: string
  filterIdentifier?: string
  includeAllConnectorsAvailableAtScope?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  getDistinctFromBranches?: boolean
}

export type GetConnectorListV2Props = Omit<
  MutateProps<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const GetConnectorListV2 = (props: GetConnectorListV2Props) => (
  <Mutate<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterProperties,
    void
  >
    verb="POST"
    path={`/connectors/listV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorListV2Props = Omit<
  UseMutateProps<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const useGetConnectorListV2 = (props: UseGetConnectorListV2Props) =>
  useMutate<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterProperties,
    void
  >('POST', `/connectors/listV2`, { base: getConfig('ng/api'), ...props })

/**
 * Gets Connector list
 */
export const getConnectorListV2Promise = (
  props: MutateUsingFetchProps<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageConnectorResponse,
    Failure | Error,
    GetConnectorListV2QueryParams,
    ConnectorFilterProperties,
    void
  >('POST', getConfig('ng/api'), `/connectors/listV2`, props, signal)

export interface ListConnectorByFQNQueryParams {
  accountIdentifier?: string
}

export type ListConnectorByFQNProps = Omit<
  MutateProps<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const ListConnectorByFQN = (props: ListConnectorByFQNProps) => (
  <Mutate<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>
    verb="POST"
    path={`/connectors/listbyfqn`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListConnectorByFQNProps = Omit<
  UseMutateProps<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>,
  'path' | 'verb'
>

/**
 * Gets Connector list
 */
export const useListConnectorByFQN = (props: UseListConnectorByFQNProps) =>
  useMutate<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>(
    'POST',
    `/connectors/listbyfqn`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Connector list
 */
export const listConnectorByFQNPromise = (
  props: MutateUsingFetchProps<
    ResponseListConnectorResponse,
    Failure | Error,
    ListConnectorByFQNQueryParams,
    string[],
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseListConnectorResponse, Failure | Error, ListConnectorByFQNQueryParams, string[], void>(
    'POST',
    getConfig('ng/api'),
    `/connectors/listbyfqn`,
    props,
    signal
  )

export interface GetConnectorStatisticsQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetConnectorStatisticsProps = Omit<
  GetProps<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>,
  'path'
>

/**
 * Get Connectors statistics
 */
export const GetConnectorStatistics = (props: GetConnectorStatisticsProps) => (
  <Get<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>
    path={`/connectors/stats`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorStatisticsProps = Omit<
  UseGetProps<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>,
  'path'
>

/**
 * Get Connectors statistics
 */
export const useGetConnectorStatistics = (props: UseGetConnectorStatisticsProps) =>
  useGet<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>(`/connectors/stats`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Connectors statistics
 */
export const getConnectorStatisticsPromise = (
  props: GetUsingFetchProps<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectorStatistics, Failure | Error, GetConnectorStatisticsQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/stats`,
    props,
    signal
  )

export interface GetTestConnectionResultQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export interface GetTestConnectionResultPathParams {
  identifier: string
}

export type GetTestConnectionResultProps = Omit<
  MutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultPathParams

/**
 * Test the connection
 */
export const GetTestConnectionResult = ({ identifier, ...props }: GetTestConnectionResultProps) => (
  <Mutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >
    verb="POST"
    path={`/connectors/testConnection/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTestConnectionResultProps = Omit<
  UseMutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultPathParams

/**
 * Test the connection
 */
export const useGetTestConnectionResult = ({ identifier, ...props }: UseGetTestConnectionResultProps) =>
  useMutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >(
    'POST',
    (paramsInPath: GetTestConnectionResultPathParams) => `/connectors/testConnection/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Test the connection
 */
export const getTestConnectionResultPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultQueryParams,
    void,
    GetTestConnectionResultPathParams
  >('POST', getConfig('ng/api'), `/connectors/testConnection/${identifier}`, props, signal)

export interface GetTestConnectionResultInternalQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetTestConnectionResultInternalPathParams {
  identifier: string
}

export type GetTestConnectionResultInternalProps = Omit<
  MutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultInternalQueryParams,
    void,
    GetTestConnectionResultInternalPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultInternalPathParams

/**
 * Test the connection internal api
 */
export const GetTestConnectionResultInternal = ({ identifier, ...props }: GetTestConnectionResultInternalProps) => (
  <Mutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultInternalQueryParams,
    void,
    GetTestConnectionResultInternalPathParams
  >
    verb="POST"
    path={`/connectors/testConnectionInternal/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTestConnectionResultInternalProps = Omit<
  UseMutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultInternalQueryParams,
    void,
    GetTestConnectionResultInternalPathParams
  >,
  'path' | 'verb'
> &
  GetTestConnectionResultInternalPathParams

/**
 * Test the connection internal api
 */
export const useGetTestConnectionResultInternal = ({ identifier, ...props }: UseGetTestConnectionResultInternalProps) =>
  useMutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultInternalQueryParams,
    void,
    GetTestConnectionResultInternalPathParams
  >(
    'POST',
    (paramsInPath: GetTestConnectionResultInternalPathParams) =>
      `/connectors/testConnectionInternal/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Test the connection internal api
 */
export const getTestConnectionResultInternalPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultInternalQueryParams,
    void,
    GetTestConnectionResultInternalPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestConnectionResultInternalQueryParams,
    void,
    GetTestConnectionResultInternalPathParams
  >('POST', getConfig('ng/api'), `/connectors/testConnectionInternal/${identifier}`, props, signal)

export interface GetTestGitRepoConnectionResultQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoURL?: string
}

export interface GetTestGitRepoConnectionResultPathParams {
  identifier: string
}

export type GetTestGitRepoConnectionResultProps = Omit<
  MutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestGitRepoConnectionResultPathParams

/**
 * Test the connection
 */
export const GetTestGitRepoConnectionResult = ({ identifier, ...props }: GetTestGitRepoConnectionResultProps) => (
  <Mutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >
    verb="POST"
    path={`/connectors/testGitRepoConnection/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTestGitRepoConnectionResultProps = Omit<
  UseMutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >,
  'path' | 'verb'
> &
  GetTestGitRepoConnectionResultPathParams

/**
 * Test the connection
 */
export const useGetTestGitRepoConnectionResult = ({ identifier, ...props }: UseGetTestGitRepoConnectionResultProps) =>
  useMutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >(
    'POST',
    (paramsInPath: GetTestGitRepoConnectionResultPathParams) =>
      `/connectors/testGitRepoConnection/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Test the connection
 */
export const getTestGitRepoConnectionResultPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseConnectorValidationResult,
    Failure | Error,
    GetTestGitRepoConnectionResultQueryParams,
    void,
    GetTestGitRepoConnectionResultPathParams
  >('POST', getConfig('ng/api'), `/connectors/testGitRepoConnection/${identifier}`, props, signal)

export interface ValidateTheIdentifierIsUniqueQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ValidateTheIdentifierIsUniqueProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const ValidateTheIdentifierIsUnique = (props: ValidateTheIdentifierIsUniqueProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>
    path={`/connectors/validateUniqueIdentifier`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateTheIdentifierIsUniqueProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const useValidateTheIdentifierIsUnique = (props: UseValidateTheIdentifierIsUniqueProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>(
    `/connectors/validateUniqueIdentifier`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Identifier is unique
 */
export const validateTheIdentifierIsUniquePromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateTheIdentifierIsUniqueQueryParams, void>(
    getConfig('ng/api'),
    `/connectors/validateUniqueIdentifier`,
    props,
    signal
  )

export interface DeleteConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  lastObjectId?: string
}

export type DeleteConnectorProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector by identifier
 */
export const DeleteConnector = (props: DeleteConnectorProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>
    verb="DELETE"
    path={`/connectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteConnectorProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a connector by identifier
 */
export const useDeleteConnector = (props: UseDeleteConnectorProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>('DELETE', `/connectors`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a connector by identifier
 */
export const deleteConnectorPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteConnectorQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/connectors`,
    props,
    signal
  )

export interface GetConnectorQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export interface GetConnectorPathParams {
  identifier: string
}

export type GetConnectorProps = Omit<
  GetProps<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>,
  'path'
> &
  GetConnectorPathParams

/**
 * Get Connector
 */
export const GetConnector = ({ identifier, ...props }: GetConnectorProps) => (
  <Get<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>
    path={`/connectors/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetConnectorProps = Omit<
  UseGetProps<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>,
  'path'
> &
  GetConnectorPathParams

/**
 * Get Connector
 */
export const useGetConnector = ({ identifier, ...props }: UseGetConnectorProps) =>
  useGet<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>(
    (paramsInPath: GetConnectorPathParams) => `/connectors/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Connector
 */
export const getConnectorPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseConnectorResponse, Failure | Error, GetConnectorQueryParams, GetConnectorPathParams>(
    getConfig('ng/api'),
    `/connectors/${identifier}`,
    props,
    signal
  )

export interface GetDeploymentExecutionQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
}

export type GetDeploymentExecutionProps = Omit<
  GetProps<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>,
  'path'
>

/**
 * Get deployment execution
 */
export const GetDeploymentExecution = (props: GetDeploymentExecutionProps) => (
  <Get<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>
    path={`/dashboard/deploymentExecution`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentExecutionProps = Omit<
  UseGetProps<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>,
  'path'
>

/**
 * Get deployment execution
 */
export const useGetDeploymentExecution = (props: UseGetDeploymentExecutionProps) =>
  useGet<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>(
    `/dashboard/deploymentExecution`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get deployment execution
 */
export const getDeploymentExecutionPromise = (
  props: GetUsingFetchProps<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseExecutionDeploymentInfo, Failure | Error, GetDeploymentExecutionQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/deploymentExecution`,
    props,
    signal
  )

export interface GetDeploymentHealthQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
}

export type GetDeploymentHealthProps = Omit<
  GetProps<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>,
  'path'
>

/**
 * Get deployment health
 */
export const GetDeploymentHealth = (props: GetDeploymentHealthProps) => (
  <Get<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>
    path={`/dashboard/deploymentHealth`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentHealthProps = Omit<
  UseGetProps<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>,
  'path'
>

/**
 * Get deployment health
 */
export const useGetDeploymentHealth = (props: UseGetDeploymentHealthProps) =>
  useGet<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>(
    `/dashboard/deploymentHealth`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get deployment health
 */
export const getDeploymentHealthPromise = (
  props: GetUsingFetchProps<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseHealthDeploymentDashboard, Failure | Error, GetDeploymentHealthQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/deploymentHealth`,
    props,
    signal
  )

export interface GetActiveServiceInstanceSummaryQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  serviceId: string
  timestamp: number
}

export type GetActiveServiceInstanceSummaryProps = Omit<
  GetProps<ResponseActiveServiceInstanceSummary, Failure | Error, GetActiveServiceInstanceSummaryQueryParams, void>,
  'path'
>

/**
 * Get active service instance summary
 */
export const GetActiveServiceInstanceSummary = (props: GetActiveServiceInstanceSummaryProps) => (
  <Get<ResponseActiveServiceInstanceSummary, Failure | Error, GetActiveServiceInstanceSummaryQueryParams, void>
    path={`/dashboard/getActiveServiceInstanceSummary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveServiceInstanceSummaryProps = Omit<
  UseGetProps<ResponseActiveServiceInstanceSummary, Failure | Error, GetActiveServiceInstanceSummaryQueryParams, void>,
  'path'
>

/**
 * Get active service instance summary
 */
export const useGetActiveServiceInstanceSummary = (props: UseGetActiveServiceInstanceSummaryProps) =>
  useGet<ResponseActiveServiceInstanceSummary, Failure | Error, GetActiveServiceInstanceSummaryQueryParams, void>(
    `/dashboard/getActiveServiceInstanceSummary`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get active service instance summary
 */
export const getActiveServiceInstanceSummaryPromise = (
  props: GetUsingFetchProps<
    ResponseActiveServiceInstanceSummary,
    Failure | Error,
    GetActiveServiceInstanceSummaryQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseActiveServiceInstanceSummary,
    Failure | Error,
    GetActiveServiceInstanceSummaryQueryParams,
    void
  >(getConfig('ng/api'), `/dashboard/getActiveServiceInstanceSummary`, props, signal)

export interface GetDeploymentsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  top?: number
}

export type GetDeploymentsProps = Omit<
  GetProps<ResponseDashboardExecutionStatusInfo, Failure | Error, GetDeploymentsQueryParams, void>,
  'path'
>

/**
 * Get deployments
 */
export const GetDeployments = (props: GetDeploymentsProps) => (
  <Get<ResponseDashboardExecutionStatusInfo, Failure | Error, GetDeploymentsQueryParams, void>
    path={`/dashboard/getDeployments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentsProps = Omit<
  UseGetProps<ResponseDashboardExecutionStatusInfo, Failure | Error, GetDeploymentsQueryParams, void>,
  'path'
>

/**
 * Get deployments
 */
export const useGetDeployments = (props: UseGetDeploymentsProps) =>
  useGet<ResponseDashboardExecutionStatusInfo, Failure | Error, GetDeploymentsQueryParams, void>(
    `/dashboard/getDeployments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get deployments
 */
export const getDeploymentsPromise = (
  props: GetUsingFetchProps<ResponseDashboardExecutionStatusInfo, Failure | Error, GetDeploymentsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardExecutionStatusInfo, Failure | Error, GetDeploymentsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getDeployments`,
    props,
    signal
  )

export interface GetDeploymentsByServiceIdQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  serviceId: string
  startTime: number
  endTime: number
}

export type GetDeploymentsByServiceIdProps = Omit<
  GetProps<ResponseDeploymentsInfo, Failure | Error, GetDeploymentsByServiceIdQueryParams, void>,
  'path'
>

/**
 * Get deployments by serviceId
 */
export const GetDeploymentsByServiceId = (props: GetDeploymentsByServiceIdProps) => (
  <Get<ResponseDeploymentsInfo, Failure | Error, GetDeploymentsByServiceIdQueryParams, void>
    path={`/dashboard/getDeploymentsByServiceId`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentsByServiceIdProps = Omit<
  UseGetProps<ResponseDeploymentsInfo, Failure | Error, GetDeploymentsByServiceIdQueryParams, void>,
  'path'
>

/**
 * Get deployments by serviceId
 */
export const useGetDeploymentsByServiceId = (props: UseGetDeploymentsByServiceIdProps) =>
  useGet<ResponseDeploymentsInfo, Failure | Error, GetDeploymentsByServiceIdQueryParams, void>(
    `/dashboard/getDeploymentsByServiceId`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get deployments by serviceId
 */
export const getDeploymentsByServiceIdPromise = (
  props: GetUsingFetchProps<ResponseDeploymentsInfo, Failure | Error, GetDeploymentsByServiceIdQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDeploymentsInfo, Failure | Error, GetDeploymentsByServiceIdQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getDeploymentsByServiceId`,
    props,
    signal
  )

export interface GetEnvBuildInstanceCountQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  serviceId: string
}

export type GetEnvBuildInstanceCountProps = Omit<
  GetProps<ResponseEnvBuildIdAndInstanceCountInfoList, Failure | Error, GetEnvBuildInstanceCountQueryParams, void>,
  'path'
>

/**
 * Get list of unique environment and build ids with instance count
 */
export const GetEnvBuildInstanceCount = (props: GetEnvBuildInstanceCountProps) => (
  <Get<ResponseEnvBuildIdAndInstanceCountInfoList, Failure | Error, GetEnvBuildInstanceCountQueryParams, void>
    path={`/dashboard/getEnvBuildInstanceCountByService`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvBuildInstanceCountProps = Omit<
  UseGetProps<ResponseEnvBuildIdAndInstanceCountInfoList, Failure | Error, GetEnvBuildInstanceCountQueryParams, void>,
  'path'
>

/**
 * Get list of unique environment and build ids with instance count
 */
export const useGetEnvBuildInstanceCount = (props: UseGetEnvBuildInstanceCountProps) =>
  useGet<ResponseEnvBuildIdAndInstanceCountInfoList, Failure | Error, GetEnvBuildInstanceCountQueryParams, void>(
    `/dashboard/getEnvBuildInstanceCountByService`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get list of unique environment and build ids with instance count
 */
export const getEnvBuildInstanceCountPromise = (
  props: GetUsingFetchProps<
    ResponseEnvBuildIdAndInstanceCountInfoList,
    Failure | Error,
    GetEnvBuildInstanceCountQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEnvBuildIdAndInstanceCountInfoList, Failure | Error, GetEnvBuildInstanceCountQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getEnvBuildInstanceCountByService`,
    props,
    signal
  )

export interface GetActiveServiceInstanceCountBreakdownQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  serviceId: string[]
}

export type GetActiveServiceInstanceCountBreakdownProps = Omit<
  GetProps<
    ResponseInstanceCountDetailsByEnvTypeAndServiceId,
    Failure | Error,
    GetActiveServiceInstanceCountBreakdownQueryParams,
    void
  >,
  'path'
>

/**
 * Get active service instance count breakdown by env type
 */
export const GetActiveServiceInstanceCountBreakdown = (props: GetActiveServiceInstanceCountBreakdownProps) => (
  <Get<
    ResponseInstanceCountDetailsByEnvTypeAndServiceId,
    Failure | Error,
    GetActiveServiceInstanceCountBreakdownQueryParams,
    void
  >
    path={`/dashboard/getInstanceCountDetailsByService`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveServiceInstanceCountBreakdownProps = Omit<
  UseGetProps<
    ResponseInstanceCountDetailsByEnvTypeAndServiceId,
    Failure | Error,
    GetActiveServiceInstanceCountBreakdownQueryParams,
    void
  >,
  'path'
>

/**
 * Get active service instance count breakdown by env type
 */
export const useGetActiveServiceInstanceCountBreakdown = (props: UseGetActiveServiceInstanceCountBreakdownProps) =>
  useGet<
    ResponseInstanceCountDetailsByEnvTypeAndServiceId,
    Failure | Error,
    GetActiveServiceInstanceCountBreakdownQueryParams,
    void
  >(`/dashboard/getInstanceCountDetailsByService`, { base: getConfig('ng/api'), ...props })

/**
 * Get active service instance count breakdown by env type
 */
export const getActiveServiceInstanceCountBreakdownPromise = (
  props: GetUsingFetchProps<
    ResponseInstanceCountDetailsByEnvTypeAndServiceId,
    Failure | Error,
    GetActiveServiceInstanceCountBreakdownQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInstanceCountDetailsByEnvTypeAndServiceId,
    Failure | Error,
    GetActiveServiceInstanceCountBreakdownQueryParams,
    void
  >(getConfig('ng/api'), `/dashboard/getInstanceCountDetailsByService`, props, signal)

export interface GetInstanceCountHistoryQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  serviceId: string
  startTime: number
  endTime: number
}

export type GetInstanceCountHistoryProps = Omit<
  GetProps<ResponseTimeValuePairListDTOEnvIdCountPair, Failure | Error, GetInstanceCountHistoryQueryParams, void>,
  'path'
>

/**
 * Get instance count history
 */
export const GetInstanceCountHistory = (props: GetInstanceCountHistoryProps) => (
  <Get<ResponseTimeValuePairListDTOEnvIdCountPair, Failure | Error, GetInstanceCountHistoryQueryParams, void>
    path={`/dashboard/getInstanceCountHistory`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInstanceCountHistoryProps = Omit<
  UseGetProps<ResponseTimeValuePairListDTOEnvIdCountPair, Failure | Error, GetInstanceCountHistoryQueryParams, void>,
  'path'
>

/**
 * Get instance count history
 */
export const useGetInstanceCountHistory = (props: UseGetInstanceCountHistoryProps) =>
  useGet<ResponseTimeValuePairListDTOEnvIdCountPair, Failure | Error, GetInstanceCountHistoryQueryParams, void>(
    `/dashboard/getInstanceCountHistory`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get instance count history
 */
export const getInstanceCountHistoryPromise = (
  props: GetUsingFetchProps<
    ResponseTimeValuePairListDTOEnvIdCountPair,
    Failure | Error,
    GetInstanceCountHistoryQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTimeValuePairListDTOEnvIdCountPair, Failure | Error, GetInstanceCountHistoryQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getInstanceCountHistory`,
    props,
    signal
  )

export interface GetInstanceGrowthTrendQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  serviceId: string
  startTime: number
  endTime: number
}

export type GetInstanceGrowthTrendProps = Omit<
  GetProps<ResponseTimeValuePairListDTOInteger, Failure | Error, GetInstanceGrowthTrendQueryParams, void>,
  'path'
>

/**
 * Get instance growth trend
 */
export const GetInstanceGrowthTrend = (props: GetInstanceGrowthTrendProps) => (
  <Get<ResponseTimeValuePairListDTOInteger, Failure | Error, GetInstanceGrowthTrendQueryParams, void>
    path={`/dashboard/getInstanceGrowthTrend`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInstanceGrowthTrendProps = Omit<
  UseGetProps<ResponseTimeValuePairListDTOInteger, Failure | Error, GetInstanceGrowthTrendQueryParams, void>,
  'path'
>

/**
 * Get instance growth trend
 */
export const useGetInstanceGrowthTrend = (props: UseGetInstanceGrowthTrendProps) =>
  useGet<ResponseTimeValuePairListDTOInteger, Failure | Error, GetInstanceGrowthTrendQueryParams, void>(
    `/dashboard/getInstanceGrowthTrend`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get instance growth trend
 */
export const getInstanceGrowthTrendPromise = (
  props: GetUsingFetchProps<
    ResponseTimeValuePairListDTOInteger,
    Failure | Error,
    GetInstanceGrowthTrendQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTimeValuePairListDTOInteger, Failure | Error, GetInstanceGrowthTrendQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getInstanceGrowthTrend`,
    props,
    signal
  )

export interface GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  serviceId: string
  envId: string
  buildIds: string[]
}

export type GetActiveInstancesByServiceIdEnvIdAndBuildIdsProps = Omit<
  GetProps<
    ResponseInstancesByBuildIdList,
    Failure | Error,
    GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams,
    void
  >,
  'path'
>

/**
 * Get list of buildId and instances
 */
export const GetActiveInstancesByServiceIdEnvIdAndBuildIds = (
  props: GetActiveInstancesByServiceIdEnvIdAndBuildIdsProps
) => (
  <Get<ResponseInstancesByBuildIdList, Failure | Error, GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams, void>
    path={`/dashboard/getInstancesByServiceEnvAndBuilds`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveInstancesByServiceIdEnvIdAndBuildIdsProps = Omit<
  UseGetProps<
    ResponseInstancesByBuildIdList,
    Failure | Error,
    GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams,
    void
  >,
  'path'
>

/**
 * Get list of buildId and instances
 */
export const useGetActiveInstancesByServiceIdEnvIdAndBuildIds = (
  props: UseGetActiveInstancesByServiceIdEnvIdAndBuildIdsProps
) =>
  useGet<
    ResponseInstancesByBuildIdList,
    Failure | Error,
    GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams,
    void
  >(`/dashboard/getInstancesByServiceEnvAndBuilds`, { base: getConfig('ng/api'), ...props })

/**
 * Get list of buildId and instances
 */
export const getActiveInstancesByServiceIdEnvIdAndBuildIdsPromise = (
  props: GetUsingFetchProps<
    ResponseInstancesByBuildIdList,
    Failure | Error,
    GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseInstancesByBuildIdList,
    Failure | Error,
    GetActiveInstancesByServiceIdEnvIdAndBuildIdsQueryParams,
    void
  >(getConfig('ng/api'), `/dashboard/getInstancesByServiceEnvAndBuilds`, props, signal)

export interface GetServiceHeaderInfoQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  serviceId: string
}

export type GetServiceHeaderInfoProps = Omit<
  GetProps<ResponseServiceHeaderInfo, Failure | Error, GetServiceHeaderInfoQueryParams, void>,
  'path'
>

/**
 * Get service header info
 */
export const GetServiceHeaderInfo = (props: GetServiceHeaderInfoProps) => (
  <Get<ResponseServiceHeaderInfo, Failure | Error, GetServiceHeaderInfoQueryParams, void>
    path={`/dashboard/getServiceHeaderInfo`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceHeaderInfoProps = Omit<
  UseGetProps<ResponseServiceHeaderInfo, Failure | Error, GetServiceHeaderInfoQueryParams, void>,
  'path'
>

/**
 * Get service header info
 */
export const useGetServiceHeaderInfo = (props: UseGetServiceHeaderInfoProps) =>
  useGet<ResponseServiceHeaderInfo, Failure | Error, GetServiceHeaderInfoQueryParams, void>(
    `/dashboard/getServiceHeaderInfo`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get service header info
 */
export const getServiceHeaderInfoPromise = (
  props: GetUsingFetchProps<ResponseServiceHeaderInfo, Failure | Error, GetServiceHeaderInfoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceHeaderInfo, Failure | Error, GetServiceHeaderInfoQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getServiceHeaderInfo`,
    props,
    signal
  )

export interface GetServicesGrowthTrendQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
  timeGroupByType: 'HOUR' | 'DAY' | 'WEEK'
}

export type GetServicesGrowthTrendProps = Omit<
  GetProps<ResponseTimeValuePairListDTOInteger, Failure | Error, GetServicesGrowthTrendQueryParams, void>,
  'path'
>

/**
 * Get service growth trend
 */
export const GetServicesGrowthTrend = (props: GetServicesGrowthTrendProps) => (
  <Get<ResponseTimeValuePairListDTOInteger, Failure | Error, GetServicesGrowthTrendQueryParams, void>
    path={`/dashboard/getServicesGrowthTrend`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServicesGrowthTrendProps = Omit<
  UseGetProps<ResponseTimeValuePairListDTOInteger, Failure | Error, GetServicesGrowthTrendQueryParams, void>,
  'path'
>

/**
 * Get service growth trend
 */
export const useGetServicesGrowthTrend = (props: UseGetServicesGrowthTrendProps) =>
  useGet<ResponseTimeValuePairListDTOInteger, Failure | Error, GetServicesGrowthTrendQueryParams, void>(
    `/dashboard/getServicesGrowthTrend`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get service growth trend
 */
export const getServicesGrowthTrendPromise = (
  props: GetUsingFetchProps<
    ResponseTimeValuePairListDTOInteger,
    Failure | Error,
    GetServicesGrowthTrendQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTimeValuePairListDTOInteger, Failure | Error, GetServicesGrowthTrendQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getServicesGrowthTrend`,
    props,
    signal
  )

export interface GetWorkloadsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
  environmentType?: 'PreProduction' | 'Production'
}

export type GetWorkloadsProps = Omit<
  GetProps<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>,
  'path'
>

/**
 * Get workloads
 */
export const GetWorkloads = (props: GetWorkloadsProps) => (
  <Get<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>
    path={`/dashboard/getWorkloads`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetWorkloadsProps = Omit<
  UseGetProps<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>,
  'path'
>

/**
 * Get workloads
 */
export const useGetWorkloads = (props: UseGetWorkloadsProps) =>
  useGet<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>(
    `/dashboard/getWorkloads`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get workloads
 */
export const getWorkloadsPromise = (
  props: GetUsingFetchProps<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseDashboardWorkloadDeployment, Failure | Error, GetWorkloadsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/getWorkloads`,
    props,
    signal
  )

export interface GetServiceDeploymentsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
  serviceId?: string
  bucketSizeInDays?: number
}

export type GetServiceDeploymentsProps = Omit<
  GetProps<ResponseServiceDeploymentInfoDTO, Failure | Error, GetServiceDeploymentsQueryParams, void>,
  'path'
>

/**
 * Get service deployment
 */
export const GetServiceDeployments = (props: GetServiceDeploymentsProps) => (
  <Get<ResponseServiceDeploymentInfoDTO, Failure | Error, GetServiceDeploymentsQueryParams, void>
    path={`/dashboard/serviceDeployments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDeploymentsProps = Omit<
  UseGetProps<ResponseServiceDeploymentInfoDTO, Failure | Error, GetServiceDeploymentsQueryParams, void>,
  'path'
>

/**
 * Get service deployment
 */
export const useGetServiceDeployments = (props: UseGetServiceDeploymentsProps) =>
  useGet<ResponseServiceDeploymentInfoDTO, Failure | Error, GetServiceDeploymentsQueryParams, void>(
    `/dashboard/serviceDeployments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get service deployment
 */
export const getServiceDeploymentsPromise = (
  props: GetUsingFetchProps<ResponseServiceDeploymentInfoDTO, Failure | Error, GetServiceDeploymentsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceDeploymentInfoDTO, Failure | Error, GetServiceDeploymentsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/serviceDeployments`,
    props,
    signal
  )

export interface GetServiceDeploymentsInfoQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
  serviceId?: string
  bucketSizeInDays?: number
}

export type GetServiceDeploymentsInfoProps = Omit<
  GetProps<ResponseServiceDeploymentListInfo, Failure | Error, GetServiceDeploymentsInfoQueryParams, void>,
  'path'
>

/**
 * Get service deployments info
 */
export const GetServiceDeploymentsInfo = (props: GetServiceDeploymentsInfoProps) => (
  <Get<ResponseServiceDeploymentListInfo, Failure | Error, GetServiceDeploymentsInfoQueryParams, void>
    path={`/dashboard/serviceDeploymentsInfo`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDeploymentsInfoProps = Omit<
  UseGetProps<ResponseServiceDeploymentListInfo, Failure | Error, GetServiceDeploymentsInfoQueryParams, void>,
  'path'
>

/**
 * Get service deployments info
 */
export const useGetServiceDeploymentsInfo = (props: UseGetServiceDeploymentsInfoProps) =>
  useGet<ResponseServiceDeploymentListInfo, Failure | Error, GetServiceDeploymentsInfoQueryParams, void>(
    `/dashboard/serviceDeploymentsInfo`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get service deployments info
 */
export const getServiceDeploymentsInfoPromise = (
  props: GetUsingFetchProps<
    ResponseServiceDeploymentListInfo,
    Failure | Error,
    GetServiceDeploymentsInfoQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceDeploymentListInfo, Failure | Error, GetServiceDeploymentsInfoQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/serviceDeploymentsInfo`,
    props,
    signal
  )

export interface GetServiceDetailsQueryParams {
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
  startTime: number
  endTime: number
}

export type GetServiceDetailsProps = Omit<
  GetProps<ResponseServiceDetailsInfoDTO, Failure | Error, GetServiceDetailsQueryParams, void>,
  'path'
>

/**
 * Get service details list
 */
export const GetServiceDetails = (props: GetServiceDetailsProps) => (
  <Get<ResponseServiceDetailsInfoDTO, Failure | Error, GetServiceDetailsQueryParams, void>
    path={`/dashboard/serviceDetails`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDetailsProps = Omit<
  UseGetProps<ResponseServiceDetailsInfoDTO, Failure | Error, GetServiceDetailsQueryParams, void>,
  'path'
>

/**
 * Get service details list
 */
export const useGetServiceDetails = (props: UseGetServiceDetailsProps) =>
  useGet<ResponseServiceDetailsInfoDTO, Failure | Error, GetServiceDetailsQueryParams, void>(
    `/dashboard/serviceDetails`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get service details list
 */
export const getServiceDetailsPromise = (
  props: GetUsingFetchProps<ResponseServiceDetailsInfoDTO, Failure | Error, GetServiceDetailsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceDetailsInfoDTO, Failure | Error, GetServiceDetailsQueryParams, void>(
    getConfig('ng/api'),
    `/dashboard/serviceDetails`,
    props,
    signal
  )

export interface ListDelegateProfilesNgQueryParams {
  offset?: string
  limit?: string
  fieldsIncluded?: string[]
  fieldsExcluded?: string[]
  accountId?: string
  orgId?: string
  projectId?: string
}

export type ListDelegateProfilesNgProps = Omit<
  GetProps<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>,
  'path'
>

/**
 * Lists the Delegate Configurations (profiles)
 */
export const ListDelegateProfilesNg = (props: ListDelegateProfilesNgProps) => (
  <Get<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>
    path={`/delegate-profiles/ng`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListDelegateProfilesNgProps = Omit<
  UseGetProps<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>,
  'path'
>

/**
 * Lists the Delegate Configurations (profiles)
 */
export const useListDelegateProfilesNg = (props: UseListDelegateProfilesNgProps) =>
  useGet<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>(
    `/delegate-profiles/ng`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Lists the Delegate Configurations (profiles)
 */
export const listDelegateProfilesNgPromise = (
  props: GetUsingFetchProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateProfilesNgQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<RestResponsePageResponseDelegateProfileDetailsNg, unknown, ListDelegateProfilesNgQueryParams, void>(
    getConfig('ng/api'),
    `/delegate-profiles/ng`,
    props,
    signal
  )

export interface AddDelegateProfileNgQueryParams {
  accountId?: string
  orgId?: string
  projectId?: string
}

export type AddDelegateProfileNgProps = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Adds a Delegate Configuration (profile)
 */
export const AddDelegateProfileNg = (props: AddDelegateProfileNgProps) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >
    verb="POST"
    path={`/delegate-profiles/ng`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddDelegateProfileNgProps = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Adds a Delegate Configuration (profile)
 */
export const useAddDelegateProfileNg = (props: UseAddDelegateProfileNgProps) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >('POST', `/delegate-profiles/ng`, { base: getConfig('ng/api'), ...props })

/**
 * Adds a Delegate Configuration (profile)
 */
export const addDelegateProfileNgPromise = (
  props: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    AddDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    void
  >('POST', getConfig('ng/api'), `/delegate-profiles/ng`, props, signal)

export interface DeleteDelegateProfileNgQueryParams {
  accountId?: string
  orgId?: string
  projectId?: string
}

export type DeleteDelegateProfileNgProps = Omit<
  MutateProps<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes a Delegate Configuration (profile)
 */
export const DeleteDelegateProfileNg = (props: DeleteDelegateProfileNgProps) => (
  <Mutate<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>
    verb="DELETE"
    path={`/delegate-profiles/ng`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteDelegateProfileNgProps = Omit<
  UseMutateProps<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes a Delegate Configuration (profile)
 */
export const useDeleteDelegateProfileNg = (props: UseDeleteDelegateProfileNgProps) =>
  useMutate<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>(
    'DELETE',
    `/delegate-profiles/ng`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Deletes a Delegate Configuration (profile)
 */
export const deleteDelegateProfileNgPromise = (
  props: MutateUsingFetchProps<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseVoid, unknown, DeleteDelegateProfileNgQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/delegate-profiles/ng`,
    props,
    signal
  )

export interface GetDelegateProfileNgQueryParams {
  accountId?: string
  orgId?: string
  projectId?: string
}

export interface GetDelegateProfileNgPathParams {
  delegateProfileId: string
}

export type GetDelegateProfileNgProps = Omit<
  GetProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  >,
  'path'
> &
  GetDelegateProfileNgPathParams

/**
 * Gets Delegate Configuration (profile)
 */
export const GetDelegateProfileNg = ({ delegateProfileId, ...props }: GetDelegateProfileNgProps) => (
  <Get<RestResponseDelegateProfileDetailsNg, unknown, GetDelegateProfileNgQueryParams, GetDelegateProfileNgPathParams>
    path={`/delegate-profiles/ng/${delegateProfileId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDelegateProfileNgProps = Omit<
  UseGetProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  >,
  'path'
> &
  GetDelegateProfileNgPathParams

/**
 * Gets Delegate Configuration (profile)
 */
export const useGetDelegateProfileNg = ({ delegateProfileId, ...props }: UseGetDelegateProfileNgProps) =>
  useGet<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  >((paramsInPath: GetDelegateProfileNgPathParams) => `/delegate-profiles/ng/${paramsInPath.delegateProfileId}`, {
    base: getConfig('ng/api'),
    pathParams: { delegateProfileId },
    ...props
  })

/**
 * Gets Delegate Configuration (profile)
 */
export const getDelegateProfileNgPromise = (
  {
    delegateProfileId,
    ...props
  }: GetUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  > & { delegateProfileId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateProfileNgQueryParams,
    GetDelegateProfileNgPathParams
  >(getConfig('ng/api'), `/delegate-profiles/ng/${delegateProfileId}`, props, signal)

export interface UpdateDelegateProfileNgQueryParams {
  accountId?: string
  orgId?: string
  projectId?: string
}

export interface UpdateDelegateProfileNgPathParams {
  delegateProfileId: string
}

export type UpdateDelegateProfileNgProps = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateDelegateProfileNgPathParams

/**
 * Updates a Delegate profile
 */
export const UpdateDelegateProfileNg = ({ delegateProfileId, ...props }: UpdateDelegateProfileNgProps) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >
    verb="PUT"
    path={`/delegate-profiles/ng/${delegateProfileId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateDelegateProfileNgProps = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateDelegateProfileNgPathParams

/**
 * Updates a Delegate profile
 */
export const useUpdateDelegateProfileNg = ({ delegateProfileId, ...props }: UseUpdateDelegateProfileNgProps) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >(
    'PUT',
    (paramsInPath: UpdateDelegateProfileNgPathParams) => `/delegate-profiles/ng/${paramsInPath.delegateProfileId}`,
    { base: getConfig('ng/api'), pathParams: { delegateProfileId }, ...props }
  )

/**
 * Updates a Delegate profile
 */
export const updateDelegateProfileNgPromise = (
  {
    delegateProfileId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  > & { delegateProfileId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateProfileNgQueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateProfileNgPathParams
  >('PUT', getConfig('ng/api'), `/delegate-profiles/ng/${delegateProfileId}`, props, signal)

export interface UpdateScopingRulesNgQueryParams {
  accountId?: string
  orgId?: string
  projectId?: string
}

export interface UpdateScopingRulesNgPathParams {
  delegateProfileId: string
}

export type UpdateScopingRulesNgProps = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateScopingRulesNgPathParams

/**
 * Updates the scoping rules inside the Delegate profile
 */
export const UpdateScopingRulesNg = ({ delegateProfileId, ...props }: UpdateScopingRulesNgProps) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgPathParams
  >
    verb="PUT"
    path={`/delegate-profiles/ng/${delegateProfileId}/scoping-rules`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateScopingRulesNgProps = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateScopingRulesNgPathParams

/**
 * Updates the scoping rules inside the Delegate profile
 */
export const useUpdateScopingRulesNg = ({ delegateProfileId, ...props }: UseUpdateScopingRulesNgProps) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgPathParams
  >(
    'PUT',
    (paramsInPath: UpdateScopingRulesNgPathParams) =>
      `/delegate-profiles/ng/${paramsInPath.delegateProfileId}/scoping-rules`,
    { base: getConfig('ng/api'), pathParams: { delegateProfileId }, ...props }
  )

/**
 * Updates the scoping rules inside the Delegate profile
 */
export const updateScopingRulesNgPromise = (
  {
    delegateProfileId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgPathParams
  > & { delegateProfileId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgQueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgPathParams
  >('PUT', getConfig('ng/api'), `/delegate-profiles/ng/${delegateProfileId}/scoping-rules`, props, signal)

export interface UpdateSelectorsNgQueryParams {
  accountId?: string
  orgId?: string
  projectId?: string
}

export interface UpdateSelectorsNgPathParams {
  delegateProfileId: string
}

export type UpdateSelectorsNgProps = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateSelectorsNgPathParams

/**
 * Updates the selectors inside the Delegate profile
 */
export const UpdateSelectorsNg = ({ delegateProfileId, ...props }: UpdateSelectorsNgProps) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >
    verb="PUT"
    path={`/delegate-profiles/ng/${delegateProfileId}/selectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSelectorsNgProps = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >,
  'path' | 'verb'
> &
  UpdateSelectorsNgPathParams

/**
 * Updates the selectors inside the Delegate profile
 */
export const useUpdateSelectorsNg = ({ delegateProfileId, ...props }: UseUpdateSelectorsNgProps) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >(
    'PUT',
    (paramsInPath: UpdateSelectorsNgPathParams) => `/delegate-profiles/ng/${paramsInPath.delegateProfileId}/selectors`,
    { base: getConfig('ng/api'), pathParams: { delegateProfileId }, ...props }
  )

/**
 * Updates the selectors inside the Delegate profile
 */
export const updateSelectorsNgPromise = (
  {
    delegateProfileId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  > & { delegateProfileId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgQueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgPathParams
  >('PUT', getConfig('ng/api'), `/delegate-profiles/ng/${delegateProfileId}/selectors`, props, signal)

export interface GetFeatureRestrictionDetailQueryParams {
  accountIdentifier: string
}

export type GetFeatureRestrictionDetailProps = Omit<
  MutateProps<
    ResponseFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailQueryParams,
    FeatureRestrictionDetailRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Fetch Feature Restriction Detail
 */
export const GetFeatureRestrictionDetail = (props: GetFeatureRestrictionDetailProps) => (
  <Mutate<
    ResponseFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailQueryParams,
    FeatureRestrictionDetailRequestDTO,
    void
  >
    verb="POST"
    path={`/enforcement`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFeatureRestrictionDetailProps = Omit<
  UseMutateProps<
    ResponseFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailQueryParams,
    FeatureRestrictionDetailRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Fetch Feature Restriction Detail
 */
export const useGetFeatureRestrictionDetail = (props: UseGetFeatureRestrictionDetailProps) =>
  useMutate<
    ResponseFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailQueryParams,
    FeatureRestrictionDetailRequestDTO,
    void
  >('POST', `/enforcement`, { base: getConfig('ng/api'), ...props })

/**
 * Fetch Feature Restriction Detail
 */
export const getFeatureRestrictionDetailPromise = (
  props: MutateUsingFetchProps<
    ResponseFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailQueryParams,
    FeatureRestrictionDetailRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailQueryParams,
    FeatureRestrictionDetailRequestDTO,
    void
  >('POST', getConfig('ng/api'), `/enforcement`, props, signal)

export interface GetFeatureRestrictionDetailsQueryParams {
  accountIdentifier: string
}

export type GetFeatureRestrictionDetailsProps = Omit<
  MutateProps<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailsQueryParams,
    FeatureRestrictionDetailListRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Fetch List of Feature Restriction Detail
 */
export const GetFeatureRestrictionDetails = (props: GetFeatureRestrictionDetailsProps) => (
  <Mutate<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailsQueryParams,
    FeatureRestrictionDetailListRequestDTO,
    void
  >
    verb="POST"
    path={`/enforcement/details`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFeatureRestrictionDetailsProps = Omit<
  UseMutateProps<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailsQueryParams,
    FeatureRestrictionDetailListRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Fetch List of Feature Restriction Detail
 */
export const useGetFeatureRestrictionDetails = (props: UseGetFeatureRestrictionDetailsProps) =>
  useMutate<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailsQueryParams,
    FeatureRestrictionDetailListRequestDTO,
    void
  >('POST', `/enforcement/details`, { base: getConfig('ng/api'), ...props })

/**
 * Fetch List of Feature Restriction Detail
 */
export const getFeatureRestrictionDetailsPromise = (
  props: MutateUsingFetchProps<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailsQueryParams,
    FeatureRestrictionDetailListRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetFeatureRestrictionDetailsQueryParams,
    FeatureRestrictionDetailListRequestDTO,
    void
  >('POST', getConfig('ng/api'), `/enforcement/details`, props, signal)

export interface GetEnabledFeatureRestrictionDetailByAccountIdQueryParams {
  accountIdentifier: string
}

export type GetEnabledFeatureRestrictionDetailByAccountIdProps = Omit<
  GetProps<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetEnabledFeatureRestrictionDetailByAccountIdQueryParams,
    void
  >,
  'path'
>

/**
 * Fetch the List of enabled Feature Restriction Detail for this Account
 */
export const GetEnabledFeatureRestrictionDetailByAccountId = (
  props: GetEnabledFeatureRestrictionDetailByAccountIdProps
) => (
  <Get<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetEnabledFeatureRestrictionDetailByAccountIdQueryParams,
    void
  >
    path={`/enforcement/enabled`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnabledFeatureRestrictionDetailByAccountIdProps = Omit<
  UseGetProps<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetEnabledFeatureRestrictionDetailByAccountIdQueryParams,
    void
  >,
  'path'
>

/**
 * Fetch the List of enabled Feature Restriction Detail for this Account
 */
export const useGetEnabledFeatureRestrictionDetailByAccountId = (
  props: UseGetEnabledFeatureRestrictionDetailByAccountIdProps
) =>
  useGet<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetEnabledFeatureRestrictionDetailByAccountIdQueryParams,
    void
  >(`/enforcement/enabled`, { base: getConfig('ng/api'), ...props })

/**
 * Fetch the List of enabled Feature Restriction Detail for this Account
 */
export const getEnabledFeatureRestrictionDetailByAccountIdPromise = (
  props: GetUsingFetchProps<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetEnabledFeatureRestrictionDetailByAccountIdQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListFeatureRestrictionDetailsDTO,
    Failure | Error,
    GetEnabledFeatureRestrictionDetailByAccountIdQueryParams,
    void
  >(getConfig('ng/api'), `/enforcement/enabled`, props, signal)

export type GetAllFeatureRestrictionMetadataProps = Omit<
  GetProps<ResponseListFeatureRestrictionMetadataDTO, Failure | Error, void, void>,
  'path'
>

/**
 * Fetch All Feature Restriction Metadata
 */
export const GetAllFeatureRestrictionMetadata = (props: GetAllFeatureRestrictionMetadataProps) => (
  <Get<ResponseListFeatureRestrictionMetadataDTO, Failure | Error, void, void>
    path={`/enforcement/metadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAllFeatureRestrictionMetadataProps = Omit<
  UseGetProps<ResponseListFeatureRestrictionMetadataDTO, Failure | Error, void, void>,
  'path'
>

/**
 * Fetch All Feature Restriction Metadata
 */
export const useGetAllFeatureRestrictionMetadata = (props: UseGetAllFeatureRestrictionMetadataProps) =>
  useGet<ResponseListFeatureRestrictionMetadataDTO, Failure | Error, void, void>(`/enforcement/metadata`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Fetch All Feature Restriction Metadata
 */
export const getAllFeatureRestrictionMetadataPromise = (
  props: GetUsingFetchProps<ResponseListFeatureRestrictionMetadataDTO, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListFeatureRestrictionMetadataDTO, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/enforcement/metadata`,
    props,
    signal
  )

export interface FetchFeatureRestrictionMetadataQueryParams {
  accountIdentifier: string
}

export interface FetchFeatureRestrictionMetadataPathParams {
  featureRestrictionName:
    | 'TEST1'
    | 'TEST2'
    | 'TEST3'
    | 'TEST4'
    | 'TEST5'
    | 'TEST6'
    | 'TEST7'
    | 'PERSPECTIVES'
    | 'CCM_K8S_CLUSTERS'
    | 'CCM_AUTOSTOPPING_RULES'
    | 'MULTIPLE_ORGANIZATIONS'
    | 'MULTIPLE_PROJECTS'
    | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
    | 'INTEGRATED_APPROVALS_WITH_JIRA'
    | 'SECRET_MANAGERS'
    | 'DEPLOYMENTS'
    | 'INITIAL_DEPLOYMENTS'
    | 'DEPLOYMENTS_PER_MONTH'
    | 'SERVICES'
    | 'BUILDS'
    | 'SAML_SUPPORT'
    | 'OAUTH_SUPPORT'
    | 'LDAP_SUPPORT'
    | 'TWO_FACTOR_AUTH_SUPPORT'
    | 'CUSTOM_ROLES'
    | 'CUSTOM_RESOURCE_GROUPS'
    | 'MAX_TOTAL_BUILDS'
    | 'MAX_BUILDS_PER_MONTH'
    | 'ACTIVE_COMMITTERS'
    | 'TEST_INTELLIGENCE'
    | 'TEMPLATE_SERVICE'
    | 'K8S_BG_SWAP_SERVICES'
    | 'K8S_BLUE_GREEN_DEPLOY'
    | 'K8S_APPLY'
    | 'K8S_DELETE'
    | 'K8S_CANARY_DELETE'
    | 'K8S_ROLLING_DEPLOY'
    | 'K8S_CANARY_DEPLOY'
    | 'K8S_SCALE'
    | 'K8S_ROLLING_ROLLBACK'
    | 'TERRAFORM_APPLY'
    | 'TERRAFORM_PLAN'
    | 'TERRAFORM_DESTROY'
    | 'TERRAFORM_ROLLBACK'
    | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
}

export type FetchFeatureRestrictionMetadataProps = Omit<
  GetProps<
    ResponseFeatureRestrictionMetadataDTO,
    Failure | Error,
    FetchFeatureRestrictionMetadataQueryParams,
    FetchFeatureRestrictionMetadataPathParams
  >,
  'path'
> &
  FetchFeatureRestrictionMetadataPathParams

/**
 * Fetch Feature Restriction Metadata
 */
export const FetchFeatureRestrictionMetadata = ({
  featureRestrictionName,
  ...props
}: FetchFeatureRestrictionMetadataProps) => (
  <Get<
    ResponseFeatureRestrictionMetadataDTO,
    Failure | Error,
    FetchFeatureRestrictionMetadataQueryParams,
    FetchFeatureRestrictionMetadataPathParams
  >
    path={`/enforcement/${featureRestrictionName}/metadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseFetchFeatureRestrictionMetadataProps = Omit<
  UseGetProps<
    ResponseFeatureRestrictionMetadataDTO,
    Failure | Error,
    FetchFeatureRestrictionMetadataQueryParams,
    FetchFeatureRestrictionMetadataPathParams
  >,
  'path'
> &
  FetchFeatureRestrictionMetadataPathParams

/**
 * Fetch Feature Restriction Metadata
 */
export const useFetchFeatureRestrictionMetadata = ({
  featureRestrictionName,
  ...props
}: UseFetchFeatureRestrictionMetadataProps) =>
  useGet<
    ResponseFeatureRestrictionMetadataDTO,
    Failure | Error,
    FetchFeatureRestrictionMetadataQueryParams,
    FetchFeatureRestrictionMetadataPathParams
  >(
    (paramsInPath: FetchFeatureRestrictionMetadataPathParams) =>
      `/enforcement/${paramsInPath.featureRestrictionName}/metadata`,
    { base: getConfig('ng/api'), pathParams: { featureRestrictionName }, ...props }
  )

/**
 * Fetch Feature Restriction Metadata
 */
export const fetchFeatureRestrictionMetadataPromise = (
  {
    featureRestrictionName,
    ...props
  }: GetUsingFetchProps<
    ResponseFeatureRestrictionMetadataDTO,
    Failure | Error,
    FetchFeatureRestrictionMetadataQueryParams,
    FetchFeatureRestrictionMetadataPathParams
  > & {
    featureRestrictionName:
      | 'TEST1'
      | 'TEST2'
      | 'TEST3'
      | 'TEST4'
      | 'TEST5'
      | 'TEST6'
      | 'TEST7'
      | 'PERSPECTIVES'
      | 'CCM_K8S_CLUSTERS'
      | 'CCM_AUTOSTOPPING_RULES'
      | 'MULTIPLE_ORGANIZATIONS'
      | 'MULTIPLE_PROJECTS'
      | 'INTEGRATED_APPROVALS_WITH_HARNESS_UI'
      | 'INTEGRATED_APPROVALS_WITH_JIRA'
      | 'SECRET_MANAGERS'
      | 'DEPLOYMENTS'
      | 'INITIAL_DEPLOYMENTS'
      | 'DEPLOYMENTS_PER_MONTH'
      | 'SERVICES'
      | 'BUILDS'
      | 'SAML_SUPPORT'
      | 'OAUTH_SUPPORT'
      | 'LDAP_SUPPORT'
      | 'TWO_FACTOR_AUTH_SUPPORT'
      | 'CUSTOM_ROLES'
      | 'CUSTOM_RESOURCE_GROUPS'
      | 'MAX_TOTAL_BUILDS'
      | 'MAX_BUILDS_PER_MONTH'
      | 'ACTIVE_COMMITTERS'
      | 'TEST_INTELLIGENCE'
      | 'TEMPLATE_SERVICE'
      | 'K8S_BG_SWAP_SERVICES'
      | 'K8S_BLUE_GREEN_DEPLOY'
      | 'K8S_APPLY'
      | 'K8S_DELETE'
      | 'K8S_CANARY_DELETE'
      | 'K8S_ROLLING_DEPLOY'
      | 'K8S_CANARY_DEPLOY'
      | 'K8S_SCALE'
      | 'K8S_ROLLING_ROLLBACK'
      | 'TERRAFORM_APPLY'
      | 'TERRAFORM_PLAN'
      | 'TERRAFORM_DESTROY'
      | 'TERRAFORM_ROLLBACK'
      | 'INTEGRATED_APPROVALS_WITH_SERVICE_NOW'
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseFeatureRestrictionMetadataDTO,
    Failure | Error,
    FetchFeatureRestrictionMetadataQueryParams,
    FetchFeatureRestrictionMetadataPathParams
  >(getConfig('ng/api'), `/enforcement/${featureRestrictionName}/metadata`, props, signal)

export interface ListReferredByEntitiesQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
  referredEntityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  searchTerm?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type ListReferredByEntitiesProps = Omit<
  GetProps<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resource
 */
export const ListReferredByEntities = (props: ListReferredByEntitiesProps) => (
  <Get<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>
    path={`/entitySetupUsage`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListReferredByEntitiesProps = Omit<
  UseGetProps<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  'path'
>

/**
 * Get Entities referring this resource
 */
export const useListReferredByEntities = (props: UseListReferredByEntitiesProps) =>
  useGet<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>(`/entitySetupUsage`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Entities referring this resource
 */
export const listReferredByEntitiesPromise = (
  props: GetUsingFetchProps<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEntitySetupUsageDTO, unknown, ListReferredByEntitiesQueryParams, void>(
    getConfig('ng/api'),
    `/entitySetupUsage`,
    props,
    signal
  )

export interface GetEnvironmentListForProjectQueryParams {
  page?: number
  size?: number
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  envIdentifiers?: string[]
  sort?: string[]
}

export type GetEnvironmentListForProjectProps = Omit<
  GetProps<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets environment list for a project
 */
export const GetEnvironmentListForProject = (props: GetEnvironmentListForProjectProps) => (
  <Get<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>
    path={`/environments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentListForProjectProps = Omit<
  UseGetProps<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets environment list for a project
 */
export const useGetEnvironmentListForProject = (props: UseGetEnvironmentListForProjectProps) =>
  useGet<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>(
    `/environments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets environment list for a project
 */
export const getEnvironmentListForProjectPromise = (
  props: GetUsingFetchProps<
    ResponsePageEnvironmentResponseDTO,
    Failure | Error,
    GetEnvironmentListForProjectQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEnvironmentResponseDTO, Failure | Error, GetEnvironmentListForProjectQueryParams, void>(
    getConfig('ng/api'),
    `/environments`,
    props,
    signal
  )

export interface CreateEnvironmentQueryParams {
  accountId?: string
}

export type CreateEnvironmentProps = Omit<
  MutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const CreateEnvironment = (props: CreateEnvironmentProps) => (
  <Mutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/environments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateEnvironmentProps = Omit<
  UseMutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const useCreateEnvironment = (props: UseCreateEnvironmentProps) =>
  useMutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', `/environments`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Environment
 */
export const createEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    CreateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/environments`, props, signal)

export interface UpdateEnvironmentQueryParams {
  accountId?: string
}

export type UpdateEnvironmentProps = Omit<
  MutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const UpdateEnvironment = (props: UpdateEnvironmentProps) => (
  <Mutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/environments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateEnvironmentProps = Omit<
  UseMutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const useUpdateEnvironment = (props: UseUpdateEnvironmentProps) =>
  useMutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environments`, { base: getConfig('ng/api'), ...props })

/**
 * Update an environment by identifier
 */
export const updateEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpdateEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environments`, props, signal)

export interface UpsertEnvironmentQueryParams {
  accountId?: string
}

export type UpsertEnvironmentProps = Omit<
  MutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const UpsertEnvironment = (props: UpsertEnvironmentProps) => (
  <Mutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/environments/upsert`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertEnvironmentProps = Omit<
  UseMutateProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const useUpsertEnvironment = (props: UseUpsertEnvironmentProps) =>
  useMutate<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environments/upsert`, { base: getConfig('ng/api'), ...props })

/**
 * Upsert an environment by identifier
 */
export const upsertEnvironmentPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    UpsertEnvironmentQueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environments/upsert`, props, signal)

export interface DeleteEnvironmentQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteEnvironmentProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const DeleteEnvironment = (props: DeleteEnvironmentProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>
    verb="DELETE"
    path={`/environments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteEnvironmentProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const useDeleteEnvironment = (props: UseDeleteEnvironmentProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>('DELETE', `/environments`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete en environment by identifier
 */
export const deleteEnvironmentPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteEnvironmentQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/environments`,
    props,
    signal
  )

export interface GetEnvironmentQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetEnvironmentPathParams {
  environmentIdentifier: string
}

export type GetEnvironmentProps = Omit<
  GetProps<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>,
  'path'
> &
  GetEnvironmentPathParams

/**
 * Gets a Environment by identifier
 */
export const GetEnvironment = ({ environmentIdentifier, ...props }: GetEnvironmentProps) => (
  <Get<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>
    path={`/environments/${environmentIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentProps = Omit<
  UseGetProps<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>,
  'path'
> &
  GetEnvironmentPathParams

/**
 * Gets a Environment by identifier
 */
export const useGetEnvironment = ({ environmentIdentifier, ...props }: UseGetEnvironmentProps) =>
  useGet<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>(
    (paramsInPath: GetEnvironmentPathParams) => `/environments/${paramsInPath.environmentIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { environmentIdentifier }, ...props }
  )

/**
 * Gets a Environment by identifier
 */
export const getEnvironmentPromise = (
  {
    environmentIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseEnvironmentResponseDTO,
    Failure | Error,
    GetEnvironmentQueryParams,
    GetEnvironmentPathParams
  > & { environmentIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEnvironmentResponseDTO, Failure | Error, GetEnvironmentQueryParams, GetEnvironmentPathParams>(
    getConfig('ng/api'),
    `/environments/${environmentIdentifier}`,
    props,
    signal
  )

export interface GetEnvironmentListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  envIdentifiers?: string[]
  sort?: string[]
}

export type GetEnvironmentListProps = Omit<
  GetProps<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>,
  'path'
>

/**
 * Gets environment list
 */
export const GetEnvironmentList = (props: GetEnvironmentListProps) => (
  <Get<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>
    path={`/environmentsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentListProps = Omit<
  UseGetProps<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>,
  'path'
>

/**
 * Gets environment list
 */
export const useGetEnvironmentList = (props: UseGetEnvironmentListProps) =>
  useGet<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>(`/environmentsV2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets environment list
 */
export const getEnvironmentListPromise = (
  props: GetUsingFetchProps<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageEnvironmentResponse, Failure | Error, GetEnvironmentListQueryParams, void>(
    getConfig('ng/api'),
    `/environmentsV2`,
    props,
    signal
  )

export interface CreateEnvironmentV2QueryParams {
  accountIdentifier: string
}

export type CreateEnvironmentV2Props = Omit<
  MutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const CreateEnvironmentV2 = (props: CreateEnvironmentV2Props) => (
  <Mutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/environmentsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateEnvironmentV2Props = Omit<
  UseMutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Environment
 */
export const useCreateEnvironmentV2 = (props: UseCreateEnvironmentV2Props) =>
  useMutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', `/environmentsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Environment
 */
export const createEnvironmentV2Promise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponse,
    Failure | Error,
    CreateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/environmentsV2`, props, signal)

export interface UpdateEnvironmentV2QueryParams {
  accountIdentifier: string
}

export type UpdateEnvironmentV2Props = Omit<
  MutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const UpdateEnvironmentV2 = (props: UpdateEnvironmentV2Props) => (
  <Mutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/environmentsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateEnvironmentV2Props = Omit<
  UseMutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update an environment by identifier
 */
export const useUpdateEnvironmentV2 = (props: UseUpdateEnvironmentV2Props) =>
  useMutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environmentsV2`, { base: getConfig('ng/api'), ...props })

/**
 * Update an environment by identifier
 */
export const updateEnvironmentV2Promise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpdateEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environmentsV2`, props, signal)

export interface GetEnvironmentAccessListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  envIdentifiers?: string[]
  sort?: string[]
}

export type GetEnvironmentAccessListProps = Omit<
  GetProps<ResponseListEnvironmentResponse, Failure | Error, GetEnvironmentAccessListQueryParams, void>,
  'path'
>

/**
 * Gets environment access list
 */
export const GetEnvironmentAccessList = (props: GetEnvironmentAccessListProps) => (
  <Get<ResponseListEnvironmentResponse, Failure | Error, GetEnvironmentAccessListQueryParams, void>
    path={`/environmentsV2/list/access`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentAccessListProps = Omit<
  UseGetProps<ResponseListEnvironmentResponse, Failure | Error, GetEnvironmentAccessListQueryParams, void>,
  'path'
>

/**
 * Gets environment access list
 */
export const useGetEnvironmentAccessList = (props: UseGetEnvironmentAccessListProps) =>
  useGet<ResponseListEnvironmentResponse, Failure | Error, GetEnvironmentAccessListQueryParams, void>(
    `/environmentsV2/list/access`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets environment access list
 */
export const getEnvironmentAccessListPromise = (
  props: GetUsingFetchProps<
    ResponseListEnvironmentResponse,
    Failure | Error,
    GetEnvironmentAccessListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListEnvironmentResponse, Failure | Error, GetEnvironmentAccessListQueryParams, void>(
    getConfig('ng/api'),
    `/environmentsV2/list/access`,
    props,
    signal
  )

export interface UpsertEnvironmentV2QueryParams {
  accountIdentifier: string
}

export type UpsertEnvironmentV2Props = Omit<
  MutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const UpsertEnvironmentV2 = (props: UpsertEnvironmentV2Props) => (
  <Mutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/environmentsV2/upsert`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertEnvironmentV2Props = Omit<
  UseMutateProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert an environment by identifier
 */
export const useUpsertEnvironmentV2 = (props: UseUpsertEnvironmentV2Props) =>
  useMutate<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', `/environmentsV2/upsert`, { base: getConfig('ng/api'), ...props })

/**
 * Upsert an environment by identifier
 */
export const upsertEnvironmentV2Promise = (
  props: MutateUsingFetchProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvironmentResponse,
    Failure | Error,
    UpsertEnvironmentV2QueryParams,
    EnvironmentRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/environmentsV2/upsert`, props, signal)

export interface DeleteEnvironmentV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteEnvironmentV2Props = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const DeleteEnvironmentV2 = (props: DeleteEnvironmentV2Props) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>
    verb="DELETE"
    path={`/environmentsV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteEnvironmentV2Props = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete en environment by identifier
 */
export const useDeleteEnvironmentV2 = (props: UseDeleteEnvironmentV2Props) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>(
    'DELETE',
    `/environmentsV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete en environment by identifier
 */
export const deleteEnvironmentV2Promise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteEnvironmentV2QueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/environmentsV2`,
    props,
    signal
  )

export interface GetEnvironmentV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetEnvironmentV2PathParams {
  environmentIdentifier: string
}

export type GetEnvironmentV2Props = Omit<
  GetProps<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>,
  'path'
> &
  GetEnvironmentV2PathParams

/**
 * Gets a Environment by identifier
 */
export const GetEnvironmentV2 = ({ environmentIdentifier, ...props }: GetEnvironmentV2Props) => (
  <Get<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>
    path={`/environmentsV2/${environmentIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvironmentV2Props = Omit<
  UseGetProps<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>,
  'path'
> &
  GetEnvironmentV2PathParams

/**
 * Gets a Environment by identifier
 */
export const useGetEnvironmentV2 = ({ environmentIdentifier, ...props }: UseGetEnvironmentV2Props) =>
  useGet<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>(
    (paramsInPath: GetEnvironmentV2PathParams) => `/environmentsV2/${paramsInPath.environmentIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { environmentIdentifier }, ...props }
  )

/**
 * Gets a Environment by identifier
 */
export const getEnvironmentV2Promise = (
  {
    environmentIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseEnvironmentResponse,
    Failure | Error,
    GetEnvironmentV2QueryParams,
    GetEnvironmentV2PathParams
  > & { environmentIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseEnvironmentResponse, Failure | Error, GetEnvironmentV2QueryParams, GetEnvironmentV2PathParams>(
    getConfig('ng/api'),
    `/environmentsV2/${environmentIdentifier}`,
    props,
    signal
  )

export type DummyApiForSwaggerSchemaCheckProps = Omit<
  GetProps<ResponsePipelineConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking pms schema
 */
export const DummyApiForSwaggerSchemaCheck = (props: DummyApiForSwaggerSchemaCheckProps) => (
  <Get<ResponsePipelineConfig, Failure | Error, void, void>
    path={`/executions/dummyApiForSwaggerSchemaCheck`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDummyApiForSwaggerSchemaCheckProps = Omit<
  UseGetProps<ResponsePipelineConfig, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api for checking pms schema
 */
export const useDummyApiForSwaggerSchemaCheck = (props: UseDummyApiForSwaggerSchemaCheckProps) =>
  useGet<ResponsePipelineConfig, Failure | Error, void, void>(`/executions/dummyApiForSwaggerSchemaCheck`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api for checking pms schema
 */
export const dummyApiForSwaggerSchemaCheckPromise = (
  props: GetUsingFetchProps<ResponsePipelineConfig, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePipelineConfig, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/dummyApiForSwaggerSchemaCheck`,
    props,
    signal
  )

export type GetDummyCDPipelineModuleInfoProps = Omit<
  GetProps<ResponseCDPipelineModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const GetDummyCDPipelineModuleInfo = (props: GetDummyCDPipelineModuleInfoProps) => (
  <Get<ResponseCDPipelineModuleInfo, Failure | Error, void, void>
    path={`/executions/dummyCDPipelineModuleInfo`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDummyCDPipelineModuleInfoProps = Omit<
  UseGetProps<ResponseCDPipelineModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const useGetDummyCDPipelineModuleInfo = (props: UseGetDummyCDPipelineModuleInfoProps) =>
  useGet<ResponseCDPipelineModuleInfo, Failure | Error, void, void>(`/executions/dummyCDPipelineModuleInfo`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api
 */
export const getDummyCDPipelineModuleInfoPromise = (
  props: GetUsingFetchProps<ResponseCDPipelineModuleInfo, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCDPipelineModuleInfo, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/dummyCDPipelineModuleInfo`,
    props,
    signal
  )

export type GetDummyCDStageModuleInfoProps = Omit<
  GetProps<ResponseCDStageModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const GetDummyCDStageModuleInfo = (props: GetDummyCDStageModuleInfoProps) => (
  <Get<ResponseCDStageModuleInfo, Failure | Error, void, void>
    path={`/executions/dummyCDStageModuleInfo`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDummyCDStageModuleInfoProps = Omit<
  UseGetProps<ResponseCDStageModuleInfo, Failure | Error, void, void>,
  'path'
>

/**
 * dummy api
 */
export const useGetDummyCDStageModuleInfo = (props: UseGetDummyCDStageModuleInfoProps) =>
  useGet<ResponseCDStageModuleInfo, Failure | Error, void, void>(`/executions/dummyCDStageModuleInfo`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * dummy api
 */
export const getDummyCDStageModuleInfoPromise = (
  props: GetUsingFetchProps<ResponseCDStageModuleInfo, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseCDStageModuleInfo, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/dummyCDStageModuleInfo`,
    props,
    signal
  )

export type GetExecutionStatusesProps = Omit<GetProps<ResponseListExecutionStatus, Failure | Error, void, void>, 'path'>

/**
 * Gets Execution Status list
 */
export const GetExecutionStatuses = (props: GetExecutionStatusesProps) => (
  <Get<ResponseListExecutionStatus, Failure | Error, void, void>
    path={`/executions/executionStatus`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStatusesProps = Omit<
  UseGetProps<ResponseListExecutionStatus, Failure | Error, void, void>,
  'path'
>

/**
 * Gets Execution Status list
 */
export const useGetExecutionStatuses = (props: UseGetExecutionStatusesProps) =>
  useGet<ResponseListExecutionStatus, Failure | Error, void, void>(`/executions/executionStatus`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Execution Status list
 */
export const getExecutionStatusesPromise = (
  props: GetUsingFetchProps<ResponseListExecutionStatus, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListExecutionStatus, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/executions/executionStatus`,
    props,
    signal
  )

export interface SaveFeedbackQueryParams {
  accountIdentifier?: string
}

export type SaveFeedbackProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, SaveFeedbackQueryParams, FeedbackFormDTO, void>,
  'path' | 'verb'
>

/**
 * Saves Feedback
 */
export const SaveFeedback = (props: SaveFeedbackProps) => (
  <Mutate<ResponseBoolean, Failure | Error, SaveFeedbackQueryParams, FeedbackFormDTO, void>
    verb="POST"
    path={`/feedback`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSaveFeedbackProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, SaveFeedbackQueryParams, FeedbackFormDTO, void>,
  'path' | 'verb'
>

/**
 * Saves Feedback
 */
export const useSaveFeedback = (props: UseSaveFeedbackProps) =>
  useMutate<ResponseBoolean, Failure | Error, SaveFeedbackQueryParams, FeedbackFormDTO, void>('POST', `/feedback`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Saves Feedback
 */
export const saveFeedbackPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, SaveFeedbackQueryParams, FeedbackFormDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, SaveFeedbackQueryParams, FeedbackFormDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/feedback`,
    props,
    signal
  )

export interface GetFilterListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
}

export type GetFilterListProps = Omit<
  GetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const GetFilterList = (props: GetFilterListProps) => (
  <Get<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>
    path={`/filters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFilterListProps = Omit<
  UseGetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const useGetFilterList = (props: UseGetFilterListProps) =>
  useGet<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(`/filters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Filter
 */
export const getFilterListPromise = (
  props: GetUsingFetchProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(
    getConfig('ng/api'),
    `/filters`,
    props,
    signal
  )

export interface PostFilterQueryParams {
  accountIdentifier: string
}

export type PostFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const PostFilter = (props: PostFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>
    verb="POST"
    path={`/filters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const usePostFilter = (props: UsePostFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>('POST', `/filters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a Filter
 */
export const postFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/filters`,
    props,
    signal
  )

export interface UpdateFilterQueryParams {
  accountIdentifier: string
}

export type UpdateFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const UpdateFilter = (props: UpdateFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>
    verb="PUT"
    path={`/filters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const useUpdateFilter = (props: UseUpdateFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    `/filters`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a Filter
 */
export const updateFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/filters`,
    props,
    signal
  )

export interface DeleteFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
}

export type DeleteFilterProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const DeleteFilter = (props: DeleteFilterProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>
    verb="DELETE"
    path={`/filters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteFilterProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const useDeleteFilter = (props: UseDeleteFilterProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>('DELETE', `/filters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a filter
 */
export const deleteFilterPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/filters`,
    props,
    signal
  )

export interface GetFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
}

export interface GetFilterPathParams {
  identifier: string
}

export type GetFilterProps = Omit<
  GetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const GetFilter = ({ identifier, ...props }: GetFilterProps) => (
  <Get<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>
    path={`/filters/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFilterProps = Omit<
  UseGetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const useGetFilter = ({ identifier, ...props }: UseGetFilterProps) =>
  useGet<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    (paramsInPath: GetFilterPathParams) => `/filters/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Filter
 */
export const getFilterPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    getConfig('ng/api'),
    `/filters/${identifier}`,
    props,
    signal
  )

export interface TriggerFullSyncQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type TriggerFullSyncProps = Omit<
  MutateProps<ResponseTriggerFullSyncResponseDTO, Failure | Error, TriggerFullSyncQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Triggers Full Sync
 */
export const TriggerFullSync = (props: TriggerFullSyncProps) => (
  <Mutate<ResponseTriggerFullSyncResponseDTO, Failure | Error, TriggerFullSyncQueryParams, void, void>
    verb="POST"
    path={`/full-sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseTriggerFullSyncProps = Omit<
  UseMutateProps<ResponseTriggerFullSyncResponseDTO, Failure | Error, TriggerFullSyncQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Triggers Full Sync
 */
export const useTriggerFullSync = (props: UseTriggerFullSyncProps) =>
  useMutate<ResponseTriggerFullSyncResponseDTO, Failure | Error, TriggerFullSyncQueryParams, void, void>(
    'POST',
    `/full-sync`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Triggers Full Sync
 */
export const triggerFullSyncPromise = (
  props: MutateUsingFetchProps<
    ResponseTriggerFullSyncResponseDTO,
    Failure | Error,
    TriggerFullSyncQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseTriggerFullSyncResponseDTO, Failure | Error, TriggerFullSyncQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/full-sync`,
    props,
    signal
  )

export interface DeleteGitFullSyncConfigQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteGitFullSyncConfigProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteGitFullSyncConfigQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete full sync configuration
 */
export const DeleteGitFullSyncConfig = (props: DeleteGitFullSyncConfigProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteGitFullSyncConfigQueryParams, void, void>
    verb="DELETE"
    path={`/full-sync/config`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteGitFullSyncConfigProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteGitFullSyncConfigQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete full sync configuration
 */
export const useDeleteGitFullSyncConfig = (props: UseDeleteGitFullSyncConfigProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteGitFullSyncConfigQueryParams, void, void>(
    'DELETE',
    `/full-sync/config`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete full sync configuration
 */
export const deleteGitFullSyncConfigPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteGitFullSyncConfigQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteGitFullSyncConfigQueryParams, void, void>(
    'DELETE',
    getConfig('ng/api'),
    `/full-sync/config`,
    props,
    signal
  )

export interface GetGitFullSyncConfigQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetGitFullSyncConfigProps = Omit<
  GetProps<ResponseGitFullSyncConfigDTO, Failure | Error, GetGitFullSyncConfigQueryParams, void>,
  'path'
>

/**
 * Get full sync configuration
 */
export const GetGitFullSyncConfig = (props: GetGitFullSyncConfigProps) => (
  <Get<ResponseGitFullSyncConfigDTO, Failure | Error, GetGitFullSyncConfigQueryParams, void>
    path={`/full-sync/config`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGitFullSyncConfigProps = Omit<
  UseGetProps<ResponseGitFullSyncConfigDTO, Failure | Error, GetGitFullSyncConfigQueryParams, void>,
  'path'
>

/**
 * Get full sync configuration
 */
export const useGetGitFullSyncConfig = (props: UseGetGitFullSyncConfigProps) =>
  useGet<ResponseGitFullSyncConfigDTO, Failure | Error, GetGitFullSyncConfigQueryParams, void>(`/full-sync/config`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get full sync configuration
 */
export const getGitFullSyncConfigPromise = (
  props: GetUsingFetchProps<ResponseGitFullSyncConfigDTO, Failure | Error, GetGitFullSyncConfigQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitFullSyncConfigDTO, Failure | Error, GetGitFullSyncConfigQueryParams, void>(
    getConfig('ng/api'),
    `/full-sync/config`,
    props,
    signal
  )

export interface CreateGitFullSyncConfigQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateGitFullSyncConfigProps = Omit<
  MutateProps<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    CreateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a full sync configuration
 */
export const CreateGitFullSyncConfig = (props: CreateGitFullSyncConfigProps) => (
  <Mutate<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    CreateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >
    verb="POST"
    path={`/full-sync/config`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateGitFullSyncConfigProps = Omit<
  UseMutateProps<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    CreateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a full sync configuration
 */
export const useCreateGitFullSyncConfig = (props: UseCreateGitFullSyncConfigProps) =>
  useMutate<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    CreateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >('POST', `/full-sync/config`, { base: getConfig('ng/api'), ...props })

/**
 * Create a full sync configuration
 */
export const createGitFullSyncConfigPromise = (
  props: MutateUsingFetchProps<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    CreateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    CreateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/full-sync/config`, props, signal)

export interface UpdateGitFullSyncConfigQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type UpdateGitFullSyncConfigProps = Omit<
  MutateProps<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    UpdateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a full sync configuration
 */
export const UpdateGitFullSyncConfig = (props: UpdateGitFullSyncConfigProps) => (
  <Mutate<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    UpdateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >
    verb="PUT"
    path={`/full-sync/config`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateGitFullSyncConfigProps = Omit<
  UseMutateProps<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    UpdateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a full sync configuration
 */
export const useUpdateGitFullSyncConfig = (props: UseUpdateGitFullSyncConfigProps) =>
  useMutate<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    UpdateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >('PUT', `/full-sync/config`, { base: getConfig('ng/api'), ...props })

/**
 * Update a full sync configuration
 */
export const updateGitFullSyncConfigPromise = (
  props: MutateUsingFetchProps<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    UpdateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitFullSyncConfigDTO,
    Failure | Error,
    UpdateGitFullSyncConfigQueryParams,
    GitFullSyncConfigRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/full-sync/config`, props, signal)

export interface ListFullSyncFilesQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  entityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  syncStatus?: 'QUEUED' | 'PUSHED' | 'FAILED'
}

export type ListFullSyncFilesProps = Omit<
  GetProps<ResponsePageGitFullSyncEntityInfoDTO, Failure | Error, ListFullSyncFilesQueryParams, void>,
  'path'
>

/**
 * List files in full sync along with their status
 */
export const ListFullSyncFiles = (props: ListFullSyncFilesProps) => (
  <Get<ResponsePageGitFullSyncEntityInfoDTO, Failure | Error, ListFullSyncFilesQueryParams, void>
    path={`/full-sync/files`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListFullSyncFilesProps = Omit<
  UseGetProps<ResponsePageGitFullSyncEntityInfoDTO, Failure | Error, ListFullSyncFilesQueryParams, void>,
  'path'
>

/**
 * List files in full sync along with their status
 */
export const useListFullSyncFiles = (props: UseListFullSyncFilesProps) =>
  useGet<ResponsePageGitFullSyncEntityInfoDTO, Failure | Error, ListFullSyncFilesQueryParams, void>(
    `/full-sync/files`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * List files in full sync along with their status
 */
export const listFullSyncFilesPromise = (
  props: GetUsingFetchProps<ResponsePageGitFullSyncEntityInfoDTO, Failure | Error, ListFullSyncFilesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageGitFullSyncEntityInfoDTO, Failure | Error, ListFullSyncFilesQueryParams, void>(
    getConfig('ng/api'),
    `/full-sync/files`,
    props,
    signal
  )

export interface CountFullSyncFilesWithFilterQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  entityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  syncStatus?: 'QUEUED' | 'PUSHED' | 'FAILED'
}

export type CountFullSyncFilesWithFilterProps = Omit<
  GetProps<ResponseLong, Failure | Error, CountFullSyncFilesWithFilterQueryParams, void>,
  'path'
>

/**
 * Count files in full sync for the filter applied
 */
export const CountFullSyncFilesWithFilter = (props: CountFullSyncFilesWithFilterProps) => (
  <Get<ResponseLong, Failure | Error, CountFullSyncFilesWithFilterQueryParams, void>
    path={`/full-sync/files/count`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCountFullSyncFilesWithFilterProps = Omit<
  UseGetProps<ResponseLong, Failure | Error, CountFullSyncFilesWithFilterQueryParams, void>,
  'path'
>

/**
 * Count files in full sync for the filter applied
 */
export const useCountFullSyncFilesWithFilter = (props: UseCountFullSyncFilesWithFilterProps) =>
  useGet<ResponseLong, Failure | Error, CountFullSyncFilesWithFilterQueryParams, void>(`/full-sync/files/count`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Count files in full sync for the filter applied
 */
export const countFullSyncFilesWithFilterPromise = (
  props: GetUsingFetchProps<ResponseLong, Failure | Error, CountFullSyncFilesWithFilterQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseLong, Failure | Error, CountFullSyncFilesWithFilterQueryParams, void>(
    getConfig('ng/api'),
    `/full-sync/files/count`,
    props,
    signal
  )

export interface GetClusterNamesForGcpQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier: string
  projectIdentifier: string
}

export type GetClusterNamesForGcpProps = Omit<
  GetProps<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>,
  'path'
>

/**
 * Gets gcp cluster names
 */
export const GetClusterNamesForGcp = (props: GetClusterNamesForGcpProps) => (
  <Get<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>
    path={`/gcp/clusters`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetClusterNamesForGcpProps = Omit<
  UseGetProps<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>,
  'path'
>

/**
 * Gets gcp cluster names
 */
export const useGetClusterNamesForGcp = (props: UseGetClusterNamesForGcpProps) =>
  useGet<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>(`/gcp/clusters`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets gcp cluster names
 */
export const getClusterNamesForGcpPromise = (
  props: GetUsingFetchProps<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGcpResponseDTO, Failure | Error, GetClusterNamesForGcpQueryParams, void>(
    getConfig('ng/api'),
    `/gcp/clusters`,
    props,
    signal
  )

export interface ListGitSyncQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
}

export type ListGitSyncProps = Omit<GetProps<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>, 'path'>

/**
 * List Git Sync
 */
export const ListGitSync = (props: ListGitSyncProps) => (
  <Get<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>
    path={`/git-sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncProps = Omit<UseGetProps<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>, 'path'>

/**
 * List Git Sync
 */
export const useListGitSync = (props: UseListGitSyncProps) =>
  useGet<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>(`/git-sync`, { base: getConfig('ng/api'), ...props })

/**
 * List Git Sync
 */
export const listGitSyncPromise = (
  props: GetUsingFetchProps<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<GitSyncConfig[], unknown, ListGitSyncQueryParams, void>(getConfig('ng/api'), `/git-sync`, props, signal)

export interface PostGitSyncQueryParams {
  accountIdentifier?: string
}

export type PostGitSyncProps = Omit<
  MutateProps<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync
 */
export const PostGitSync = (props: PostGitSyncProps) => (
  <Mutate<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>
    verb="POST"
    path={`/git-sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostGitSyncProps = Omit<
  UseMutateProps<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync
 */
export const usePostGitSync = (props: UsePostGitSyncProps) =>
  useMutate<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>('POST', `/git-sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create a Git Sync
 */
export const postGitSyncPromise = (
  props: MutateUsingFetchProps<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfig, unknown, PostGitSyncQueryParams, GitSyncConfigRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/git-sync`,
    props,
    signal
  )

export interface PutGitSyncQueryParams {
  accountIdentifier?: string
}

export type PutGitSyncProps = Omit<
  MutateProps<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update Git Sync by id
 */
export const PutGitSync = (props: PutGitSyncProps) => (
  <Mutate<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>
    verb="PUT"
    path={`/git-sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutGitSyncProps = Omit<
  UseMutateProps<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update Git Sync by id
 */
export const usePutGitSync = (props: UsePutGitSyncProps) =>
  useMutate<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>('PUT', `/git-sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Update Git Sync by id
 */
export const putGitSyncPromise = (
  props: MutateUsingFetchProps<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfig, unknown, PutGitSyncQueryParams, GitSyncConfigRequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/git-sync`,
    props,
    signal
  )

export interface GetListOfBranchesWithStatusQueryParams {
  yamlGitConfigIdentifier?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  page?: number
  size?: number
  searchTerm?: string
  branchSyncStatus?: 'SYNCED' | 'SYNCING' | 'UNSYNCED'
}

export type GetListOfBranchesWithStatusProps = Omit<
  GetProps<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>,
  'path'
>

/**
 * Gets list of branches with their status by Git Sync Config Id
 */
export const GetListOfBranchesWithStatus = (props: GetListOfBranchesWithStatusProps) => (
  <Get<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>
    path={`/git-sync-branch/listBranchesWithStatus`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfBranchesWithStatusProps = Omit<
  UseGetProps<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>,
  'path'
>

/**
 * Gets list of branches with their status by Git Sync Config Id
 */
export const useGetListOfBranchesWithStatus = (props: UseGetListOfBranchesWithStatusProps) =>
  useGet<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>(
    `/git-sync-branch/listBranchesWithStatus`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets list of branches with their status by Git Sync Config Id
 */
export const getListOfBranchesWithStatusPromise = (
  props: GetUsingFetchProps<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitBranchListDTO, Failure | Error, GetListOfBranchesWithStatusQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync-branch/listBranchesWithStatus`,
    props,
    signal
  )

export interface SyncGitBranchQueryParams {
  repoIdentifier?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
}

export type SyncGitBranchProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync the new branch into harness
 */
export const SyncGitBranch = (props: SyncGitBranchProps) => (
  <Mutate<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>
    verb="POST"
    path={`/git-sync-branch/sync`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSyncGitBranchProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Sync the new branch into harness
 */
export const useSyncGitBranch = (props: UseSyncGitBranchProps) =>
  useMutate<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>('POST', `/git-sync-branch/sync`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Sync the new branch into harness
 */
export const syncGitBranchPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, SyncGitBranchQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/git-sync-branch/sync`,
    props,
    signal
  )

export interface ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
  size?: number
  gitSyncConfigId?: string
}

export interface ListGitSyncEntitiesSummaryForRepoAndBranchPathParams {
  branch: string
}

export type ListGitSyncEntitiesSummaryForRepoAndBranchProps = Omit<
  MutateProps<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >,
  'path' | 'verb'
> &
  ListGitSyncEntitiesSummaryForRepoAndBranchPathParams

/**
 * List Git Sync Entity by product for Repo and Branch and List of Entities
 */
export const ListGitSyncEntitiesSummaryForRepoAndBranch = ({
  branch,
  ...props
}: ListGitSyncEntitiesSummaryForRepoAndBranchProps) => (
  <Mutate<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >
    verb="POST"
    path={`/git-sync-entities/branch/${branch}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesSummaryForRepoAndBranchProps = Omit<
  UseMutateProps<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >,
  'path' | 'verb'
> &
  ListGitSyncEntitiesSummaryForRepoAndBranchPathParams

/**
 * List Git Sync Entity by product for Repo and Branch and List of Entities
 */
export const useListGitSyncEntitiesSummaryForRepoAndBranch = ({
  branch,
  ...props
}: UseListGitSyncEntitiesSummaryForRepoAndBranchProps) =>
  useMutate<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >(
    'POST',
    (paramsInPath: ListGitSyncEntitiesSummaryForRepoAndBranchPathParams) =>
      `/git-sync-entities/branch/${paramsInPath.branch}`,
    { base: getConfig('ng/api'), pathParams: { branch }, ...props }
  )

/**
 * List Git Sync Entity by product for Repo and Branch and List of Entities
 */
export const listGitSyncEntitiesSummaryForRepoAndBranchPromise = (
  {
    branch,
    ...props
  }: MutateUsingFetchProps<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  > & { branch: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndBranchQueryParams,
    GitEntityBranchFilterSummaryProperties,
    ListGitSyncEntitiesSummaryForRepoAndBranchPathParams
  >('POST', getConfig('ng/api'), `/git-sync-entities/branch/${branch}`, props, signal)

export interface ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
  size?: number
}

export type ListGitSyncEntitiesSummaryForRepoAndTypesProps = Omit<
  MutateProps<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * List Git Sync Entity by product for List of Repos and Entities
 */
export const ListGitSyncEntitiesSummaryForRepoAndTypes = (props: ListGitSyncEntitiesSummaryForRepoAndTypesProps) => (
  <Mutate<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >
    verb="POST"
    path={`/git-sync-entities/summary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesSummaryForRepoAndTypesProps = Omit<
  UseMutateProps<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >,
  'path' | 'verb'
>

/**
 * List Git Sync Entity by product for List of Repos and Entities
 */
export const useListGitSyncEntitiesSummaryForRepoAndTypes = (
  props: UseListGitSyncEntitiesSummaryForRepoAndTypesProps
) =>
  useMutate<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >('POST', `/git-sync-entities/summary`, { base: getConfig('ng/api'), ...props })

/**
 * List Git Sync Entity by product for List of Repos and Entities
 */
export const listGitSyncEntitiesSummaryForRepoAndTypesPromise = (
  props: MutateUsingFetchProps<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitSyncRepoFilesList,
    unknown,
    ListGitSyncEntitiesSummaryForRepoAndTypesQueryParams,
    GitEntityFilterProperties,
    void
  >('POST', getConfig('ng/api'), `/git-sync-entities/summary`, props, signal)

export interface ListGitSyncEntitiesByTypeQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
  gitSyncConfigId?: string
  branch?: string
  page?: number
  size?: number
  moduleType?: string
}

export interface ListGitSyncEntitiesByTypePathParams {
  entityType:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
}

export type ListGitSyncEntitiesByTypeProps = Omit<
  GetProps<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >,
  'path'
> &
  ListGitSyncEntitiesByTypePathParams

/**
 * Get Git Sync Entity By Type
 */
export const ListGitSyncEntitiesByType = ({ entityType, ...props }: ListGitSyncEntitiesByTypeProps) => (
  <Get<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >
    path={`/git-sync-entities/${entityType}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncEntitiesByTypeProps = Omit<
  UseGetProps<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >,
  'path'
> &
  ListGitSyncEntitiesByTypePathParams

/**
 * Get Git Sync Entity By Type
 */
export const useListGitSyncEntitiesByType = ({ entityType, ...props }: UseListGitSyncEntitiesByTypeProps) =>
  useGet<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >((paramsInPath: ListGitSyncEntitiesByTypePathParams) => `/git-sync-entities/${paramsInPath.entityType}`, {
    base: getConfig('ng/api'),
    pathParams: { entityType },
    ...props
  })

/**
 * Get Git Sync Entity By Type
 */
export const listGitSyncEntitiesByTypePromise = (
  {
    entityType,
    ...props
  }: GetUsingFetchProps<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  > & {
    entityType:
      | 'Projects'
      | 'Pipelines'
      | 'PipelineSteps'
      | 'Http'
      | 'JiraCreate'
      | 'ShellScript'
      | 'K8sCanaryDeploy'
      | 'Connectors'
      | 'Secrets'
      | 'Service'
      | 'Environment'
      | 'InputSets'
      | 'CvConfig'
      | 'Delegates'
      | 'DelegateConfigurations'
      | 'CvVerificationJob'
      | 'IntegrationStage'
      | 'IntegrationSteps'
      | 'CvKubernetesActivitySource'
      | 'DeploymentSteps'
      | 'DeploymentStage'
      | 'ApprovalStage'
      | 'FeatureFlagStage'
      | 'Template'
      | 'Triggers'
      | 'MonitoredService'
      | 'GitRepositories'
      | 'FeatureFlags'
      | 'ServiceNowApproval'
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageGitSyncEntityListDTO,
    unknown,
    ListGitSyncEntitiesByTypeQueryParams,
    ListGitSyncEntitiesByTypePathParams
  >(getConfig('ng/api'), `/git-sync-entities/${entityType}`, props, signal)

export interface ListGitSyncErrorsQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  gitToHarness?: boolean
}

export type ListGitSyncErrorsProps = Omit<
  GetProps<ResponsePageGitSyncErrorDTO, Failure | Error, ListGitSyncErrorsQueryParams, void>,
  'path'
>

/**
 * Gets Error list
 */
export const ListGitSyncErrors = (props: ListGitSyncErrorsProps) => (
  <Get<ResponsePageGitSyncErrorDTO, Failure | Error, ListGitSyncErrorsQueryParams, void>
    path={`/git-sync-errors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitSyncErrorsProps = Omit<
  UseGetProps<ResponsePageGitSyncErrorDTO, Failure | Error, ListGitSyncErrorsQueryParams, void>,
  'path'
>

/**
 * Gets Error list
 */
export const useListGitSyncErrors = (props: UseListGitSyncErrorsProps) =>
  useGet<ResponsePageGitSyncErrorDTO, Failure | Error, ListGitSyncErrorsQueryParams, void>(`/git-sync-errors`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Error list
 */
export const listGitSyncErrorsPromise = (
  props: GetUsingFetchProps<ResponsePageGitSyncErrorDTO, Failure | Error, ListGitSyncErrorsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageGitSyncErrorDTO, Failure | Error, ListGitSyncErrorsQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync-errors`,
    props,
    signal
  )

export interface ListGitToHarnessErrorsCommitsQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
  numberOfErrorsInSummary?: number
}

export type ListGitToHarnessErrorsCommitsProps = Omit<
  GetProps<
    ResponsePageGitSyncErrorAggregateByCommitDTO,
    Failure | Error,
    ListGitToHarnessErrorsCommitsQueryParams,
    void
  >,
  'path'
>

/**
 * Gets Error list grouped by commit
 */
export const ListGitToHarnessErrorsCommits = (props: ListGitToHarnessErrorsCommitsProps) => (
  <Get<ResponsePageGitSyncErrorAggregateByCommitDTO, Failure | Error, ListGitToHarnessErrorsCommitsQueryParams, void>
    path={`/git-sync-errors/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitToHarnessErrorsCommitsProps = Omit<
  UseGetProps<
    ResponsePageGitSyncErrorAggregateByCommitDTO,
    Failure | Error,
    ListGitToHarnessErrorsCommitsQueryParams,
    void
  >,
  'path'
>

/**
 * Gets Error list grouped by commit
 */
export const useListGitToHarnessErrorsCommits = (props: UseListGitToHarnessErrorsCommitsProps) =>
  useGet<ResponsePageGitSyncErrorAggregateByCommitDTO, Failure | Error, ListGitToHarnessErrorsCommitsQueryParams, void>(
    `/git-sync-errors/aggregate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Error list grouped by commit
 */
export const listGitToHarnessErrorsCommitsPromise = (
  props: GetUsingFetchProps<
    ResponsePageGitSyncErrorAggregateByCommitDTO,
    Failure | Error,
    ListGitToHarnessErrorsCommitsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageGitSyncErrorAggregateByCommitDTO,
    Failure | Error,
    ListGitToHarnessErrorsCommitsQueryParams,
    void
  >(getConfig('ng/api'), `/git-sync-errors/aggregate`, props, signal)

export interface ListGitToHarnessErrorsForCommitQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export interface ListGitToHarnessErrorsForCommitPathParams {
  commitId: string
}

export type ListGitToHarnessErrorsForCommitProps = Omit<
  GetProps<
    ResponsePageGitSyncErrorDTO,
    Failure | Error,
    ListGitToHarnessErrorsForCommitQueryParams,
    ListGitToHarnessErrorsForCommitPathParams
  >,
  'path'
> &
  ListGitToHarnessErrorsForCommitPathParams

/**
 * Gets Error list for a particular Commit
 */
export const ListGitToHarnessErrorsForCommit = ({ commitId, ...props }: ListGitToHarnessErrorsForCommitProps) => (
  <Get<
    ResponsePageGitSyncErrorDTO,
    Failure | Error,
    ListGitToHarnessErrorsForCommitQueryParams,
    ListGitToHarnessErrorsForCommitPathParams
  >
    path={`/git-sync-errors/commits/${commitId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitToHarnessErrorsForCommitProps = Omit<
  UseGetProps<
    ResponsePageGitSyncErrorDTO,
    Failure | Error,
    ListGitToHarnessErrorsForCommitQueryParams,
    ListGitToHarnessErrorsForCommitPathParams
  >,
  'path'
> &
  ListGitToHarnessErrorsForCommitPathParams

/**
 * Gets Error list for a particular Commit
 */
export const useListGitToHarnessErrorsForCommit = ({ commitId, ...props }: UseListGitToHarnessErrorsForCommitProps) =>
  useGet<
    ResponsePageGitSyncErrorDTO,
    Failure | Error,
    ListGitToHarnessErrorsForCommitQueryParams,
    ListGitToHarnessErrorsForCommitPathParams
  >((paramsInPath: ListGitToHarnessErrorsForCommitPathParams) => `/git-sync-errors/commits/${paramsInPath.commitId}`, {
    base: getConfig('ng/api'),
    pathParams: { commitId },
    ...props
  })

/**
 * Gets Error list for a particular Commit
 */
export const listGitToHarnessErrorsForCommitPromise = (
  {
    commitId,
    ...props
  }: GetUsingFetchProps<
    ResponsePageGitSyncErrorDTO,
    Failure | Error,
    ListGitToHarnessErrorsForCommitQueryParams,
    ListGitToHarnessErrorsForCommitPathParams
  > & { commitId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageGitSyncErrorDTO,
    Failure | Error,
    ListGitToHarnessErrorsForCommitQueryParams,
    ListGitToHarnessErrorsForCommitPathParams
  >(getConfig('ng/api'), `/git-sync-errors/commits/${commitId}`, props, signal)

export interface GetGitSyncErrorsCountQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetGitSyncErrorsCountProps = Omit<
  GetProps<ResponseGitSyncErrorCountDTO, Failure | Error, GetGitSyncErrorsCountQueryParams, void>,
  'path'
>

/**
 * Gets Error Count
 */
export const GetGitSyncErrorsCount = (props: GetGitSyncErrorsCountProps) => (
  <Get<ResponseGitSyncErrorCountDTO, Failure | Error, GetGitSyncErrorsCountQueryParams, void>
    path={`/git-sync-errors/count`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGitSyncErrorsCountProps = Omit<
  UseGetProps<ResponseGitSyncErrorCountDTO, Failure | Error, GetGitSyncErrorsCountQueryParams, void>,
  'path'
>

/**
 * Gets Error Count
 */
export const useGetGitSyncErrorsCount = (props: UseGetGitSyncErrorsCountProps) =>
  useGet<ResponseGitSyncErrorCountDTO, Failure | Error, GetGitSyncErrorsCountQueryParams, void>(
    `/git-sync-errors/count`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Error Count
 */
export const getGitSyncErrorsCountPromise = (
  props: GetUsingFetchProps<ResponseGitSyncErrorCountDTO, Failure | Error, GetGitSyncErrorsCountQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitSyncErrorCountDTO, Failure | Error, GetGitSyncErrorsCountQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync-errors/count`,
    props,
    signal
  )

export interface GetGitSyncSettingsQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  accountIdentifier?: string
}

export type GetGitSyncSettingsProps = Omit<
  GetProps<ResponseGitSyncSettingsDTO, unknown, GetGitSyncSettingsQueryParams, void>,
  'path'
>

/**
 * Get git sync settings
 */
export const GetGitSyncSettings = (props: GetGitSyncSettingsProps) => (
  <Get<ResponseGitSyncSettingsDTO, unknown, GetGitSyncSettingsQueryParams, void>
    path={`/git-sync-settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGitSyncSettingsProps = Omit<
  UseGetProps<ResponseGitSyncSettingsDTO, unknown, GetGitSyncSettingsQueryParams, void>,
  'path'
>

/**
 * Get git sync settings
 */
export const useGetGitSyncSettings = (props: UseGetGitSyncSettingsProps) =>
  useGet<ResponseGitSyncSettingsDTO, unknown, GetGitSyncSettingsQueryParams, void>(`/git-sync-settings`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get git sync settings
 */
export const getGitSyncSettingsPromise = (
  props: GetUsingFetchProps<ResponseGitSyncSettingsDTO, unknown, GetGitSyncSettingsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitSyncSettingsDTO, unknown, GetGitSyncSettingsQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync-settings`,
    props,
    signal
  )

export type PostGitSyncSettingProps = Omit<
  MutateProps<ResponseGitSyncSettingsDTO, unknown, void, GitSyncSettingsDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync Setting
 */
export const PostGitSyncSetting = (props: PostGitSyncSettingProps) => (
  <Mutate<ResponseGitSyncSettingsDTO, unknown, void, GitSyncSettingsDTORequestBody, void>
    verb="POST"
    path={`/git-sync-settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostGitSyncSettingProps = Omit<
  UseMutateProps<ResponseGitSyncSettingsDTO, unknown, void, GitSyncSettingsDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Git Sync Setting
 */
export const usePostGitSyncSetting = (props: UsePostGitSyncSettingProps) =>
  useMutate<ResponseGitSyncSettingsDTO, unknown, void, GitSyncSettingsDTORequestBody, void>(
    'POST',
    `/git-sync-settings`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Git Sync Setting
 */
export const postGitSyncSettingPromise = (
  props: MutateUsingFetchProps<ResponseGitSyncSettingsDTO, unknown, void, GitSyncSettingsDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseGitSyncSettingsDTO, unknown, void, GitSyncSettingsDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/git-sync-settings`,
    props,
    signal
  )

export type UpdateGitSyncSettingProps = Omit<
  MutateProps<ResponseGitSyncSettingsDTO, unknown, void, GitSyncSettingsDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Git Sync Setting
 */
export const UpdateGitSyncSetting = (props: UpdateGitSyncSettingProps) => (
  <Mutate<ResponseGitSyncSettingsDTO, unknown, void, GitSyncSettingsDTORequestBody, void>
    verb="PUT"
    path={`/git-sync-settings`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateGitSyncSettingProps = Omit<
  UseMutateProps<ResponseGitSyncSettingsDTO, unknown, void, GitSyncSettingsDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Git Sync Setting
 */
export const useUpdateGitSyncSetting = (props: UseUpdateGitSyncSettingProps) =>
  useMutate<ResponseGitSyncSettingsDTO, unknown, void, GitSyncSettingsDTORequestBody, void>(
    'PUT',
    `/git-sync-settings`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a Git Sync Setting
 */
export const updateGitSyncSettingPromise = (
  props: MutateUsingFetchProps<ResponseGitSyncSettingsDTO, unknown, void, GitSyncSettingsDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseGitSyncSettingsDTO, unknown, void, GitSyncSettingsDTORequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/git-sync-settings`,
    props,
    signal
  )

export interface IsGitSyncEnabledQueryParams {
  accountIdentifier?: string
  projectIdentifier?: string
  orgIdentifier?: string
}

export type IsGitSyncEnabledProps = Omit<GetProps<GitEnabledDTO, unknown, IsGitSyncEnabledQueryParams, void>, 'path'>

/**
 * Is Git Sync EnabledForProject
 */
export const IsGitSyncEnabled = (props: IsGitSyncEnabledProps) => (
  <Get<GitEnabledDTO, unknown, IsGitSyncEnabledQueryParams, void>
    path={`/git-sync/git-sync-enabled`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseIsGitSyncEnabledProps = Omit<
  UseGetProps<GitEnabledDTO, unknown, IsGitSyncEnabledQueryParams, void>,
  'path'
>

/**
 * Is Git Sync EnabledForProject
 */
export const useIsGitSyncEnabled = (props: UseIsGitSyncEnabledProps) =>
  useGet<GitEnabledDTO, unknown, IsGitSyncEnabledQueryParams, void>(`/git-sync/git-sync-enabled`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Is Git Sync EnabledForProject
 */
export const isGitSyncEnabledPromise = (
  props: GetUsingFetchProps<GitEnabledDTO, unknown, IsGitSyncEnabledQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<GitEnabledDTO, unknown, IsGitSyncEnabledQueryParams, void>(
    getConfig('ng/api'),
    `/git-sync/git-sync-enabled`,
    props,
    signal
  )

export interface PutGitSyncDefaultQueryParams {
  projectId?: string
  organizationId?: string
  accountId?: string
}

export interface PutGitSyncDefaultPathParams {
  identifier: string
  folderIdentifier: string
}

export type PutGitSyncDefaultProps = Omit<
  MutateProps<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>,
  'path' | 'verb'
> &
  PutGitSyncDefaultPathParams

/**
 * Update Git Sync default by id
 */
export const PutGitSyncDefault = ({ identifier, folderIdentifier, ...props }: PutGitSyncDefaultProps) => (
  <Mutate<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>
    verb="PUT"
    path={`/git-sync/${identifier}/folder/${folderIdentifier}/default`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutGitSyncDefaultProps = Omit<
  UseMutateProps<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>,
  'path' | 'verb'
> &
  PutGitSyncDefaultPathParams

/**
 * Update Git Sync default by id
 */
export const usePutGitSyncDefault = ({ identifier, folderIdentifier, ...props }: UsePutGitSyncDefaultProps) =>
  useMutate<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>(
    'PUT',
    (paramsInPath: PutGitSyncDefaultPathParams) =>
      `/git-sync/${paramsInPath.identifier}/folder/${paramsInPath.folderIdentifier}/default`,
    { base: getConfig('ng/api'), pathParams: { identifier, folderIdentifier }, ...props }
  )

/**
 * Update Git Sync default by id
 */
export const putGitSyncDefaultPromise = (
  {
    identifier,
    folderIdentifier,
    ...props
  }: MutateUsingFetchProps<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams> & {
    identifier: string
    folderIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<GitSyncConfig, unknown, PutGitSyncDefaultQueryParams, void, PutGitSyncDefaultPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/git-sync/${identifier}/folder/${folderIdentifier}/default`,
    props,
    signal
  )

export interface CreateGitOpsProviderQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
}

export type CreateGitOpsProviderProps = Omit<
  MutateProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    CreateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a GitOpsProvider
 */
export const CreateGitOpsProvider = (props: CreateGitOpsProviderProps) => (
  <Mutate<
    ResponseGitopsProviderResponse,
    Failure | Error,
    CreateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >
    verb="POST"
    path={`/gitopsproviders`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateGitOpsProviderProps = Omit<
  UseMutateProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    CreateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Creates a GitOpsProvider
 */
export const useCreateGitOpsProvider = (props: UseCreateGitOpsProviderProps) =>
  useMutate<
    ResponseGitopsProviderResponse,
    Failure | Error,
    CreateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >('POST', `/gitopsproviders`, { base: getConfig('ng/api'), ...props })

/**
 * Creates a GitOpsProvider
 */
export const createGitOpsProviderPromise = (
  props: MutateUsingFetchProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    CreateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitopsProviderResponse,
    Failure | Error,
    CreateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >('POST', getConfig('ng/api'), `/gitopsproviders`, props, signal)

export interface UpdateGitOpsProviderQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  rootFolder?: string
  filePath?: string
  commitMsg?: string
  isNewBranch?: boolean
  baseBranch?: string
}

export type UpdateGitOpsProviderProps = Omit<
  MutateProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    UpdateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Updates a GitOpsProvider
 */
export const UpdateGitOpsProvider = (props: UpdateGitOpsProviderProps) => (
  <Mutate<
    ResponseGitopsProviderResponse,
    Failure | Error,
    UpdateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >
    verb="PUT"
    path={`/gitopsproviders`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateGitOpsProviderProps = Omit<
  UseMutateProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    UpdateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Updates a GitOpsProvider
 */
export const useUpdateGitOpsProvider = (props: UseUpdateGitOpsProviderProps) =>
  useMutate<
    ResponseGitopsProviderResponse,
    Failure | Error,
    UpdateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >('PUT', `/gitopsproviders`, { base: getConfig('ng/api'), ...props })

/**
 * Updates a GitOpsProvider
 */
export const updateGitOpsProviderPromise = (
  props: MutateUsingFetchProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    UpdateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseGitopsProviderResponse,
    Failure | Error,
    UpdateGitOpsProviderQueryParams,
    GitOpsProviderRequestBody,
    void
  >('PUT', getConfig('ng/api'), `/gitopsproviders`, props, signal)

export interface ListGitOpsProvidersQueryParams {
  pageIndex?: number
  pageSize?: number
  sort?: string[]
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  type?: 'CONNECTED_ARGO_PROVIDER' | 'MANAGED_ARGO_PROVIDER'
}

export type ListGitOpsProvidersProps = Omit<
  GetProps<ResponsePageGitopsProviderResponse, Failure | Error, ListGitOpsProvidersQueryParams, void>,
  'path'
>

/**
 * List GitOps Providers
 */
export const ListGitOpsProviders = (props: ListGitOpsProvidersProps) => (
  <Get<ResponsePageGitopsProviderResponse, Failure | Error, ListGitOpsProvidersQueryParams, void>
    path={`/gitopsproviders/list`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListGitOpsProvidersProps = Omit<
  UseGetProps<ResponsePageGitopsProviderResponse, Failure | Error, ListGitOpsProvidersQueryParams, void>,
  'path'
>

/**
 * List GitOps Providers
 */
export const useListGitOpsProviders = (props: UseListGitOpsProvidersProps) =>
  useGet<ResponsePageGitopsProviderResponse, Failure | Error, ListGitOpsProvidersQueryParams, void>(
    `/gitopsproviders/list`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * List GitOps Providers
 */
export const listGitOpsProvidersPromise = (
  props: GetUsingFetchProps<ResponsePageGitopsProviderResponse, Failure | Error, ListGitOpsProvidersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageGitopsProviderResponse, Failure | Error, ListGitOpsProvidersQueryParams, void>(
    getConfig('ng/api'),
    `/gitopsproviders/list`,
    props,
    signal
  )

export interface ValidateProviderIdentifierIsUniqueQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ValidateProviderIdentifierIsUniqueProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateProviderIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const ValidateProviderIdentifierIsUnique = (props: ValidateProviderIdentifierIsUniqueProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateProviderIdentifierIsUniqueQueryParams, void>
    path={`/gitopsproviders/validateUniqueIdentifier`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateProviderIdentifierIsUniqueProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateProviderIdentifierIsUniqueQueryParams, void>,
  'path'
>

/**
 * Validate Identifier is unique
 */
export const useValidateProviderIdentifierIsUnique = (props: UseValidateProviderIdentifierIsUniqueProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateProviderIdentifierIsUniqueQueryParams, void>(
    `/gitopsproviders/validateUniqueIdentifier`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Validate Identifier is unique
 */
export const validateProviderIdentifierIsUniquePromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateProviderIdentifierIsUniqueQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateProviderIdentifierIsUniqueQueryParams, void>(
    getConfig('ng/api'),
    `/gitopsproviders/validateUniqueIdentifier`,
    props,
    signal
  )

export interface DeleteGitOpsProviderQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteGitOpsProviderProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteGitOpsProviderQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes a GitOpsProvider
 */
export const DeleteGitOpsProvider = (props: DeleteGitOpsProviderProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteGitOpsProviderQueryParams, string, void>
    verb="DELETE"
    path={`/gitopsproviders`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteGitOpsProviderProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteGitOpsProviderQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Deletes a GitOpsProvider
 */
export const useDeleteGitOpsProvider = (props: UseDeleteGitOpsProviderProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteGitOpsProviderQueryParams, string, void>(
    'DELETE',
    `/gitopsproviders`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Deletes a GitOpsProvider
 */
export const deleteGitOpsProviderPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteGitOpsProviderQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteGitOpsProviderQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/gitopsproviders`,
    props,
    signal
  )

export interface GetGitOpsProviderQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetGitOpsProviderPathParams {
  identifier: string
}

export type GetGitOpsProviderProps = Omit<
  GetProps<ResponseGitopsProviderResponse, Failure | Error, GetGitOpsProviderQueryParams, GetGitOpsProviderPathParams>,
  'path'
> &
  GetGitOpsProviderPathParams

/**
 * Get GitOps Provider
 */
export const GetGitOpsProvider = ({ identifier, ...props }: GetGitOpsProviderProps) => (
  <Get<ResponseGitopsProviderResponse, Failure | Error, GetGitOpsProviderQueryParams, GetGitOpsProviderPathParams>
    path={`/gitopsproviders/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetGitOpsProviderProps = Omit<
  UseGetProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    GetGitOpsProviderQueryParams,
    GetGitOpsProviderPathParams
  >,
  'path'
> &
  GetGitOpsProviderPathParams

/**
 * Get GitOps Provider
 */
export const useGetGitOpsProvider = ({ identifier, ...props }: UseGetGitOpsProviderProps) =>
  useGet<ResponseGitopsProviderResponse, Failure | Error, GetGitOpsProviderQueryParams, GetGitOpsProviderPathParams>(
    (paramsInPath: GetGitOpsProviderPathParams) => `/gitopsproviders/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get GitOps Provider
 */
export const getGitOpsProviderPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseGitopsProviderResponse,
    Failure | Error,
    GetGitOpsProviderQueryParams,
    GetGitOpsProviderPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseGitopsProviderResponse,
    Failure | Error,
    GetGitOpsProviderQueryParams,
    GetGitOpsProviderPathParams
  >(getConfig('ng/api'), `/gitopsproviders/${identifier}`, props, signal)

export type GetNGManagerHealthStatusProps = Omit<GetProps<ResponseString, unknown, void, void>, 'path'>

/**
 * get health for NGManager service
 */
export const GetNGManagerHealthStatus = (props: GetNGManagerHealthStatusProps) => (
  <Get<ResponseString, unknown, void, void> path={`/health`} base={getConfig('ng/api')} {...props} />
)

export type UseGetNGManagerHealthStatusProps = Omit<UseGetProps<ResponseString, unknown, void, void>, 'path'>

/**
 * get health for NGManager service
 */
export const useGetNGManagerHealthStatus = (props: UseGetNGManagerHealthStatusProps) =>
  useGet<ResponseString, unknown, void, void>(`/health`, { base: getConfig('ng/api'), ...props })

/**
 * get health for NGManager service
 */
export const getNGManagerHealthStatusPromise = (
  props: GetUsingFetchProps<ResponseString, unknown, void, void>,
  signal?: RequestInit['signal']
) => getUsingFetch<ResponseString, unknown, void, void>(getConfig('ng/api'), `/health`, props, signal)

export interface GetInstanceNGDataQueryParams {
  accountIdentifier: string
  instanceInfoPodName: string
  instanceInfoNamespace: string
}

export type GetInstanceNGDataProps = Omit<
  GetProps<ResponseOptionalHarnessServiceInfoNG, Failure | Error, GetInstanceNGDataQueryParams, void>,
  'path'
>

/**
 * Get instance NG data
 */
export const GetInstanceNGData = (props: GetInstanceNGDataProps) => (
  <Get<ResponseOptionalHarnessServiceInfoNG, Failure | Error, GetInstanceNGDataQueryParams, void>
    path={`/instanceng`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInstanceNGDataProps = Omit<
  UseGetProps<ResponseOptionalHarnessServiceInfoNG, Failure | Error, GetInstanceNGDataQueryParams, void>,
  'path'
>

/**
 * Get instance NG data
 */
export const useGetInstanceNGData = (props: UseGetInstanceNGDataProps) =>
  useGet<ResponseOptionalHarnessServiceInfoNG, Failure | Error, GetInstanceNGDataQueryParams, void>(`/instanceng`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get instance NG data
 */
export const getInstanceNGDataPromise = (
  props: GetUsingFetchProps<ResponseOptionalHarnessServiceInfoNG, Failure | Error, GetInstanceNGDataQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseOptionalHarnessServiceInfoNG, Failure | Error, GetInstanceNGDataQueryParams, void>(
    getConfig('ng/api'),
    `/instanceng`,
    props,
    signal
  )

export interface GetInstanceSyncPerpetualTaskResponseQueryParams {
  accountIdentifier: string
  perpetualTaskId: string
}

export type GetInstanceSyncPerpetualTaskResponseProps = Omit<
  MutateProps<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseQueryParams,
    DelegateResponseData,
    void
  >,
  'path' | 'verb'
>

/**
 * Get instance sync perpetual task response
 */
export const GetInstanceSyncPerpetualTaskResponse = (props: GetInstanceSyncPerpetualTaskResponseProps) => (
  <Mutate<ResponseBoolean, Failure | Error, GetInstanceSyncPerpetualTaskResponseQueryParams, DelegateResponseData, void>
    verb="POST"
    path={`/instancesync/response`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInstanceSyncPerpetualTaskResponseProps = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseQueryParams,
    DelegateResponseData,
    void
  >,
  'path' | 'verb'
>

/**
 * Get instance sync perpetual task response
 */
export const useGetInstanceSyncPerpetualTaskResponse = (props: UseGetInstanceSyncPerpetualTaskResponseProps) =>
  useMutate<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseQueryParams,
    DelegateResponseData,
    void
  >('POST', `/instancesync/response`, { base: getConfig('ng/api'), ...props })

/**
 * Get instance sync perpetual task response
 */
export const getInstanceSyncPerpetualTaskResponsePromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseQueryParams,
    DelegateResponseData,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | Error,
    GetInstanceSyncPerpetualTaskResponseQueryParams,
    DelegateResponseData,
    void
  >('POST', getConfig('ng/api'), `/instancesync/response`, props, signal)

export interface GetInvitesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetInvitesProps = Omit<GetProps<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>, 'path'>

/**
 * Get all invites for the queried project/organization
 */
export const GetInvites = (props: GetInvitesProps) => (
  <Get<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>
    path={`/invites`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInvitesProps = Omit<
  UseGetProps<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>,
  'path'
>

/**
 * Get all invites for the queried project/organization
 */
export const useGetInvites = (props: UseGetInvitesProps) =>
  useGet<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>(`/invites`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get all invites for the queried project/organization
 */
export const getInvitesPromise = (
  props: GetUsingFetchProps<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageInvite, Failure | Error, GetInvitesQueryParams, void>(
    getConfig('ng/api'),
    `/invites`,
    props,
    signal
  )

export interface SendInviteQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type SendInviteProps = Omit<
  MutateProps<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInvite, void>,
  'path' | 'verb'
>

/**
 * Add a new invite for the specified project/organization
 */
export const SendInvite = (props: SendInviteProps) => (
  <Mutate<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInvite, void>
    verb="POST"
    path={`/invites`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSendInviteProps = Omit<
  UseMutateProps<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInvite, void>,
  'path' | 'verb'
>

/**
 * Add a new invite for the specified project/organization
 */
export const useSendInvite = (props: UseSendInviteProps) =>
  useMutate<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInvite, void>(
    'POST',
    `/invites`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Add a new invite for the specified project/organization
 */
export const sendInvitePromise = (
  props: MutateUsingFetchProps<
    ResponseListInviteOperationResponse,
    Failure | Error,
    SendInviteQueryParams,
    CreateInvite,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseListInviteOperationResponse, Failure | Error, SendInviteQueryParams, CreateInvite, void>(
    'POST',
    getConfig('ng/api'),
    `/invites`,
    props,
    signal
  )

export interface GetPendingUsersAggregatedQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetPendingUsersAggregatedProps = Omit<
  MutateProps<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>,
  'path' | 'verb'
>

/**
 * Get a page of pending users for access control
 */
export const GetPendingUsersAggregated = (props: GetPendingUsersAggregatedProps) => (
  <Mutate<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>
    verb="POST"
    path={`/invites/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPendingUsersAggregatedProps = Omit<
  UseMutateProps<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>,
  'path' | 'verb'
>

/**
 * Get a page of pending users for access control
 */
export const useGetPendingUsersAggregated = (props: UseGetPendingUsersAggregatedProps) =>
  useMutate<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>(
    'POST',
    `/invites/aggregate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get a page of pending users for access control
 */
export const getPendingUsersAggregatedPromise = (
  props: MutateUsingFetchProps<
    ResponsePageInvite,
    Failure | Error,
    GetPendingUsersAggregatedQueryParams,
    ACLAggregateFilter,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePageInvite, Failure | Error, GetPendingUsersAggregatedQueryParams, ACLAggregateFilter, void>(
    'POST',
    getConfig('ng/api'),
    `/invites/aggregate`,
    props,
    signal
  )

export interface GetInviteQueryParams {
  inviteId?: string
  jwttoken?: string
}

export type GetInviteProps = Omit<GetProps<ResponseInvite, Failure | Error, GetInviteQueryParams, void>, 'path'>

/**
 * Get invite
 */
export const GetInvite = (props: GetInviteProps) => (
  <Get<ResponseInvite, Failure | Error, GetInviteQueryParams, void>
    path={`/invites/invite`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetInviteProps = Omit<UseGetProps<ResponseInvite, Failure | Error, GetInviteQueryParams, void>, 'path'>

/**
 * Get invite
 */
export const useGetInvite = (props: UseGetInviteProps) =>
  useGet<ResponseInvite, Failure | Error, GetInviteQueryParams, void>(`/invites/invite`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get invite
 */
export const getInvitePromise = (
  props: GetUsingFetchProps<ResponseInvite, Failure | Error, GetInviteQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseInvite, Failure | Error, GetInviteQueryParams, void>(
    getConfig('ng/api'),
    `/invites/invite`,
    props,
    signal
  )

export type DeleteInviteProps = Omit<
  MutateProps<ResponseOptionalInvite, Failure | Error, void, string, void>,
  'path' | 'verb'
>

/**
 * Delete a invite for the specified project/organization
 */
export const DeleteInvite = (props: DeleteInviteProps) => (
  <Mutate<ResponseOptionalInvite, Failure | Error, void, string, void>
    verb="DELETE"
    path={`/invites`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteInviteProps = Omit<
  UseMutateProps<ResponseOptionalInvite, Failure | Error, void, string, void>,
  'path' | 'verb'
>

/**
 * Delete a invite for the specified project/organization
 */
export const useDeleteInvite = (props: UseDeleteInviteProps) =>
  useMutate<ResponseOptionalInvite, Failure | Error, void, string, void>('DELETE', `/invites`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a invite for the specified project/organization
 */
export const deleteInvitePromise = (
  props: MutateUsingFetchProps<ResponseOptionalInvite, Failure | Error, void, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseOptionalInvite, Failure | Error, void, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/invites`,
    props,
    signal
  )

export interface UpdateInviteQueryParams {
  accountIdentifier?: string
}

export interface UpdateInvitePathParams {
  inviteId: string
}

export type UpdateInviteProps = Omit<
  MutateProps<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>,
  'path' | 'verb'
> &
  UpdateInvitePathParams

/**
 * Resend invite mail
 */
export const UpdateInvite = ({ inviteId, ...props }: UpdateInviteProps) => (
  <Mutate<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>
    verb="PUT"
    path={`/invites/${inviteId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateInviteProps = Omit<
  UseMutateProps<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>,
  'path' | 'verb'
> &
  UpdateInvitePathParams

/**
 * Resend invite mail
 */
export const useUpdateInvite = ({ inviteId, ...props }: UseUpdateInviteProps) =>
  useMutate<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>(
    'PUT',
    (paramsInPath: UpdateInvitePathParams) => `/invites/${paramsInPath.inviteId}`,
    { base: getConfig('ng/api'), pathParams: { inviteId }, ...props }
  )

/**
 * Resend invite mail
 */
export const updateInvitePromise = (
  {
    inviteId,
    ...props
  }: MutateUsingFetchProps<
    ResponseOptionalInvite,
    Failure | Error,
    UpdateInviteQueryParams,
    Invite,
    UpdateInvitePathParams
  > & { inviteId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseOptionalInvite, Failure | Error, UpdateInviteQueryParams, Invite, UpdateInvitePathParams>(
    'PUT',
    getConfig('ng/api'),
    `/invites/${inviteId}`,
    props,
    signal
  )

export interface GetJiraIssueCreateMetadataQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  projectKey?: string
  issueType?: string
  expand?: string
  fetchStatus?: boolean
  ignoreComment?: boolean
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetJiraIssueCreateMetadataProps = Omit<
  GetProps<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira issue create metadata
 */
export const GetJiraIssueCreateMetadata = (props: GetJiraIssueCreateMetadataProps) => (
  <Get<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>
    path={`/jira/createMetadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraIssueCreateMetadataProps = Omit<
  UseGetProps<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira issue create metadata
 */
export const useGetJiraIssueCreateMetadata = (props: UseGetJiraIssueCreateMetadataProps) =>
  useGet<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>(
    `/jira/createMetadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get jira issue create metadata
 */
export const getJiraIssueCreateMetadataPromise = (
  props: GetUsingFetchProps<
    ResponseJiraIssueCreateMetadataNG,
    Failure | Error,
    GetJiraIssueCreateMetadataQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJiraIssueCreateMetadataNG, Failure | Error, GetJiraIssueCreateMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/jira/createMetadata`,
    props,
    signal
  )

export interface GetJiraProjectsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetJiraProjectsProps = Omit<
  GetProps<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>,
  'path'
>

/**
 * Get jira projects
 */
export const GetJiraProjects = (props: GetJiraProjectsProps) => (
  <Get<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>
    path={`/jira/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraProjectsProps = Omit<
  UseGetProps<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>,
  'path'
>

/**
 * Get jira projects
 */
export const useGetJiraProjects = (props: UseGetJiraProjectsProps) =>
  useGet<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>(`/jira/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get jira projects
 */
export const getJiraProjectsPromise = (
  props: GetUsingFetchProps<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListJiraProjectBasicNG, Failure | Error, GetJiraProjectsQueryParams, void>(
    getConfig('ng/api'),
    `/jira/projects`,
    props,
    signal
  )

export interface GetJiraStatusesQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  projectKey?: string
  issueType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetJiraStatusesProps = Omit<
  GetProps<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>,
  'path'
>

/**
 * Get jira statuses
 */
export const GetJiraStatuses = (props: GetJiraStatusesProps) => (
  <Get<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>
    path={`/jira/statuses`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraStatusesProps = Omit<
  UseGetProps<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>,
  'path'
>

/**
 * Get jira statuses
 */
export const useGetJiraStatuses = (props: UseGetJiraStatusesProps) =>
  useGet<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>(`/jira/statuses`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get jira statuses
 */
export const getJiraStatusesPromise = (
  props: GetUsingFetchProps<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListJiraStatusNG, Failure | Error, GetJiraStatusesQueryParams, void>(
    getConfig('ng/api'),
    `/jira/statuses`,
    props,
    signal
  )

export interface GetJiraIssueUpdateMetadataQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  issueKey?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetJiraIssueUpdateMetadataProps = Omit<
  GetProps<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira issue update metadata
 */
export const GetJiraIssueUpdateMetadata = (props: GetJiraIssueUpdateMetadataProps) => (
  <Get<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>
    path={`/jira/updateMetadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetJiraIssueUpdateMetadataProps = Omit<
  UseGetProps<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>,
  'path'
>

/**
 * Get jira issue update metadata
 */
export const useGetJiraIssueUpdateMetadata = (props: UseGetJiraIssueUpdateMetadataProps) =>
  useGet<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>(
    `/jira/updateMetadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get jira issue update metadata
 */
export const getJiraIssueUpdateMetadataPromise = (
  props: GetUsingFetchProps<
    ResponseJiraIssueUpdateMetadataNG,
    Failure | Error,
    GetJiraIssueUpdateMetadataQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJiraIssueUpdateMetadataNG, Failure | Error, GetJiraIssueUpdateMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/jira/updateMetadata`,
    props,
    signal
  )

export interface ValidateJiraCredentialsQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type ValidateJiraCredentialsProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>,
  'path'
>

/**
 * Validate jira credentials
 */
export const ValidateJiraCredentials = (props: ValidateJiraCredentialsProps) => (
  <Get<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>
    path={`/jira/validate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateJiraCredentialsProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>,
  'path'
>

/**
 * Validate jira credentials
 */
export const useValidateJiraCredentials = (props: UseValidateJiraCredentialsProps) =>
  useGet<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>(`/jira/validate`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Validate jira credentials
 */
export const validateJiraCredentialsPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, ValidateJiraCredentialsQueryParams, void>(
    getConfig('ng/api'),
    `/jira/validate`,
    props,
    signal
  )

export interface GetActiveDeploymentStatsQueryParams {
  accountIdentifier: string
}

export type GetActiveDeploymentStatsProps = Omit<
  MutateProps<
    ResponsePipelinesExecutionDashboardInfo,
    Failure | Error,
    GetActiveDeploymentStatsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get active deployment stats
 */
export const GetActiveDeploymentStats = (props: GetActiveDeploymentStatsProps) => (
  <Mutate<
    ResponsePipelinesExecutionDashboardInfo,
    Failure | Error,
    GetActiveDeploymentStatsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >
    verb="POST"
    path={`/landingDashboards/activeDeploymentStats`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveDeploymentStatsProps = Omit<
  UseMutateProps<
    ResponsePipelinesExecutionDashboardInfo,
    Failure | Error,
    GetActiveDeploymentStatsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get active deployment stats
 */
export const useGetActiveDeploymentStats = (props: UseGetActiveDeploymentStatsProps) =>
  useMutate<
    ResponsePipelinesExecutionDashboardInfo,
    Failure | Error,
    GetActiveDeploymentStatsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', `/landingDashboards/activeDeploymentStats`, { base: getConfig('ng/api'), ...props })

/**
 * Get active deployment stats
 */
export const getActiveDeploymentStatsPromise = (
  props: MutateUsingFetchProps<
    ResponsePipelinesExecutionDashboardInfo,
    Failure | Error,
    GetActiveDeploymentStatsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePipelinesExecutionDashboardInfo,
    Failure | Error,
    GetActiveDeploymentStatsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', getConfig('ng/api'), `/landingDashboards/activeDeploymentStats`, props, signal)

export interface GetActiveServicesQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
  sortBy: 'DEPLOYMENTS' | 'INSTANCES'
}

export type GetActiveServicesProps = Omit<
  MutateProps<
    ResponseServicesDashboardInfo,
    Failure | Error,
    GetActiveServicesQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Most Active Services
 */
export const GetActiveServices = (props: GetActiveServicesProps) => (
  <Mutate<
    ResponseServicesDashboardInfo,
    Failure | Error,
    GetActiveServicesQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >
    verb="POST"
    path={`/landingDashboards/activeServices`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetActiveServicesProps = Omit<
  UseMutateProps<
    ResponseServicesDashboardInfo,
    Failure | Error,
    GetActiveServicesQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Most Active Services
 */
export const useGetActiveServices = (props: UseGetActiveServicesProps) =>
  useMutate<
    ResponseServicesDashboardInfo,
    Failure | Error,
    GetActiveServicesQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', `/landingDashboards/activeServices`, { base: getConfig('ng/api'), ...props })

/**
 * Get Most Active Services
 */
export const getActiveServicesPromise = (
  props: MutateUsingFetchProps<
    ResponseServicesDashboardInfo,
    Failure | Error,
    GetActiveServicesQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServicesDashboardInfo,
    Failure | Error,
    GetActiveServicesQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', getConfig('ng/api'), `/landingDashboards/activeServices`, props, signal)

export interface GetDeploymentStatsSummaryQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
  groupBy: 'DAY' | 'WEEK' | 'MONTH'
}

export type GetDeploymentStatsSummaryProps = Omit<
  MutateProps<
    ResponseDeploymentStatsSummary,
    Failure | Error,
    GetDeploymentStatsSummaryQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get deployment stats summary
 */
export const GetDeploymentStatsSummary = (props: GetDeploymentStatsSummaryProps) => (
  <Mutate<
    ResponseDeploymentStatsSummary,
    Failure | Error,
    GetDeploymentStatsSummaryQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >
    verb="POST"
    path={`/landingDashboards/deploymentStatsSummary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDeploymentStatsSummaryProps = Omit<
  UseMutateProps<
    ResponseDeploymentStatsSummary,
    Failure | Error,
    GetDeploymentStatsSummaryQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get deployment stats summary
 */
export const useGetDeploymentStatsSummary = (props: UseGetDeploymentStatsSummaryProps) =>
  useMutate<
    ResponseDeploymentStatsSummary,
    Failure | Error,
    GetDeploymentStatsSummaryQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', `/landingDashboards/deploymentStatsSummary`, { base: getConfig('ng/api'), ...props })

/**
 * Get deployment stats summary
 */
export const getDeploymentStatsSummaryPromise = (
  props: MutateUsingFetchProps<
    ResponseDeploymentStatsSummary,
    Failure | Error,
    GetDeploymentStatsSummaryQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseDeploymentStatsSummary,
    Failure | Error,
    GetDeploymentStatsSummaryQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', getConfig('ng/api'), `/landingDashboards/deploymentStatsSummary`, props, signal)

export interface GetEnvCountQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
}

export type GetEnvCountProps = Omit<
  MutateProps<ResponseEnvCount, Failure | Error, GetEnvCountQueryParams, LandingDashboardRequestCDRequestBody, void>,
  'path' | 'verb'
>

/**
 * Get environments count
 */
export const GetEnvCount = (props: GetEnvCountProps) => (
  <Mutate<ResponseEnvCount, Failure | Error, GetEnvCountQueryParams, LandingDashboardRequestCDRequestBody, void>
    verb="POST"
    path={`/landingDashboards/envCount`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEnvCountProps = Omit<
  UseMutateProps<ResponseEnvCount, Failure | Error, GetEnvCountQueryParams, LandingDashboardRequestCDRequestBody, void>,
  'path' | 'verb'
>

/**
 * Get environments count
 */
export const useGetEnvCount = (props: UseGetEnvCountProps) =>
  useMutate<ResponseEnvCount, Failure | Error, GetEnvCountQueryParams, LandingDashboardRequestCDRequestBody, void>(
    'POST',
    `/landingDashboards/envCount`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get environments count
 */
export const getEnvCountPromise = (
  props: MutateUsingFetchProps<
    ResponseEnvCount,
    Failure | Error,
    GetEnvCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseEnvCount,
    Failure | Error,
    GetEnvCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', getConfig('ng/api'), `/landingDashboards/envCount`, props, signal)

export interface GetServicesCountQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
}

export type GetServicesCountProps = Omit<
  MutateProps<
    ResponseServicesCount,
    Failure | Error,
    GetServicesCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get services count
 */
export const GetServicesCount = (props: GetServicesCountProps) => (
  <Mutate<
    ResponseServicesCount,
    Failure | Error,
    GetServicesCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >
    verb="POST"
    path={`/landingDashboards/servicesCount`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServicesCountProps = Omit<
  UseMutateProps<
    ResponseServicesCount,
    Failure | Error,
    GetServicesCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get services count
 */
export const useGetServicesCount = (props: UseGetServicesCountProps) =>
  useMutate<
    ResponseServicesCount,
    Failure | Error,
    GetServicesCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', `/landingDashboards/servicesCount`, { base: getConfig('ng/api'), ...props })

/**
 * Get services count
 */
export const getServicesCountPromise = (
  props: MutateUsingFetchProps<
    ResponseServicesCount,
    Failure | Error,
    GetServicesCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServicesCount,
    Failure | Error,
    GetServicesCountQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', getConfig('ng/api'), `/landingDashboards/servicesCount`, props, signal)

export interface GetTopProjectsQueryParams {
  accountIdentifier: string
  startTime: number
  endTime: number
}

export type GetTopProjectsProps = Omit<
  MutateProps<
    ResponseProjectsDashboardInfo,
    Failure | Error,
    GetTopProjectsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Top Projects as per Deployments
 */
export const GetTopProjects = (props: GetTopProjectsProps) => (
  <Mutate<
    ResponseProjectsDashboardInfo,
    Failure | Error,
    GetTopProjectsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >
    verb="POST"
    path={`/landingDashboards/topProjects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTopProjectsProps = Omit<
  UseMutateProps<
    ResponseProjectsDashboardInfo,
    Failure | Error,
    GetTopProjectsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Top Projects as per Deployments
 */
export const useGetTopProjects = (props: UseGetTopProjectsProps) =>
  useMutate<
    ResponseProjectsDashboardInfo,
    Failure | Error,
    GetTopProjectsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', `/landingDashboards/topProjects`, { base: getConfig('ng/api'), ...props })

/**
 * Get Top Projects as per Deployments
 */
export const getTopProjectsPromise = (
  props: MutateUsingFetchProps<
    ResponseProjectsDashboardInfo,
    Failure | Error,
    GetTopProjectsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseProjectsDashboardInfo,
    Failure | Error,
    GetTopProjectsQueryParams,
    LandingDashboardRequestCDRequestBody,
    void
  >('POST', getConfig('ng/api'), `/landingDashboards/topProjects`, props, signal)

export interface GetAccountLicensesQueryParams {
  accountIdentifier?: string
}

export type GetAccountLicensesProps = Omit<
  GetProps<ResponseAccountLicenseDTO, Failure | Error, GetAccountLicensesQueryParams, void>,
  'path'
>

/**
 * Gets All Module License Information in Account
 */
export const GetAccountLicenses = (props: GetAccountLicensesProps) => (
  <Get<ResponseAccountLicenseDTO, Failure | Error, GetAccountLicensesQueryParams, void>
    path={`/licenses/account`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAccountLicensesProps = Omit<
  UseGetProps<ResponseAccountLicenseDTO, Failure | Error, GetAccountLicensesQueryParams, void>,
  'path'
>

/**
 * Gets All Module License Information in Account
 */
export const useGetAccountLicenses = (props: UseGetAccountLicensesProps) =>
  useGet<ResponseAccountLicenseDTO, Failure | Error, GetAccountLicensesQueryParams, void>(`/licenses/account`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets All Module License Information in Account
 */
export const getAccountLicensesPromise = (
  props: GetUsingFetchProps<ResponseAccountLicenseDTO, Failure | Error, GetAccountLicensesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseAccountLicenseDTO, Failure | Error, GetAccountLicensesQueryParams, void>(
    getConfig('ng/api'),
    `/licenses/account`,
    props,
    signal
  )

export interface GetEditionActionsQueryParams {
  accountIdentifier: string
  moduleType: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
}

export type GetEditionActionsProps = Omit<
  GetProps<ResponseMapEditionSetEditionActionDTO, Failure | Error, GetEditionActionsQueryParams, void>,
  'path'
>

/**
 * Get Allowed Actions Under Each Edition
 */
export const GetEditionActions = (props: GetEditionActionsProps) => (
  <Get<ResponseMapEditionSetEditionActionDTO, Failure | Error, GetEditionActionsQueryParams, void>
    path={`/licenses/actions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetEditionActionsProps = Omit<
  UseGetProps<ResponseMapEditionSetEditionActionDTO, Failure | Error, GetEditionActionsQueryParams, void>,
  'path'
>

/**
 * Get Allowed Actions Under Each Edition
 */
export const useGetEditionActions = (props: UseGetEditionActionsProps) =>
  useGet<ResponseMapEditionSetEditionActionDTO, Failure | Error, GetEditionActionsQueryParams, void>(
    `/licenses/actions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Allowed Actions Under Each Edition
 */
export const getEditionActionsPromise = (
  props: GetUsingFetchProps<ResponseMapEditionSetEditionActionDTO, Failure | Error, GetEditionActionsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapEditionSetEditionActionDTO, Failure | Error, GetEditionActionsQueryParams, void>(
    getConfig('ng/api'),
    `/licenses/actions`,
    props,
    signal
  )

export interface StartCommunityLicenseQueryParams {
  accountIdentifier: string
  moduleType: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
}

export type StartCommunityLicenseProps = Omit<
  MutateProps<ResponseModuleLicenseDTO, Failure | Error, StartCommunityLicenseQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Starts Community License For A Module
 */
export const StartCommunityLicense = (props: StartCommunityLicenseProps) => (
  <Mutate<ResponseModuleLicenseDTO, Failure | Error, StartCommunityLicenseQueryParams, void, void>
    verb="POST"
    path={`/licenses/community`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseStartCommunityLicenseProps = Omit<
  UseMutateProps<ResponseModuleLicenseDTO, Failure | Error, StartCommunityLicenseQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Starts Community License For A Module
 */
export const useStartCommunityLicense = (props: UseStartCommunityLicenseProps) =>
  useMutate<ResponseModuleLicenseDTO, Failure | Error, StartCommunityLicenseQueryParams, void, void>(
    'POST',
    `/licenses/community`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Starts Community License For A Module
 */
export const startCommunityLicensePromise = (
  props: MutateUsingFetchProps<ResponseModuleLicenseDTO, Failure | Error, StartCommunityLicenseQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseModuleLicenseDTO, Failure | Error, StartCommunityLicenseQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/licenses/community`,
    props,
    signal
  )

export interface ExtendTrialLicenseQueryParams {
  accountIdentifier: string
}

export type ExtendTrialLicenseProps = Omit<
  MutateProps<ResponseModuleLicenseDTO, Failure | Error, ExtendTrialLicenseQueryParams, StartTrialDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Extends Trail License For A Module
 */
export const ExtendTrialLicense = (props: ExtendTrialLicenseProps) => (
  <Mutate<ResponseModuleLicenseDTO, Failure | Error, ExtendTrialLicenseQueryParams, StartTrialDTORequestBody, void>
    verb="POST"
    path={`/licenses/extend-trial`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseExtendTrialLicenseProps = Omit<
  UseMutateProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    ExtendTrialLicenseQueryParams,
    StartTrialDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Extends Trail License For A Module
 */
export const useExtendTrialLicense = (props: UseExtendTrialLicenseProps) =>
  useMutate<ResponseModuleLicenseDTO, Failure | Error, ExtendTrialLicenseQueryParams, StartTrialDTORequestBody, void>(
    'POST',
    `/licenses/extend-trial`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Extends Trail License For A Module
 */
export const extendTrialLicensePromise = (
  props: MutateUsingFetchProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    ExtendTrialLicenseQueryParams,
    StartTrialDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseModuleLicenseDTO,
    Failure | Error,
    ExtendTrialLicenseQueryParams,
    StartTrialDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/licenses/extend-trial`, props, signal)

export interface StartFreeLicenseQueryParams {
  accountIdentifier: string
  moduleType: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
}

export type StartFreeLicenseProps = Omit<
  MutateProps<ResponseModuleLicenseDTO, Failure | Error, StartFreeLicenseQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Starts Free License For A Module
 */
export const StartFreeLicense = (props: StartFreeLicenseProps) => (
  <Mutate<ResponseModuleLicenseDTO, Failure | Error, StartFreeLicenseQueryParams, void, void>
    verb="POST"
    path={`/licenses/free`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseStartFreeLicenseProps = Omit<
  UseMutateProps<ResponseModuleLicenseDTO, Failure | Error, StartFreeLicenseQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Starts Free License For A Module
 */
export const useStartFreeLicense = (props: UseStartFreeLicenseProps) =>
  useMutate<ResponseModuleLicenseDTO, Failure | Error, StartFreeLicenseQueryParams, void, void>(
    'POST',
    `/licenses/free`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Starts Free License For A Module
 */
export const startFreeLicensePromise = (
  props: MutateUsingFetchProps<ResponseModuleLicenseDTO, Failure | Error, StartFreeLicenseQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseModuleLicenseDTO, Failure | Error, StartFreeLicenseQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/licenses/free`,
    props,
    signal
  )

export interface GetModuleLicensesByAccountAndModuleTypeQueryParams {
  moduleType: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
}

export interface GetModuleLicensesByAccountAndModuleTypePathParams {
  accountIdentifier: string
}

export type GetModuleLicensesByAccountAndModuleTypeProps = Omit<
  GetProps<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetModuleLicensesByAccountAndModuleTypeQueryParams,
    GetModuleLicensesByAccountAndModuleTypePathParams
  >,
  'path'
> &
  GetModuleLicensesByAccountAndModuleTypePathParams

/**
 * Gets Module Licenses By Account And ModuleType
 */
export const GetModuleLicensesByAccountAndModuleType = ({
  accountIdentifier,
  ...props
}: GetModuleLicensesByAccountAndModuleTypeProps) => (
  <Get<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetModuleLicensesByAccountAndModuleTypeQueryParams,
    GetModuleLicensesByAccountAndModuleTypePathParams
  >
    path={`/licenses/modules/${accountIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetModuleLicensesByAccountAndModuleTypeProps = Omit<
  UseGetProps<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetModuleLicensesByAccountAndModuleTypeQueryParams,
    GetModuleLicensesByAccountAndModuleTypePathParams
  >,
  'path'
> &
  GetModuleLicensesByAccountAndModuleTypePathParams

/**
 * Gets Module Licenses By Account And ModuleType
 */
export const useGetModuleLicensesByAccountAndModuleType = ({
  accountIdentifier,
  ...props
}: UseGetModuleLicensesByAccountAndModuleTypeProps) =>
  useGet<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetModuleLicensesByAccountAndModuleTypeQueryParams,
    GetModuleLicensesByAccountAndModuleTypePathParams
  >(
    (paramsInPath: GetModuleLicensesByAccountAndModuleTypePathParams) =>
      `/licenses/modules/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Gets Module Licenses By Account And ModuleType
 */
export const getModuleLicensesByAccountAndModuleTypePromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetModuleLicensesByAccountAndModuleTypeQueryParams,
    GetModuleLicensesByAccountAndModuleTypePathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseListModuleLicenseDTO,
    Failure | Error,
    GetModuleLicensesByAccountAndModuleTypeQueryParams,
    GetModuleLicensesByAccountAndModuleTypePathParams
  >(getConfig('ng/api'), `/licenses/modules/${accountIdentifier}`, props, signal)

export interface StartTrialLicenseQueryParams {
  accountIdentifier: string
}

export type StartTrialLicenseProps = Omit<
  MutateProps<ResponseModuleLicenseDTO, Failure | Error, StartTrialLicenseQueryParams, StartTrialDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Starts Trial License For A Module
 */
export const StartTrialLicense = (props: StartTrialLicenseProps) => (
  <Mutate<ResponseModuleLicenseDTO, Failure | Error, StartTrialLicenseQueryParams, StartTrialDTORequestBody, void>
    verb="POST"
    path={`/licenses/trial`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseStartTrialLicenseProps = Omit<
  UseMutateProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    StartTrialLicenseQueryParams,
    StartTrialDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Starts Trial License For A Module
 */
export const useStartTrialLicense = (props: UseStartTrialLicenseProps) =>
  useMutate<ResponseModuleLicenseDTO, Failure | Error, StartTrialLicenseQueryParams, StartTrialDTORequestBody, void>(
    'POST',
    `/licenses/trial`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Starts Trial License For A Module
 */
export const startTrialLicensePromise = (
  props: MutateUsingFetchProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    StartTrialLicenseQueryParams,
    StartTrialDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseModuleLicenseDTO,
    Failure | Error,
    StartTrialLicenseQueryParams,
    StartTrialDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/licenses/trial`, props, signal)

export interface GetLastModifiedTimeForAllModuleTypesQueryParams {
  accountIdentifier: string
}

export type GetLastModifiedTimeForAllModuleTypesProps = Omit<
  MutateProps<ResponseMapModuleTypeLong, Failure | Error, GetLastModifiedTimeForAllModuleTypesQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Get Last Modified Time For All Module Types
 */
export const GetLastModifiedTimeForAllModuleTypes = (props: GetLastModifiedTimeForAllModuleTypesProps) => (
  <Mutate<ResponseMapModuleTypeLong, Failure | Error, GetLastModifiedTimeForAllModuleTypesQueryParams, void, void>
    verb="POST"
    path={`/licenses/versions`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLastModifiedTimeForAllModuleTypesProps = Omit<
  UseMutateProps<
    ResponseMapModuleTypeLong,
    Failure | Error,
    GetLastModifiedTimeForAllModuleTypesQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Last Modified Time For All Module Types
 */
export const useGetLastModifiedTimeForAllModuleTypes = (props: UseGetLastModifiedTimeForAllModuleTypesProps) =>
  useMutate<ResponseMapModuleTypeLong, Failure | Error, GetLastModifiedTimeForAllModuleTypesQueryParams, void, void>(
    'POST',
    `/licenses/versions`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Last Modified Time For All Module Types
 */
export const getLastModifiedTimeForAllModuleTypesPromise = (
  props: MutateUsingFetchProps<
    ResponseMapModuleTypeLong,
    Failure | Error,
    GetLastModifiedTimeForAllModuleTypesQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseMapModuleTypeLong,
    Failure | Error,
    GetLastModifiedTimeForAllModuleTypesQueryParams,
    void,
    void
  >('POST', getConfig('ng/api'), `/licenses/versions`, props, signal)

export interface GetLicensesAndSummaryQueryParams {
  moduleType: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
}

export interface GetLicensesAndSummaryPathParams {
  accountIdentifier: string
}

export type GetLicensesAndSummaryProps = Omit<
  GetProps<
    ResponseLicensesWithSummaryDTO,
    Failure | Error,
    GetLicensesAndSummaryQueryParams,
    GetLicensesAndSummaryPathParams
  >,
  'path'
> &
  GetLicensesAndSummaryPathParams

/**
 * Gets Module Licenses With Summary By Account And ModuleType
 */
export const GetLicensesAndSummary = ({ accountIdentifier, ...props }: GetLicensesAndSummaryProps) => (
  <Get<
    ResponseLicensesWithSummaryDTO,
    Failure | Error,
    GetLicensesAndSummaryQueryParams,
    GetLicensesAndSummaryPathParams
  >
    path={`/licenses/${accountIdentifier}/summary`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLicensesAndSummaryProps = Omit<
  UseGetProps<
    ResponseLicensesWithSummaryDTO,
    Failure | Error,
    GetLicensesAndSummaryQueryParams,
    GetLicensesAndSummaryPathParams
  >,
  'path'
> &
  GetLicensesAndSummaryPathParams

/**
 * Gets Module Licenses With Summary By Account And ModuleType
 */
export const useGetLicensesAndSummary = ({ accountIdentifier, ...props }: UseGetLicensesAndSummaryProps) =>
  useGet<
    ResponseLicensesWithSummaryDTO,
    Failure | Error,
    GetLicensesAndSummaryQueryParams,
    GetLicensesAndSummaryPathParams
  >((paramsInPath: GetLicensesAndSummaryPathParams) => `/licenses/${paramsInPath.accountIdentifier}/summary`, {
    base: getConfig('ng/api'),
    pathParams: { accountIdentifier },
    ...props
  })

/**
 * Gets Module Licenses With Summary By Account And ModuleType
 */
export const getLicensesAndSummaryPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseLicensesWithSummaryDTO,
    Failure | Error,
    GetLicensesAndSummaryQueryParams,
    GetLicensesAndSummaryPathParams
  > & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseLicensesWithSummaryDTO,
    Failure | Error,
    GetLicensesAndSummaryQueryParams,
    GetLicensesAndSummaryPathParams
  >(getConfig('ng/api'), `/licenses/${accountIdentifier}/summary`, props, signal)

export interface GetModuleLicenseByIdQueryParams {
  accountIdentifier: string
}

export interface GetModuleLicenseByIdPathParams {
  identifier: string
}

export type GetModuleLicenseByIdProps = Omit<
  GetProps<ResponseModuleLicenseDTO, Failure | Error, GetModuleLicenseByIdQueryParams, GetModuleLicenseByIdPathParams>,
  'path'
> &
  GetModuleLicenseByIdPathParams

/**
 * Gets Module License
 */
export const GetModuleLicenseById = ({ identifier, ...props }: GetModuleLicenseByIdProps) => (
  <Get<ResponseModuleLicenseDTO, Failure | Error, GetModuleLicenseByIdQueryParams, GetModuleLicenseByIdPathParams>
    path={`/licenses/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetModuleLicenseByIdProps = Omit<
  UseGetProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    GetModuleLicenseByIdQueryParams,
    GetModuleLicenseByIdPathParams
  >,
  'path'
> &
  GetModuleLicenseByIdPathParams

/**
 * Gets Module License
 */
export const useGetModuleLicenseById = ({ identifier, ...props }: UseGetModuleLicenseByIdProps) =>
  useGet<ResponseModuleLicenseDTO, Failure | Error, GetModuleLicenseByIdQueryParams, GetModuleLicenseByIdPathParams>(
    (paramsInPath: GetModuleLicenseByIdPathParams) => `/licenses/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets Module License
 */
export const getModuleLicenseByIdPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseModuleLicenseDTO,
    Failure | Error,
    GetModuleLicenseByIdQueryParams,
    GetModuleLicenseByIdPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseModuleLicenseDTO,
    Failure | Error,
    GetModuleLicenseByIdQueryParams,
    GetModuleLicenseByIdPathParams
  >(getConfig('ng/api'), `/licenses/${identifier}`, props, signal)

export interface GetOrganizationListQueryParams {
  accountIdentifier: string
  identifiers?: string[]
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetOrganizationListProps = Omit<
  GetProps<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>,
  'path'
>

/**
 * Get Organization list
 */
export const GetOrganizationList = (props: GetOrganizationListProps) => (
  <Get<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>
    path={`/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationListProps = Omit<
  UseGetProps<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>,
  'path'
>

/**
 * Get Organization list
 */
export const useGetOrganizationList = (props: UseGetOrganizationListProps) =>
  useGet<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>(`/organizations`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Organization list
 */
export const getOrganizationListPromise = (
  props: GetUsingFetchProps<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageOrganizationResponse, Failure | Error, GetOrganizationListQueryParams, void>(
    getConfig('ng/api'),
    `/organizations`,
    props,
    signal
  )

export interface PostOrganizationQueryParams {
  accountIdentifier: string
}

export type PostOrganizationProps = Omit<
  MutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Organization
 */
export const PostOrganization = (props: PostOrganizationProps) => (
  <Mutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >
    verb="POST"
    path={`/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostOrganizationProps = Omit<
  UseMutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create an Organization
 */
export const usePostOrganization = (props: UsePostOrganizationProps) =>
  useMutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >('POST', `/organizations`, { base: getConfig('ng/api'), ...props })

/**
 * Create an Organization
 */
export const postOrganizationPromise = (
  props: MutateUsingFetchProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOrganizationResponse,
    Failure | Error,
    PostOrganizationQueryParams,
    OrganizationRequestRequestBody,
    void
  >('POST', getConfig('ng/api'), `/organizations`, props, signal)

export interface DeleteOrganizationQueryParams {
  accountIdentifier: string
}

export type DeleteOrganizationProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an Organization by identifier
 */
export const DeleteOrganization = (props: DeleteOrganizationProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>
    verb="DELETE"
    path={`/organizations`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteOrganizationProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete an Organization by identifier
 */
export const useDeleteOrganization = (props: UseDeleteOrganizationProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>('DELETE', `/organizations`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete an Organization by identifier
 */
export const deleteOrganizationPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteOrganizationQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/organizations`,
    props,
    signal
  )

export interface GetOrganizationQueryParams {
  accountIdentifier: string
}

export interface GetOrganizationPathParams {
  identifier: string
}

export type GetOrganizationProps = Omit<
  GetProps<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>,
  'path'
> &
  GetOrganizationPathParams

/**
 * Get an Organization by identifier
 */
export const GetOrganization = ({ identifier, ...props }: GetOrganizationProps) => (
  <Get<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>
    path={`/organizations/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetOrganizationProps = Omit<
  UseGetProps<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>,
  'path'
> &
  GetOrganizationPathParams

/**
 * Get an Organization by identifier
 */
export const useGetOrganization = ({ identifier, ...props }: UseGetOrganizationProps) =>
  useGet<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>(
    (paramsInPath: GetOrganizationPathParams) => `/organizations/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get an Organization by identifier
 */
export const getOrganizationPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseOrganizationResponse,
    Failure | Error,
    GetOrganizationQueryParams,
    GetOrganizationPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseOrganizationResponse, Failure | Error, GetOrganizationQueryParams, GetOrganizationPathParams>(
    getConfig('ng/api'),
    `/organizations/${identifier}`,
    props,
    signal
  )

export interface PutOrganizationQueryParams {
  accountIdentifier: string
}

export interface PutOrganizationPathParams {
  identifier: string
}

export type PutOrganizationProps = Omit<
  MutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >,
  'path' | 'verb'
> &
  PutOrganizationPathParams

/**
 * Update an Organization by ID
 */
export const PutOrganization = ({ identifier, ...props }: PutOrganizationProps) => (
  <Mutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >
    verb="PUT"
    path={`/organizations/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutOrganizationProps = Omit<
  UseMutateProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >,
  'path' | 'verb'
> &
  PutOrganizationPathParams

/**
 * Update an Organization by ID
 */
export const usePutOrganization = ({ identifier, ...props }: UsePutOrganizationProps) =>
  useMutate<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >('PUT', (paramsInPath: PutOrganizationPathParams) => `/organizations/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update an Organization by ID
 */
export const putOrganizationPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOrganizationResponse,
    Failure | Error,
    PutOrganizationQueryParams,
    OrganizationRequestRequestBody,
    PutOrganizationPathParams
  >('PUT', getConfig('ng/api'), `/organizations/${identifier}`, props, signal)

export interface GetPartialYamlSchemaQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type GetPartialYamlSchemaProps = Omit<
  GetProps<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema
 */
export const GetPartialYamlSchema = (props: GetPartialYamlSchemaProps) => (
  <Get<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>
    path={`/partial-yaml-schema`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPartialYamlSchemaProps = Omit<
  UseGetProps<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema
 */
export const useGetPartialYamlSchema = (props: UseGetPartialYamlSchemaProps) =>
  useGet<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>(`/partial-yaml-schema`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Partial Yaml Schema
 */
export const getPartialYamlSchemaPromise = (
  props: GetUsingFetchProps<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListPartialSchemaDTO, Failure | Error, GetPartialYamlSchemaQueryParams, void>(
    getConfig('ng/api'),
    `/partial-yaml-schema`,
    props,
    signal
  )

export interface GetPartialYamlSchemaWithDetailsQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type GetPartialYamlSchemaWithDetailsProps = Omit<
  GetProps<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema with details
 */
export const GetPartialYamlSchemaWithDetails = (props: GetPartialYamlSchemaWithDetailsProps) => (
  <Get<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>
    path={`/partial-yaml-schema/details`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetPartialYamlSchemaWithDetailsProps = Omit<
  UseGetProps<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>,
  'path'
>

/**
 * Get Partial Yaml Schema with details
 */
export const useGetPartialYamlSchemaWithDetails = (props: UseGetPartialYamlSchemaWithDetailsProps) =>
  useGet<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>(
    `/partial-yaml-schema/details`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Partial Yaml Schema with details
 */
export const getPartialYamlSchemaWithDetailsPromise = (
  props: GetUsingFetchProps<
    ResponseYamlSchemaDetailsWrapper,
    Failure | Error,
    GetPartialYamlSchemaWithDetailsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseYamlSchemaDetailsWrapper, Failure | Error, GetPartialYamlSchemaWithDetailsQueryParams, void>(
    getConfig('ng/api'),
    `/partial-yaml-schema/details`,
    props,
    signal
  )

export interface GetStepYamlSchemaQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
  entityType?:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  yamlGroup?: string
}

export type GetStepYamlSchemaProps = Omit<
  MutateProps<
    ResponseJsonNode,
    Failure | Error,
    GetStepYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get step YAML schema
 */
export const GetStepYamlSchema = (props: GetStepYamlSchemaProps) => (
  <Mutate<ResponseJsonNode, Failure | Error, GetStepYamlSchemaQueryParams, YamlSchemaDetailsWrapperRequestBody, void>
    verb="POST"
    path={`/partial-yaml-schema/get`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetStepYamlSchemaProps = Omit<
  UseMutateProps<
    ResponseJsonNode,
    Failure | Error,
    GetStepYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get step YAML schema
 */
export const useGetStepYamlSchema = (props: UseGetStepYamlSchemaProps) =>
  useMutate<ResponseJsonNode, Failure | Error, GetStepYamlSchemaQueryParams, YamlSchemaDetailsWrapperRequestBody, void>(
    'POST',
    `/partial-yaml-schema/get`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get step YAML schema
 */
export const getStepYamlSchemaPromise = (
  props: MutateUsingFetchProps<
    ResponseJsonNode,
    Failure | Error,
    GetStepYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseJsonNode,
    Failure | Error,
    GetStepYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >('POST', getConfig('ng/api'), `/partial-yaml-schema/get`, props, signal)

export interface GetMergedPartialYamlSchemaQueryParams {
  accountIdentifier: string
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export type GetMergedPartialYamlSchemaProps = Omit<
  MutateProps<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Merged Partial Yaml Schema
 */
export const GetMergedPartialYamlSchema = (props: GetMergedPartialYamlSchemaProps) => (
  <Mutate<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >
    verb="POST"
    path={`/partial-yaml-schema/merged`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetMergedPartialYamlSchemaProps = Omit<
  UseMutateProps<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Merged Partial Yaml Schema
 */
export const useGetMergedPartialYamlSchema = (props: UseGetMergedPartialYamlSchemaProps) =>
  useMutate<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >('POST', `/partial-yaml-schema/merged`, { base: getConfig('ng/api'), ...props })

/**
 * Get Merged Partial Yaml Schema
 */
export const getMergedPartialYamlSchemaPromise = (
  props: MutateUsingFetchProps<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListPartialSchemaDTO,
    Failure | Error,
    GetMergedPartialYamlSchemaQueryParams,
    YamlSchemaDetailsWrapperRequestBody,
    void
  >('POST', getConfig('ng/api'), `/partial-yaml-schema/merged`, props, signal)

export type GetProvisionerStepsProps = Omit<GetProps<ResponseStepCategory, Failure | Error, void, void>, 'path'>

/**
 * get provisioner steps
 */
export const GetProvisionerSteps = (props: GetProvisionerStepsProps) => (
  <Get<ResponseStepCategory, Failure | Error, void, void>
    path={`/pipelines/configuration/provisioner-steps`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProvisionerStepsProps = Omit<UseGetProps<ResponseStepCategory, Failure | Error, void, void>, 'path'>

/**
 * get provisioner steps
 */
export const useGetProvisionerSteps = (props: UseGetProvisionerStepsProps) =>
  useGet<ResponseStepCategory, Failure | Error, void, void>(`/pipelines/configuration/provisioner-steps`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get provisioner steps
 */
export const getProvisionerStepsPromise = (
  props: GetUsingFetchProps<ResponseStepCategory, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseStepCategory, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/provisioner-steps`,
    props,
    signal
  )

export type GetServiceDefinitionTypesProps = Omit<
  GetProps<ResponseListServiceDefinitionType, Failure | Error, void, void>,
  'path'
>

/**
 * Git list of service definition types
 */
export const GetServiceDefinitionTypes = (props: GetServiceDefinitionTypesProps) => (
  <Get<ResponseListServiceDefinitionType, Failure | Error, void, void>
    path={`/pipelines/configuration/serviceDefinitionTypes`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceDefinitionTypesProps = Omit<
  UseGetProps<ResponseListServiceDefinitionType, Failure | Error, void, void>,
  'path'
>

/**
 * Git list of service definition types
 */
export const useGetServiceDefinitionTypes = (props: UseGetServiceDefinitionTypesProps) =>
  useGet<ResponseListServiceDefinitionType, Failure | Error, void, void>(
    `/pipelines/configuration/serviceDefinitionTypes`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Git list of service definition types
 */
export const getServiceDefinitionTypesPromise = (
  props: GetUsingFetchProps<ResponseListServiceDefinitionType, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceDefinitionType, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/serviceDefinitionTypes`,
    props,
    signal
  )

export interface GetStepsQueryParams {
  serviceDefinitionType: 'Kubernetes' | 'NativeHelm'
}

export type GetStepsProps = Omit<GetProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>, 'path'>

/**
 * get steps for given service definition type
 */
export const GetSteps = (props: GetStepsProps) => (
  <Get<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>
    path={`/pipelines/configuration/steps`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetStepsProps = Omit<
  UseGetProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>,
  'path'
>

/**
 * get steps for given service definition type
 */
export const useGetSteps = (props: UseGetStepsProps) =>
  useGet<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>(`/pipelines/configuration/steps`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get steps for given service definition type
 */
export const getStepsPromise = (
  props: GetUsingFetchProps<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseStepCategory, Failure | Error, GetStepsQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/steps`,
    props,
    signal
  )

export type GetExecutionStrategyListProps = Omit<
  GetProps<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>,
  'path'
>

/**
 * Gets Execution Strategy list
 */
export const GetExecutionStrategyList = (props: GetExecutionStrategyListProps) => (
  <Get<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>
    path={`/pipelines/configuration/strategies`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStrategyListProps = Omit<
  UseGetProps<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>,
  'path'
>

/**
 * Gets Execution Strategy list
 */
export const useGetExecutionStrategyList = (props: UseGetExecutionStrategyListProps) =>
  useGet<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>(
    `/pipelines/configuration/strategies`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Execution Strategy list
 */
export const getExecutionStrategyListPromise = (
  props: GetUsingFetchProps<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseMapServiceDefinitionTypeListExecutionStrategyType, Failure | Error, void, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/strategies`,
    props,
    signal
  )

export interface GetProvisionerExecutionStrategyYamlQueryParams {
  provisionerType: 'TERRAFORM' | 'CLOUD_FORMATION' | 'AZURE_ARM' | 'SHELL_SCRIPT_PROVISIONER'
}

export type GetProvisionerExecutionStrategyYamlProps = Omit<
  GetProps<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on Provisioner Type
 */
export const GetProvisionerExecutionStrategyYaml = (props: GetProvisionerExecutionStrategyYamlProps) => (
  <Get<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>
    path={`/pipelines/configuration/strategies/provisioner-yaml-snippets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProvisionerExecutionStrategyYamlProps = Omit<
  UseGetProps<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on Provisioner Type
 */
export const useGetProvisionerExecutionStrategyYaml = (props: UseGetProvisionerExecutionStrategyYamlProps) =>
  useGet<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>(
    `/pipelines/configuration/strategies/provisioner-yaml-snippets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Yaml for Execution Strategy based on Provisioner Type
 */
export const getProvisionerExecutionStrategyYamlPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetProvisionerExecutionStrategyYamlQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/strategies/provisioner-yaml-snippets`,
    props,
    signal
  )

export interface GetExecutionStrategyYamlQueryParams {
  serviceDefinitionType: 'Kubernetes' | 'NativeHelm'
  strategyType: 'Basic' | 'Canary' | 'BlueGreen' | 'Rolling' | 'Default'
  includeVerify?: boolean
}

export type GetExecutionStrategyYamlProps = Omit<
  GetProps<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const GetExecutionStrategyYaml = (props: GetExecutionStrategyYamlProps) => (
  <Get<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>
    path={`/pipelines/configuration/strategies/yaml-snippets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetExecutionStrategyYamlProps = Omit<
  UseGetProps<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>,
  'path'
>

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const useGetExecutionStrategyYaml = (props: UseGetExecutionStrategyYamlProps) =>
  useGet<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>(
    `/pipelines/configuration/strategies/yaml-snippets`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Yaml for Execution Strategy based on deployment type and selected strategy
 */
export const getExecutionStrategyYamlPromise = (
  props: GetUsingFetchProps<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseString, Failure | Error, GetExecutionStrategyYamlQueryParams, void>(
    getConfig('ng/api'),
    `/pipelines/configuration/strategies/yaml-snippets`,
    props,
    signal
  )

export interface ProcessPollingResultNgQueryParams {
  accountId?: string
}

export interface ProcessPollingResultNgPathParams {
  perpetualTaskId: string
}

export type ProcessPollingResultNgProps = Omit<
  MutateProps<
    void,
    Failure | Error,
    ProcessPollingResultNgQueryParams,
    UnsubscribeBodyRequestBody,
    ProcessPollingResultNgPathParams
  >,
  'path' | 'verb'
> &
  ProcessPollingResultNgPathParams

export const ProcessPollingResultNg = ({ perpetualTaskId, ...props }: ProcessPollingResultNgProps) => (
  <Mutate<
    void,
    Failure | Error,
    ProcessPollingResultNgQueryParams,
    UnsubscribeBodyRequestBody,
    ProcessPollingResultNgPathParams
  >
    verb="POST"
    path={`/polling/delegate-response/${perpetualTaskId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseProcessPollingResultNgProps = Omit<
  UseMutateProps<
    void,
    Failure | Error,
    ProcessPollingResultNgQueryParams,
    UnsubscribeBodyRequestBody,
    ProcessPollingResultNgPathParams
  >,
  'path' | 'verb'
> &
  ProcessPollingResultNgPathParams

export const useProcessPollingResultNg = ({ perpetualTaskId, ...props }: UseProcessPollingResultNgProps) =>
  useMutate<
    void,
    Failure | Error,
    ProcessPollingResultNgQueryParams,
    UnsubscribeBodyRequestBody,
    ProcessPollingResultNgPathParams
  >(
    'POST',
    (paramsInPath: ProcessPollingResultNgPathParams) => `/polling/delegate-response/${paramsInPath.perpetualTaskId}`,
    { base: getConfig('ng/api'), pathParams: { perpetualTaskId }, ...props }
  )

export const processPollingResultNgPromise = (
  {
    perpetualTaskId,
    ...props
  }: MutateUsingFetchProps<
    void,
    Failure | Error,
    ProcessPollingResultNgQueryParams,
    UnsubscribeBodyRequestBody,
    ProcessPollingResultNgPathParams
  > & { perpetualTaskId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    void,
    Failure | Error,
    ProcessPollingResultNgQueryParams,
    UnsubscribeBodyRequestBody,
    ProcessPollingResultNgPathParams
  >('POST', getConfig('ng/api'), `/polling/delegate-response/${perpetualTaskId}`, props, signal)

export type SubscribeProps = Omit<
  MutateProps<ResponsePollingResponseDTO, Failure | Error, void, UnsubscribeBodyRequestBody, void>,
  'path' | 'verb'
>

export const Subscribe = (props: SubscribeProps) => (
  <Mutate<ResponsePollingResponseDTO, Failure | Error, void, UnsubscribeBodyRequestBody, void>
    verb="POST"
    path={`/polling/subscribe`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSubscribeProps = Omit<
  UseMutateProps<ResponsePollingResponseDTO, Failure | Error, void, UnsubscribeBodyRequestBody, void>,
  'path' | 'verb'
>

export const useSubscribe = (props: UseSubscribeProps) =>
  useMutate<ResponsePollingResponseDTO, Failure | Error, void, UnsubscribeBodyRequestBody, void>(
    'POST',
    `/polling/subscribe`,
    { base: getConfig('ng/api'), ...props }
  )

export const subscribePromise = (
  props: MutateUsingFetchProps<ResponsePollingResponseDTO, Failure | Error, void, UnsubscribeBodyRequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePollingResponseDTO, Failure | Error, void, UnsubscribeBodyRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/polling/subscribe`,
    props,
    signal
  )

export type UnsubscribeProps = Omit<
  MutateProps<boolean, Failure | Error, void, UnsubscribeBodyRequestBody, void>,
  'path' | 'verb'
>

export const Unsubscribe = (props: UnsubscribeProps) => (
  <Mutate<boolean, Failure | Error, void, UnsubscribeBodyRequestBody, void>
    verb="POST"
    path={`/polling/unsubscribe`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUnsubscribeProps = Omit<
  UseMutateProps<boolean, Failure | Error, void, UnsubscribeBodyRequestBody, void>,
  'path' | 'verb'
>

export const useUnsubscribe = (props: UseUnsubscribeProps) =>
  useMutate<boolean, Failure | Error, void, UnsubscribeBodyRequestBody, void>('POST', `/polling/unsubscribe`, {
    base: getConfig('ng/api'),
    ...props
  })

export const unsubscribePromise = (
  props: MutateUsingFetchProps<boolean, Failure | Error, void, UnsubscribeBodyRequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<boolean, Failure | Error, void, UnsubscribeBodyRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/polling/unsubscribe`,
    props,
    signal
  )

export interface GetProjectListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  hasModule?: boolean
  identifiers?: string[]
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetProjectListProps = Omit<
  GetProps<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const GetProjectList = (props: GetProjectListProps) => (
  <Get<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>
    path={`/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectListProps = Omit<
  UseGetProps<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const useGetProjectList = (props: UseGetProjectListProps) =>
  useGet<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>(`/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Project list
 */
export const getProjectListPromise = (
  props: GetUsingFetchProps<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProjectResponse, Failure | Error, GetProjectListQueryParams, void>(
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface PostProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export type PostProjectProps = Omit<
  MutateProps<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Project
 */
export const PostProject = (props: PostProjectProps) => (
  <Mutate<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>
    verb="POST"
    path={`/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostProjectProps = Omit<
  UseMutateProps<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Project
 */
export const usePostProject = (props: UsePostProjectProps) =>
  useMutate<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>(
    'POST',
    `/projects`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Project
 */
export const postProjectPromise = (
  props: MutateUsingFetchProps<
    ResponseProjectResponse,
    Failure | Error,
    PostProjectQueryParams,
    ProjectRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseProjectResponse, Failure | Error, PostProjectQueryParams, ProjectRequestRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface GetProjectListWithMultiOrgFilterQueryParams {
  accountIdentifier: string
  orgIdentifiers?: string[]
  hasModule?: boolean
  identifiers?: string[]
  moduleType?: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetProjectListWithMultiOrgFilterProps = Omit<
  GetProps<ResponsePageProjectResponse, Failure | Error, GetProjectListWithMultiOrgFilterQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const GetProjectListWithMultiOrgFilter = (props: GetProjectListWithMultiOrgFilterProps) => (
  <Get<ResponsePageProjectResponse, Failure | Error, GetProjectListWithMultiOrgFilterQueryParams, void>
    path={`/projects/list`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectListWithMultiOrgFilterProps = Omit<
  UseGetProps<ResponsePageProjectResponse, Failure | Error, GetProjectListWithMultiOrgFilterQueryParams, void>,
  'path'
>

/**
 * Get Project list
 */
export const useGetProjectListWithMultiOrgFilter = (props: UseGetProjectListWithMultiOrgFilterProps) =>
  useGet<ResponsePageProjectResponse, Failure | Error, GetProjectListWithMultiOrgFilterQueryParams, void>(
    `/projects/list`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Project list
 */
export const getProjectListWithMultiOrgFilterPromise = (
  props: GetUsingFetchProps<
    ResponsePageProjectResponse,
    Failure | Error,
    GetProjectListWithMultiOrgFilterQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProjectResponse, Failure | Error, GetProjectListWithMultiOrgFilterQueryParams, void>(
    getConfig('ng/api'),
    `/projects/list`,
    props,
    signal
  )

export interface DeleteProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export type DeleteProjectProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a Project by identifier
 */
export const DeleteProject = (props: DeleteProjectProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>
    verb="DELETE"
    path={`/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteProjectProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a Project by identifier
 */
export const useDeleteProject = (props: UseDeleteProjectProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>('DELETE', `/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a Project by identifier
 */
export const deleteProjectPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteProjectQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/projects`,
    props,
    signal
  )

export interface GetProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export interface GetProjectPathParams {
  identifier: string
}

export type GetProjectProps = Omit<
  GetProps<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>,
  'path'
> &
  GetProjectPathParams

/**
 * Gets a Project by ID
 */
export const GetProject = ({ identifier, ...props }: GetProjectProps) => (
  <Get<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>
    path={`/projects/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetProjectProps = Omit<
  UseGetProps<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>,
  'path'
> &
  GetProjectPathParams

/**
 * Gets a Project by ID
 */
export const useGetProject = ({ identifier, ...props }: UseGetProjectProps) =>
  useGet<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>(
    (paramsInPath: GetProjectPathParams) => `/projects/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets a Project by ID
 */
export const getProjectPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseProjectResponse, Failure | Error, GetProjectQueryParams, GetProjectPathParams>(
    getConfig('ng/api'),
    `/projects/${identifier}`,
    props,
    signal
  )

export interface PutProjectQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
}

export interface PutProjectPathParams {
  identifier: string
}

export type PutProjectProps = Omit<
  MutateProps<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >,
  'path' | 'verb'
> &
  PutProjectPathParams

/**
 * Update a Project by ID
 */
export const PutProject = ({ identifier, ...props }: PutProjectProps) => (
  <Mutate<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >
    verb="PUT"
    path={`/projects/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutProjectProps = Omit<
  UseMutateProps<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >,
  'path' | 'verb'
> &
  PutProjectPathParams

/**
 * Update a Project by ID
 */
export const usePutProject = ({ identifier, ...props }: UsePutProjectProps) =>
  useMutate<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >('PUT', (paramsInPath: PutProjectPathParams) => `/projects/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a Project by ID
 */
export const putProjectPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseProjectResponse,
    Failure | Error,
    PutProjectQueryParams,
    ProjectRequestRequestBody,
    PutProjectPathParams
  >('PUT', getConfig('ng/api'), `/projects/${identifier}`, props, signal)

export interface CreateRoleAssignmentQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateRoleAssignmentProps = Omit<
  MutateProps<ResponseRoleAssignmentResponse, Failure | Error, CreateRoleAssignmentQueryParams, RoleAssignment, void>,
  'path' | 'verb'
>

/**
 * (Stub) Create Role Assignment
 */
export const CreateRoleAssignment = (props: CreateRoleAssignmentProps) => (
  <Mutate<ResponseRoleAssignmentResponse, Failure | Error, CreateRoleAssignmentQueryParams, RoleAssignment, void>
    verb="POST"
    path={`/roleassignments`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateRoleAssignmentProps = Omit<
  UseMutateProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignment,
    void
  >,
  'path' | 'verb'
>

/**
 * (Stub) Create Role Assignment
 */
export const useCreateRoleAssignment = (props: UseCreateRoleAssignmentProps) =>
  useMutate<ResponseRoleAssignmentResponse, Failure | Error, CreateRoleAssignmentQueryParams, RoleAssignment, void>(
    'POST',
    `/roleassignments`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * (Stub) Create Role Assignment
 */
export const createRoleAssignmentPromise = (
  props: MutateUsingFetchProps<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignment,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentQueryParams,
    RoleAssignment,
    void
  >('POST', getConfig('ng/api'), `/roleassignments`, props, signal)

export interface GetRoleAssignmentsAggregateQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetRoleAssignmentsAggregateProps = Omit<
  MutateProps<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Role Assignments Aggregate
 */
export const GetRoleAssignmentsAggregate = (props: GetRoleAssignmentsAggregateProps) => (
  <Mutate<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >
    verb="POST"
    path={`/roleassignments/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetRoleAssignmentsAggregateProps = Omit<
  UseMutateProps<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Get Role Assignments Aggregate
 */
export const useGetRoleAssignmentsAggregate = (props: UseGetRoleAssignmentsAggregateProps) =>
  useMutate<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >('POST', `/roleassignments/aggregate`, { base: getConfig('ng/api'), ...props })

/**
 * Get Role Assignments Aggregate
 */
export const getRoleAssignmentsAggregatePromise = (
  props: MutateUsingFetchProps<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseRoleAssignmentAggregateResponse,
    Failure | Error,
    GetRoleAssignmentsAggregateQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >('POST', getConfig('ng/api'), `/roleassignments/aggregate`, props, signal)

export interface GetFilteredRoleAssignmentListQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetFilteredRoleAssignmentListProps = Omit<
  MutateProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * (Stub) Get Filtered Role Assignments
 */
export const GetFilteredRoleAssignmentList = (props: GetFilteredRoleAssignmentListProps) => (
  <Mutate<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >
    verb="POST"
    path={`/roleassignments/filter`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFilteredRoleAssignmentListProps = Omit<
  UseMutateProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * (Stub) Get Filtered Role Assignments
 */
export const useGetFilteredRoleAssignmentList = (props: UseGetFilteredRoleAssignmentListProps) =>
  useMutate<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >('POST', `/roleassignments/filter`, { base: getConfig('ng/api'), ...props })

/**
 * (Stub) Get Filtered Role Assignments
 */
export const getFilteredRoleAssignmentListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageRoleAssignmentResponse,
    Failure | Error,
    GetFilteredRoleAssignmentListQueryParams,
    RoleAssignmentFilterRequestBody,
    void
  >('POST', getConfig('ng/api'), `/roleassignments/filter`, props, signal)

export interface CreateRoleAssignmentsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  managed?: boolean
}

export type CreateRoleAssignmentsProps = Omit<
  MutateProps<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    RoleAssignmentCreateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * (Stub) Create Multiple Role Assignments
 */
export const CreateRoleAssignments = (props: CreateRoleAssignmentsProps) => (
  <Mutate<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    RoleAssignmentCreateRequest,
    void
  >
    verb="POST"
    path={`/roleassignments/multi/internal`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateRoleAssignmentsProps = Omit<
  UseMutateProps<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    RoleAssignmentCreateRequest,
    void
  >,
  'path' | 'verb'
>

/**
 * (Stub) Create Multiple Role Assignments
 */
export const useCreateRoleAssignments = (props: UseCreateRoleAssignmentsProps) =>
  useMutate<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    RoleAssignmentCreateRequest,
    void
  >('POST', `/roleassignments/multi/internal`, { base: getConfig('ng/api'), ...props })

/**
 * (Stub) Create Multiple Role Assignments
 */
export const createRoleAssignmentsPromise = (
  props: MutateUsingFetchProps<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    RoleAssignmentCreateRequest,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseListRoleAssignmentResponse,
    Failure | Error,
    CreateRoleAssignmentsQueryParams,
    RoleAssignmentCreateRequest,
    void
  >('POST', getConfig('ng/api'), `/roleassignments/multi/internal`, props, signal)

export interface SearchScimGroupQueryParams {
  filter?: string
  count?: number
  startIndex?: number
}

export interface SearchScimGroupPathParams {
  accountIdentifier: string
}

export type SearchScimGroupProps = Omit<
  GetProps<void, void, SearchScimGroupQueryParams, SearchScimGroupPathParams>,
  'path'
> &
  SearchScimGroupPathParams

/**
 * Search groups by their name. Supports pagination. If nothing is passed in filter, all results will be returned.
 */
export const SearchScimGroup = ({ accountIdentifier, ...props }: SearchScimGroupProps) => (
  <Get<void, void, SearchScimGroupQueryParams, SearchScimGroupPathParams>
    path={`/scim/account/${accountIdentifier}/Groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSearchScimGroupProps = Omit<
  UseGetProps<void, void, SearchScimGroupQueryParams, SearchScimGroupPathParams>,
  'path'
> &
  SearchScimGroupPathParams

/**
 * Search groups by their name. Supports pagination. If nothing is passed in filter, all results will be returned.
 */
export const useSearchScimGroup = ({ accountIdentifier, ...props }: UseSearchScimGroupProps) =>
  useGet<void, void, SearchScimGroupQueryParams, SearchScimGroupPathParams>(
    (paramsInPath: SearchScimGroupPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Groups`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Search groups by their name. Supports pagination. If nothing is passed in filter, all results will be returned.
 */
export const searchScimGroupPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<void, void, SearchScimGroupQueryParams, SearchScimGroupPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, SearchScimGroupQueryParams, SearchScimGroupPathParams>(
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Groups`,
    props,
    signal
  )

export interface CreateScimGroupPathParams {
  accountIdentifier: string
}

export type CreateScimGroupProps = Omit<
  MutateProps<void, void, void, ScimGroupRequestBody, CreateScimGroupPathParams>,
  'path' | 'verb'
> &
  CreateScimGroupPathParams

/**
 * Create a new group and return uuid in response
 */
export const CreateScimGroup = ({ accountIdentifier, ...props }: CreateScimGroupProps) => (
  <Mutate<void, void, void, ScimGroupRequestBody, CreateScimGroupPathParams>
    verb="POST"
    path={`/scim/account/${accountIdentifier}/Groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateScimGroupProps = Omit<
  UseMutateProps<void, void, void, ScimGroupRequestBody, CreateScimGroupPathParams>,
  'path' | 'verb'
> &
  CreateScimGroupPathParams

/**
 * Create a new group and return uuid in response
 */
export const useCreateScimGroup = ({ accountIdentifier, ...props }: UseCreateScimGroupProps) =>
  useMutate<void, void, void, ScimGroupRequestBody, CreateScimGroupPathParams>(
    'POST',
    (paramsInPath: CreateScimGroupPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Groups`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Create a new group and return uuid in response
 */
export const createScimGroupPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<void, void, void, ScimGroupRequestBody, CreateScimGroupPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, void, ScimGroupRequestBody, CreateScimGroupPathParams>(
    'POST',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Groups`,
    props,
    signal
  )

export interface DeleteScimGroupPathParams {
  accountIdentifier: string
}

export type DeleteScimGroupProps = Omit<
  MutateProps<void, void, void, string, DeleteScimGroupPathParams>,
  'path' | 'verb'
> &
  DeleteScimGroupPathParams

/**
 * Delete an existing user by uuid
 */
export const DeleteScimGroup = ({ accountIdentifier, ...props }: DeleteScimGroupProps) => (
  <Mutate<void, void, void, string, DeleteScimGroupPathParams>
    verb="DELETE"
    path={`/scim/account/${accountIdentifier}/Groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteScimGroupProps = Omit<
  UseMutateProps<void, void, void, string, DeleteScimGroupPathParams>,
  'path' | 'verb'
> &
  DeleteScimGroupPathParams

/**
 * Delete an existing user by uuid
 */
export const useDeleteScimGroup = ({ accountIdentifier, ...props }: UseDeleteScimGroupProps) =>
  useMutate<void, void, void, string, DeleteScimGroupPathParams>(
    'DELETE',
    (paramsInPath: DeleteScimGroupPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Groups`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Delete an existing user by uuid
 */
export const deleteScimGroupPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<void, void, void, string, DeleteScimGroupPathParams> & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, void, string, DeleteScimGroupPathParams>(
    'DELETE',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Groups`,
    props,
    signal
  )

export interface GetScimGroupPathParams {
  accountIdentifier: string
  groupIdentifier: string
}

export type GetScimGroupProps = Omit<GetProps<void, void, void, GetScimGroupPathParams>, 'path'> &
  GetScimGroupPathParams

/**
 * Fetch an existing user by uuid
 */
export const GetScimGroup = ({ accountIdentifier, groupIdentifier, ...props }: GetScimGroupProps) => (
  <Get<void, void, void, GetScimGroupPathParams>
    path={`/scim/account/${accountIdentifier}/Groups/${groupIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetScimGroupProps = Omit<UseGetProps<void, void, void, GetScimGroupPathParams>, 'path'> &
  GetScimGroupPathParams

/**
 * Fetch an existing user by uuid
 */
export const useGetScimGroup = ({ accountIdentifier, groupIdentifier, ...props }: UseGetScimGroupProps) =>
  useGet<void, void, void, GetScimGroupPathParams>(
    (paramsInPath: GetScimGroupPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/Groups/${paramsInPath.groupIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier, groupIdentifier }, ...props }
  )

/**
 * Fetch an existing user by uuid
 */
export const getScimGroupPromise = (
  {
    accountIdentifier,
    groupIdentifier,
    ...props
  }: GetUsingFetchProps<void, void, void, GetScimGroupPathParams> & {
    accountIdentifier: string
    groupIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, void, GetScimGroupPathParams>(
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Groups/${groupIdentifier}`,
    props,
    signal
  )

export interface PatchScimGroupPathParams {
  accountIdentifier: string
  groupIdentifier: string
}

export type PatchScimGroupProps = Omit<
  MutateProps<void, void, void, PatchRequestRequestBody, PatchScimGroupPathParams>,
  'path' | 'verb'
> &
  PatchScimGroupPathParams

/**
 * Update some fields of a groups by uuid. Can update members/name
 */
export const PatchScimGroup = ({ accountIdentifier, groupIdentifier, ...props }: PatchScimGroupProps) => (
  <Mutate<void, void, void, PatchRequestRequestBody, PatchScimGroupPathParams>
    verb="PATCH"
    path={`/scim/account/${accountIdentifier}/Groups/${groupIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePatchScimGroupProps = Omit<
  UseMutateProps<void, void, void, PatchRequestRequestBody, PatchScimGroupPathParams>,
  'path' | 'verb'
> &
  PatchScimGroupPathParams

/**
 * Update some fields of a groups by uuid. Can update members/name
 */
export const usePatchScimGroup = ({ accountIdentifier, groupIdentifier, ...props }: UsePatchScimGroupProps) =>
  useMutate<void, void, void, PatchRequestRequestBody, PatchScimGroupPathParams>(
    'PATCH',
    (paramsInPath: PatchScimGroupPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/Groups/${paramsInPath.groupIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier, groupIdentifier }, ...props }
  )

/**
 * Update some fields of a groups by uuid. Can update members/name
 */
export const patchScimGroupPromise = (
  {
    accountIdentifier,
    groupIdentifier,
    ...props
  }: MutateUsingFetchProps<void, void, void, PatchRequestRequestBody, PatchScimGroupPathParams> & {
    accountIdentifier: string
    groupIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, void, PatchRequestRequestBody, PatchScimGroupPathParams>(
    'PATCH',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Groups/${groupIdentifier}`,
    props,
    signal
  )

export interface UpdateScimGroupPathParams {
  accountIdentifier: string
  groupIdentifier: string
}

export type UpdateScimGroupProps = Omit<
  MutateProps<void, void, void, ScimGroupRequestBody, UpdateScimGroupPathParams>,
  'path' | 'verb'
> &
  UpdateScimGroupPathParams

/**
 * Update a group
 */
export const UpdateScimGroup = ({ accountIdentifier, groupIdentifier, ...props }: UpdateScimGroupProps) => (
  <Mutate<void, void, void, ScimGroupRequestBody, UpdateScimGroupPathParams>
    verb="PUT"
    path={`/scim/account/${accountIdentifier}/Groups/${groupIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateScimGroupProps = Omit<
  UseMutateProps<void, void, void, ScimGroupRequestBody, UpdateScimGroupPathParams>,
  'path' | 'verb'
> &
  UpdateScimGroupPathParams

/**
 * Update a group
 */
export const useUpdateScimGroup = ({ accountIdentifier, groupIdentifier, ...props }: UseUpdateScimGroupProps) =>
  useMutate<void, void, void, ScimGroupRequestBody, UpdateScimGroupPathParams>(
    'PUT',
    (paramsInPath: UpdateScimGroupPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/Groups/${paramsInPath.groupIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier, groupIdentifier }, ...props }
  )

/**
 * Update a group
 */
export const updateScimGroupPromise = (
  {
    accountIdentifier,
    groupIdentifier,
    ...props
  }: MutateUsingFetchProps<void, void, void, ScimGroupRequestBody, UpdateScimGroupPathParams> & {
    accountIdentifier: string
    groupIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, void, ScimGroupRequestBody, UpdateScimGroupPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Groups/${groupIdentifier}`,
    props,
    signal
  )

export interface SearchScimUserQueryParams {
  filter?: string
  count?: number
  startIndex?: number
}

export interface SearchScimUserPathParams {
  accountIdentifier: string
}

export type SearchScimUserProps = Omit<
  GetProps<void, void, SearchScimUserQueryParams, SearchScimUserPathParams>,
  'path'
> &
  SearchScimUserPathParams

/**
 * Search users by their email address. Supports pagination. If nothing is passed in filter, all results will be returned.
 */
export const SearchScimUser = ({ accountIdentifier, ...props }: SearchScimUserProps) => (
  <Get<void, void, SearchScimUserQueryParams, SearchScimUserPathParams>
    path={`/scim/account/${accountIdentifier}/Users`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSearchScimUserProps = Omit<
  UseGetProps<void, void, SearchScimUserQueryParams, SearchScimUserPathParams>,
  'path'
> &
  SearchScimUserPathParams

/**
 * Search users by their email address. Supports pagination. If nothing is passed in filter, all results will be returned.
 */
export const useSearchScimUser = ({ accountIdentifier, ...props }: UseSearchScimUserProps) =>
  useGet<void, void, SearchScimUserQueryParams, SearchScimUserPathParams>(
    (paramsInPath: SearchScimUserPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Users`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Search users by their email address. Supports pagination. If nothing is passed in filter, all results will be returned.
 */
export const searchScimUserPromise = (
  {
    accountIdentifier,
    ...props
  }: GetUsingFetchProps<void, void, SearchScimUserQueryParams, SearchScimUserPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, SearchScimUserQueryParams, SearchScimUserPathParams>(
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Users`,
    props,
    signal
  )

export interface CreateScimUserPathParams {
  accountIdentifier: string
}

export type CreateScimUserProps = Omit<
  MutateProps<void, void, void, ScimUserRequestBody, CreateScimUserPathParams>,
  'path' | 'verb'
> &
  CreateScimUserPathParams

/**
 * Create a new user
 */
export const CreateScimUser = ({ accountIdentifier, ...props }: CreateScimUserProps) => (
  <Mutate<void, void, void, ScimUserRequestBody, CreateScimUserPathParams>
    verb="POST"
    path={`/scim/account/${accountIdentifier}/Users`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateScimUserProps = Omit<
  UseMutateProps<void, void, void, ScimUserRequestBody, CreateScimUserPathParams>,
  'path' | 'verb'
> &
  CreateScimUserPathParams

/**
 * Create a new user
 */
export const useCreateScimUser = ({ accountIdentifier, ...props }: UseCreateScimUserProps) =>
  useMutate<void, void, void, ScimUserRequestBody, CreateScimUserPathParams>(
    'POST',
    (paramsInPath: CreateScimUserPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Users`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Create a new user
 */
export const createScimUserPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<void, void, void, ScimUserRequestBody, CreateScimUserPathParams> & {
    accountIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, void, ScimUserRequestBody, CreateScimUserPathParams>(
    'POST',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Users`,
    props,
    signal
  )

export interface DeleteScimUserPathParams {
  accountIdentifier: string
}

export type DeleteScimUserProps = Omit<
  MutateProps<void, void, void, string, DeleteScimUserPathParams>,
  'path' | 'verb'
> &
  DeleteScimUserPathParams

/**
 * Delete an user by uuid
 */
export const DeleteScimUser = ({ accountIdentifier, ...props }: DeleteScimUserProps) => (
  <Mutate<void, void, void, string, DeleteScimUserPathParams>
    verb="DELETE"
    path={`/scim/account/${accountIdentifier}/Users`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteScimUserProps = Omit<
  UseMutateProps<void, void, void, string, DeleteScimUserPathParams>,
  'path' | 'verb'
> &
  DeleteScimUserPathParams

/**
 * Delete an user by uuid
 */
export const useDeleteScimUser = ({ accountIdentifier, ...props }: UseDeleteScimUserProps) =>
  useMutate<void, void, void, string, DeleteScimUserPathParams>(
    'DELETE',
    (paramsInPath: DeleteScimUserPathParams) => `/scim/account/${paramsInPath.accountIdentifier}/Users`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier }, ...props }
  )

/**
 * Delete an user by uuid
 */
export const deleteScimUserPromise = (
  {
    accountIdentifier,
    ...props
  }: MutateUsingFetchProps<void, void, void, string, DeleteScimUserPathParams> & { accountIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, void, string, DeleteScimUserPathParams>(
    'DELETE',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Users`,
    props,
    signal
  )

export interface GetScimUserPathParams {
  accountIdentifier: string
  userIdentifier: string
}

export type GetScimUserProps = Omit<GetProps<void, void, void, GetScimUserPathParams>, 'path'> & GetScimUserPathParams

/**
 * Get an existing user by uuid
 */
export const GetScimUser = ({ accountIdentifier, userIdentifier, ...props }: GetScimUserProps) => (
  <Get<void, void, void, GetScimUserPathParams>
    path={`/scim/account/${accountIdentifier}/Users/${userIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetScimUserProps = Omit<UseGetProps<void, void, void, GetScimUserPathParams>, 'path'> &
  GetScimUserPathParams

/**
 * Get an existing user by uuid
 */
export const useGetScimUser = ({ accountIdentifier, userIdentifier, ...props }: UseGetScimUserProps) =>
  useGet<void, void, void, GetScimUserPathParams>(
    (paramsInPath: GetScimUserPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/Users/${paramsInPath.userIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier, userIdentifier }, ...props }
  )

/**
 * Get an existing user by uuid
 */
export const getScimUserPromise = (
  {
    accountIdentifier,
    userIdentifier,
    ...props
  }: GetUsingFetchProps<void, void, void, GetScimUserPathParams> & {
    accountIdentifier: string
    userIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, void, GetScimUserPathParams>(
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Users/${userIdentifier}`,
    props,
    signal
  )

export interface PatchScimUserPathParams {
  accountIdentifier: string
  userIdentifier: string
}

export type PatchScimUserProps = Omit<
  MutateProps<void, void, void, PatchRequestRequestBody, PatchScimUserPathParams>,
  'path' | 'verb'
> &
  PatchScimUserPathParams

/**
 * Update some fields of a user by uuid
 */
export const PatchScimUser = ({ accountIdentifier, userIdentifier, ...props }: PatchScimUserProps) => (
  <Mutate<void, void, void, PatchRequestRequestBody, PatchScimUserPathParams>
    verb="PATCH"
    path={`/scim/account/${accountIdentifier}/Users/${userIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePatchScimUserProps = Omit<
  UseMutateProps<void, void, void, PatchRequestRequestBody, PatchScimUserPathParams>,
  'path' | 'verb'
> &
  PatchScimUserPathParams

/**
 * Update some fields of a user by uuid
 */
export const usePatchScimUser = ({ accountIdentifier, userIdentifier, ...props }: UsePatchScimUserProps) =>
  useMutate<void, void, void, PatchRequestRequestBody, PatchScimUserPathParams>(
    'PATCH',
    (paramsInPath: PatchScimUserPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/Users/${paramsInPath.userIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier, userIdentifier }, ...props }
  )

/**
 * Update some fields of a user by uuid
 */
export const patchScimUserPromise = (
  {
    accountIdentifier,
    userIdentifier,
    ...props
  }: MutateUsingFetchProps<void, void, void, PatchRequestRequestBody, PatchScimUserPathParams> & {
    accountIdentifier: string
    userIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, void, PatchRequestRequestBody, PatchScimUserPathParams>(
    'PATCH',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Users/${userIdentifier}`,
    props,
    signal
  )

export interface UpdateScimUserPathParams {
  accountIdentifier: string
  userIdentifier: string
}

export type UpdateScimUserProps = Omit<
  MutateProps<void, void, void, ScimUserRequestBody, UpdateScimUserPathParams>,
  'path' | 'verb'
> &
  UpdateScimUserPathParams

/**
 * Update an existing user by uuid
 */
export const UpdateScimUser = ({ accountIdentifier, userIdentifier, ...props }: UpdateScimUserProps) => (
  <Mutate<void, void, void, ScimUserRequestBody, UpdateScimUserPathParams>
    verb="PUT"
    path={`/scim/account/${accountIdentifier}/Users/${userIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateScimUserProps = Omit<
  UseMutateProps<void, void, void, ScimUserRequestBody, UpdateScimUserPathParams>,
  'path' | 'verb'
> &
  UpdateScimUserPathParams

/**
 * Update an existing user by uuid
 */
export const useUpdateScimUser = ({ accountIdentifier, userIdentifier, ...props }: UseUpdateScimUserProps) =>
  useMutate<void, void, void, ScimUserRequestBody, UpdateScimUserPathParams>(
    'PUT',
    (paramsInPath: UpdateScimUserPathParams) =>
      `/scim/account/${paramsInPath.accountIdentifier}/Users/${paramsInPath.userIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountIdentifier, userIdentifier }, ...props }
  )

/**
 * Update an existing user by uuid
 */
export const updateScimUserPromise = (
  {
    accountIdentifier,
    userIdentifier,
    ...props
  }: MutateUsingFetchProps<void, void, void, ScimUserRequestBody, UpdateScimUserPathParams> & {
    accountIdentifier: string
    userIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<void, void, void, ScimUserRequestBody, UpdateScimUserPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/scim/account/${accountIdentifier}/Users/${userIdentifier}`,
    props,
    signal
  )

export type CreatePRProps = Omit<
  MutateProps<ResponseCreatePRDTO, Failure | Error, void, GitPRCreateRequest, void>,
  'path' | 'verb'
>

/**
 * creates a pull request
 */
export const CreatePR = (props: CreatePRProps) => (
  <Mutate<ResponseCreatePRDTO, Failure | Error, void, GitPRCreateRequest, void>
    verb="POST"
    path={`/scm/createPR`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreatePRProps = Omit<
  UseMutateProps<ResponseCreatePRDTO, Failure | Error, void, GitPRCreateRequest, void>,
  'path' | 'verb'
>

/**
 * creates a pull request
 */
export const useCreatePR = (props: UseCreatePRProps) =>
  useMutate<ResponseCreatePRDTO, Failure | Error, void, GitPRCreateRequest, void>('POST', `/scm/createPR`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * creates a pull request
 */
export const createPRPromise = (
  props: MutateUsingFetchProps<ResponseCreatePRDTO, Failure | Error, void, GitPRCreateRequest, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseCreatePRDTO, Failure | Error, void, GitPRCreateRequest, void>(
    'POST',
    getConfig('ng/api'),
    `/scm/createPR`,
    props,
    signal
  )

export interface GetFileContentQueryParams {
  yamlGitConfigIdentifier: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  filePath: string
  branch?: string
  commitId?: string
}

export type GetFileContentProps = Omit<
  GetProps<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>,
  'path'
>

/**
 * Gets file content
 */
export const GetFileContent = (props: GetFileContentProps) => (
  <Get<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>
    path={`/scm/fileContent`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetFileContentProps = Omit<
  UseGetProps<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>,
  'path'
>

/**
 * Gets file content
 */
export const useGetFileContent = (props: UseGetFileContentProps) =>
  useGet<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>(`/scm/fileContent`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets file content
 */
export const getFileContentPromise = (
  props: GetUsingFetchProps<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseGitFileContent, Failure | Error, GetFileContentQueryParams, void>(
    getConfig('ng/api'),
    `/scm/fileContent`,
    props,
    signal
  )

export interface IsSaasGitQueryParams {
  repoURL?: string
}

export type IsSaasGitProps = Omit<
  MutateProps<ResponseSaasGitDTO, Failure | Error, IsSaasGitQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Checks if Saas is possible
 */
export const IsSaasGit = (props: IsSaasGitProps) => (
  <Mutate<ResponseSaasGitDTO, Failure | Error, IsSaasGitQueryParams, void, void>
    verb="POST"
    path={`/scm/isSaasGit`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseIsSaasGitProps = Omit<
  UseMutateProps<ResponseSaasGitDTO, Failure | Error, IsSaasGitQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Checks if Saas is possible
 */
export const useIsSaasGit = (props: UseIsSaasGitProps) =>
  useMutate<ResponseSaasGitDTO, Failure | Error, IsSaasGitQueryParams, void, void>('POST', `/scm/isSaasGit`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Checks if Saas is possible
 */
export const isSaasGitPromise = (
  props: MutateUsingFetchProps<ResponseSaasGitDTO, Failure | Error, IsSaasGitQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseSaasGitDTO, Failure | Error, IsSaasGitQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/scm/isSaasGit`,
    props,
    signal
  )

export interface GetListOfBranchesByGitConfigQueryParams {
  yamlGitConfigIdentifier?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  page?: number
  size?: number
  searchTerm?: string
}

export type GetListOfBranchesByGitConfigProps = Omit<
  GetProps<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>,
  'path'
>

/**
 * Retrieves a list of Git Branches corresponding to a Git Sync Config Id
 */
export const GetListOfBranchesByGitConfig = (props: GetListOfBranchesByGitConfigProps) => (
  <Get<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>
    path={`/scm/listBranchesByGitConfig`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfBranchesByGitConfigProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>,
  'path'
>

/**
 * Retrieves a list of Git Branches corresponding to a Git Sync Config Id
 */
export const useGetListOfBranchesByGitConfig = (props: UseGetListOfBranchesByGitConfigProps) =>
  useGet<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>(
    `/scm/listBranchesByGitConfig`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Retrieves a list of Git Branches corresponding to a Git Sync Config Id
 */
export const getListOfBranchesByGitConfigPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, GetListOfBranchesByGitConfigQueryParams, void>(
    getConfig('ng/api'),
    `/scm/listBranchesByGitConfig`,
    props,
    signal
  )

export interface GetListOfBranchesByConnectorQueryParams {
  connectorIdentifierRef?: string
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
  repoURL?: string
  page?: number
  size?: number
  searchTerm?: string
}

export type GetListOfBranchesByConnectorProps = Omit<
  GetProps<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>,
  'path'
>

/**
 * Gets list of branches by Connector Identifier
 */
export const GetListOfBranchesByConnector = (props: GetListOfBranchesByConnectorProps) => (
  <Get<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>
    path={`/scm/listRepoBranches`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetListOfBranchesByConnectorProps = Omit<
  UseGetProps<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>,
  'path'
>

/**
 * Gets list of branches by Connector Identifier
 */
export const useGetListOfBranchesByConnector = (props: UseGetListOfBranchesByConnectorProps) =>
  useGet<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>(`/scm/listRepoBranches`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets list of branches by Connector Identifier
 */
export const getListOfBranchesByConnectorPromise = (
  props: GetUsingFetchProps<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListString, Failure | Error, GetListOfBranchesByConnectorQueryParams, void>(
    getConfig('ng/api'),
    `/scm/listRepoBranches`,
    props,
    signal
  )

export interface GetMetadataQueryParams {
  accountIdentifier: string
}

export type GetMetadataProps = Omit<
  MutateProps<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get metadata of secret manager
 */
export const GetMetadata = (props: GetMetadataProps) => (
  <Mutate<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >
    verb="POST"
    path={`/secret-managers/meta-data`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetMetadataProps = Omit<
  UseMutateProps<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get metadata of secret manager
 */
export const useGetMetadata = (props: UseGetMetadataProps) =>
  useMutate<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >('POST', `/secret-managers/meta-data`, { base: getConfig('ng/api'), ...props })

/**
 * Get metadata of secret manager
 */
export const getMetadataPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretManagerMetadataDTO,
    Failure | Error,
    GetMetadataQueryParams,
    SecretManagerMetadataRequestDTO,
    void
  >('POST', getConfig('ng/api'), `/secret-managers/meta-data`, props, signal)

export interface ListServiceAccountQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifiers?: string[]
}

export type ListServiceAccountProps = Omit<
  GetProps<ResponseListServiceAccountDTO, Failure | Error, ListServiceAccountQueryParams, void>,
  'path'
>

/**
 * List service account
 */
export const ListServiceAccount = (props: ListServiceAccountProps) => (
  <Get<ResponseListServiceAccountDTO, Failure | Error, ListServiceAccountQueryParams, void>
    path={`/serviceaccount`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListServiceAccountProps = Omit<
  UseGetProps<ResponseListServiceAccountDTO, Failure | Error, ListServiceAccountQueryParams, void>,
  'path'
>

/**
 * List service account
 */
export const useListServiceAccount = (props: UseListServiceAccountProps) =>
  useGet<ResponseListServiceAccountDTO, Failure | Error, ListServiceAccountQueryParams, void>(`/serviceaccount`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List service account
 */
export const listServiceAccountPromise = (
  props: GetUsingFetchProps<ResponseListServiceAccountDTO, Failure | Error, ListServiceAccountQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceAccountDTO, Failure | Error, ListServiceAccountQueryParams, void>(
    getConfig('ng/api'),
    `/serviceaccount`,
    props,
    signal
  )

export interface CreateServiceAccountQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateServiceAccountProps = Omit<
  MutateProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    CreateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create service account
 */
export const CreateServiceAccount = (props: CreateServiceAccountProps) => (
  <Mutate<
    ResponseServiceAccountDTO,
    Failure | Error,
    CreateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    void
  >
    verb="POST"
    path={`/serviceaccount`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServiceAccountProps = Omit<
  UseMutateProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    CreateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create service account
 */
export const useCreateServiceAccount = (props: UseCreateServiceAccountProps) =>
  useMutate<
    ResponseServiceAccountDTO,
    Failure | Error,
    CreateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    void
  >('POST', `/serviceaccount`, { base: getConfig('ng/api'), ...props })

/**
 * Create service account
 */
export const createServiceAccountPromise = (
  props: MutateUsingFetchProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    CreateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceAccountDTO,
    Failure | Error,
    CreateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/serviceaccount`, props, signal)

export interface ListAggregatedServiceAccountsQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifiers?: string[]
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  searchTerm?: string
}

export type ListAggregatedServiceAccountsProps = Omit<
  GetProps<ResponsePageServiceAccountAggregateDTO, Failure | Error, ListAggregatedServiceAccountsQueryParams, void>,
  'path'
>

/**
 * List service account
 */
export const ListAggregatedServiceAccounts = (props: ListAggregatedServiceAccountsProps) => (
  <Get<ResponsePageServiceAccountAggregateDTO, Failure | Error, ListAggregatedServiceAccountsQueryParams, void>
    path={`/serviceaccount/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListAggregatedServiceAccountsProps = Omit<
  UseGetProps<ResponsePageServiceAccountAggregateDTO, Failure | Error, ListAggregatedServiceAccountsQueryParams, void>,
  'path'
>

/**
 * List service account
 */
export const useListAggregatedServiceAccounts = (props: UseListAggregatedServiceAccountsProps) =>
  useGet<ResponsePageServiceAccountAggregateDTO, Failure | Error, ListAggregatedServiceAccountsQueryParams, void>(
    `/serviceaccount/aggregate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * List service account
 */
export const listAggregatedServiceAccountsPromise = (
  props: GetUsingFetchProps<
    ResponsePageServiceAccountAggregateDTO,
    Failure | Error,
    ListAggregatedServiceAccountsQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageServiceAccountAggregateDTO,
    Failure | Error,
    ListAggregatedServiceAccountsQueryParams,
    void
  >(getConfig('ng/api'), `/serviceaccount/aggregate`, props, signal)

export interface GetAggregatedServiceAccountQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetAggregatedServiceAccountPathParams {
  identifier: string
}

export type GetAggregatedServiceAccountProps = Omit<
  GetProps<
    ResponseServiceAccountAggregateDTO,
    Failure | Error,
    GetAggregatedServiceAccountQueryParams,
    GetAggregatedServiceAccountPathParams
  >,
  'path'
> &
  GetAggregatedServiceAccountPathParams

/**
 * Get service account
 */
export const GetAggregatedServiceAccount = ({ identifier, ...props }: GetAggregatedServiceAccountProps) => (
  <Get<
    ResponseServiceAccountAggregateDTO,
    Failure | Error,
    GetAggregatedServiceAccountQueryParams,
    GetAggregatedServiceAccountPathParams
  >
    path={`/serviceaccount/aggregate/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAggregatedServiceAccountProps = Omit<
  UseGetProps<
    ResponseServiceAccountAggregateDTO,
    Failure | Error,
    GetAggregatedServiceAccountQueryParams,
    GetAggregatedServiceAccountPathParams
  >,
  'path'
> &
  GetAggregatedServiceAccountPathParams

/**
 * Get service account
 */
export const useGetAggregatedServiceAccount = ({ identifier, ...props }: UseGetAggregatedServiceAccountProps) =>
  useGet<
    ResponseServiceAccountAggregateDTO,
    Failure | Error,
    GetAggregatedServiceAccountQueryParams,
    GetAggregatedServiceAccountPathParams
  >((paramsInPath: GetAggregatedServiceAccountPathParams) => `/serviceaccount/aggregate/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Get service account
 */
export const getAggregatedServiceAccountPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseServiceAccountAggregateDTO,
    Failure | Error,
    GetAggregatedServiceAccountQueryParams,
    GetAggregatedServiceAccountPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseServiceAccountAggregateDTO,
    Failure | Error,
    GetAggregatedServiceAccountQueryParams,
    GetAggregatedServiceAccountPathParams
  >(getConfig('ng/api'), `/serviceaccount/aggregate/${identifier}`, props, signal)

export interface DeleteServiceAccountQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteServiceAccountProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteServiceAccountQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete service account
 */
export const DeleteServiceAccount = (props: DeleteServiceAccountProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteServiceAccountQueryParams, string, void>
    verb="DELETE"
    path={`/serviceaccount`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteServiceAccountProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteServiceAccountQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete service account
 */
export const useDeleteServiceAccount = (props: UseDeleteServiceAccountProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteServiceAccountQueryParams, string, void>(
    'DELETE',
    `/serviceaccount`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete service account
 */
export const deleteServiceAccountPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteServiceAccountQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteServiceAccountQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/serviceaccount`,
    props,
    signal
  )

export interface UpdateServiceAccountQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UpdateServiceAccountPathParams {
  identifier: string
}

export type UpdateServiceAccountProps = Omit<
  MutateProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    UpdateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    UpdateServiceAccountPathParams
  >,
  'path' | 'verb'
> &
  UpdateServiceAccountPathParams

/**
 * Update service account
 */
export const UpdateServiceAccount = ({ identifier, ...props }: UpdateServiceAccountProps) => (
  <Mutate<
    ResponseServiceAccountDTO,
    Failure | Error,
    UpdateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    UpdateServiceAccountPathParams
  >
    verb="PUT"
    path={`/serviceaccount/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateServiceAccountProps = Omit<
  UseMutateProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    UpdateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    UpdateServiceAccountPathParams
  >,
  'path' | 'verb'
> &
  UpdateServiceAccountPathParams

/**
 * Update service account
 */
export const useUpdateServiceAccount = ({ identifier, ...props }: UseUpdateServiceAccountProps) =>
  useMutate<
    ResponseServiceAccountDTO,
    Failure | Error,
    UpdateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    UpdateServiceAccountPathParams
  >('PUT', (paramsInPath: UpdateServiceAccountPathParams) => `/serviceaccount/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update service account
 */
export const updateServiceAccountPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseServiceAccountDTO,
    Failure | Error,
    UpdateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    UpdateServiceAccountPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceAccountDTO,
    Failure | Error,
    UpdateServiceAccountQueryParams,
    ServiceAccountDTORequestBody,
    UpdateServiceAccountPathParams
  >('PUT', getConfig('ng/api'), `/serviceaccount/${identifier}`, props, signal)

export interface GetServiceNowIssueCreateMetadataQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  ticketType?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetServiceNowIssueCreateMetadataProps = Omit<
  GetProps<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueCreateMetadataQueryParams, void>,
  'path'
>

/**
 * Get ServiceNow issue create metadata
 */
export const GetServiceNowIssueCreateMetadata = (props: GetServiceNowIssueCreateMetadataProps) => (
  <Get<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueCreateMetadataQueryParams, void>
    path={`/servicenow/createMetadata`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceNowIssueCreateMetadataProps = Omit<
  UseGetProps<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueCreateMetadataQueryParams, void>,
  'path'
>

/**
 * Get ServiceNow issue create metadata
 */
export const useGetServiceNowIssueCreateMetadata = (props: UseGetServiceNowIssueCreateMetadataProps) =>
  useGet<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueCreateMetadataQueryParams, void>(
    `/servicenow/createMetadata`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get ServiceNow issue create metadata
 */
export const getServiceNowIssueCreateMetadataPromise = (
  props: GetUsingFetchProps<
    ResponseListServiceNowFieldNG,
    Failure | Error,
    GetServiceNowIssueCreateMetadataQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceNowFieldNG, Failure | Error, GetServiceNowIssueCreateMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/servicenow/createMetadata`,
    props,
    signal
  )

export interface GetServiceNowTicketTypesQueryParams {
  connectorRef: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  branch?: string
  repoIdentifier?: string
  getDefaultFromOtherRepo?: boolean
}

export type GetServiceNowTicketTypesProps = Omit<
  GetProps<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesQueryParams, void>,
  'path'
>

/**
 * Get serviceNow ticket types
 */
export const GetServiceNowTicketTypes = (props: GetServiceNowTicketTypesProps) => (
  <Get<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesQueryParams, void>
    path={`/servicenow/ticketTypes`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceNowTicketTypesProps = Omit<
  UseGetProps<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesQueryParams, void>,
  'path'
>

/**
 * Get serviceNow ticket types
 */
export const useGetServiceNowTicketTypes = (props: UseGetServiceNowTicketTypesProps) =>
  useGet<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesQueryParams, void>(
    `/servicenow/ticketTypes`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get serviceNow ticket types
 */
export const getServiceNowTicketTypesPromise = (
  props: GetUsingFetchProps<
    ResponseListServiceNowTicketTypeDTO,
    Failure | Error,
    GetServiceNowTicketTypesQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceNowTicketTypeDTO, Failure | Error, GetServiceNowTicketTypesQueryParams, void>(
    getConfig('ng/api'),
    `/servicenow/ticketTypes`,
    props,
    signal
  )

export interface GetServiceListForProjectQueryParams {
  page?: number
  size?: number
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  serviceIdentifiers?: string[]
  sort?: string[]
}

export type GetServiceListForProjectProps = Omit<
  GetProps<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets Service list for a project
 */
export const GetServiceListForProject = (props: GetServiceListForProjectProps) => (
  <Get<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>
    path={`/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceListForProjectProps = Omit<
  UseGetProps<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>,
  'path'
>

/**
 * Gets Service list for a project
 */
export const useGetServiceListForProject = (props: UseGetServiceListForProjectProps) =>
  useGet<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>(`/services`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Service list for a project
 */
export const getServiceListForProjectPromise = (
  props: GetUsingFetchProps<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceResponseDTO, Failure | Error, GetServiceListForProjectQueryParams, void>(
    getConfig('ng/api'),
    `/services`,
    props,
    signal
  )

export interface CreateServiceQueryParams {
  accountId?: string
}

export type CreateServiceProps = Omit<
  MutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const CreateService = (props: CreateServiceProps) => (
  <Mutate<ResponseServiceResponseDTO, Failure | Error, CreateServiceQueryParams, ServiceRequestDTORequestBody, void>
    verb="POST"
    path={`/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServiceProps = Omit<
  UseMutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const useCreateService = (props: UseCreateServiceProps) =>
  useMutate<ResponseServiceResponseDTO, Failure | Error, CreateServiceQueryParams, ServiceRequestDTORequestBody, void>(
    'POST',
    `/services`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Service
 */
export const createServicePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponseDTO,
    Failure | Error,
    CreateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/services`, props, signal)

export interface UpdateServiceQueryParams {
  accountId?: string
}

export type UpdateServiceProps = Omit<
  MutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const UpdateService = (props: UpdateServiceProps) => (
  <Mutate<ResponseServiceResponseDTO, Failure | Error, UpdateServiceQueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path={`/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateServiceProps = Omit<
  UseMutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const useUpdateService = (props: UseUpdateServiceProps) =>
  useMutate<ResponseServiceResponseDTO, Failure | Error, UpdateServiceQueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/services`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a service by identifier
 */
export const updateServicePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpdateServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/services`, props, signal)

export interface CreateServicesQueryParams {
  accountId?: string
}

export type CreateServicesProps = Omit<
  MutateProps<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const CreateServices = (props: CreateServicesProps) => (
  <Mutate<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >
    verb="POST"
    path={`/services/batch`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServicesProps = Omit<
  UseMutateProps<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const useCreateServices = (props: UseCreateServicesProps) =>
  useMutate<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >('POST', `/services/batch`, { base: getConfig('ng/api'), ...props })

/**
 * Create Services
 */
export const createServicesPromise = (
  props: MutateUsingFetchProps<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageServiceResponseDTO,
    Failure | Error,
    CreateServicesQueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >('POST', getConfig('ng/api'), `/services/batch`, props, signal)

export interface HelmCmdFlagsQueryParams {
  serviceSpecType: string
  version: 'V2' | 'V3'
  storeType: string
}

export type HelmCmdFlagsProps = Omit<
  GetProps<ResponseSetHelmCommandFlagType, Failure | Error, HelmCmdFlagsQueryParams, void>,
  'path'
>

/**
 * Get Command flags based on Deployment Type
 */
export const HelmCmdFlags = (props: HelmCmdFlagsProps) => (
  <Get<ResponseSetHelmCommandFlagType, Failure | Error, HelmCmdFlagsQueryParams, void>
    path={`/services/helmCmdFlags`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseHelmCmdFlagsProps = Omit<
  UseGetProps<ResponseSetHelmCommandFlagType, Failure | Error, HelmCmdFlagsQueryParams, void>,
  'path'
>

/**
 * Get Command flags based on Deployment Type
 */
export const useHelmCmdFlags = (props: UseHelmCmdFlagsProps) =>
  useGet<ResponseSetHelmCommandFlagType, Failure | Error, HelmCmdFlagsQueryParams, void>(`/services/helmCmdFlags`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Command flags based on Deployment Type
 */
export const helmCmdFlagsPromise = (
  props: GetUsingFetchProps<ResponseSetHelmCommandFlagType, Failure | Error, HelmCmdFlagsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSetHelmCommandFlagType, Failure | Error, HelmCmdFlagsQueryParams, void>(
    getConfig('ng/api'),
    `/services/helmCmdFlags`,
    props,
    signal
  )

export interface UpsertServiceQueryParams {
  accountId?: string
}

export type UpsertServiceProps = Omit<
  MutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const UpsertService = (props: UpsertServiceProps) => (
  <Mutate<ResponseServiceResponseDTO, Failure | Error, UpsertServiceQueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path={`/services/upsert`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertServiceProps = Omit<
  UseMutateProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const useUpsertService = (props: UseUpsertServiceProps) =>
  useMutate<ResponseServiceResponseDTO, Failure | Error, UpsertServiceQueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/services/upsert`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Upsert a service by identifier
 */
export const upsertServicePromise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponseDTO,
    Failure | Error,
    UpsertServiceQueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/services/upsert`, props, signal)

export interface DeleteServiceQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteServiceProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const DeleteService = (props: DeleteServiceProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>
    verb="DELETE"
    path={`/services`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteServiceProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const useDeleteService = (props: UseDeleteServiceProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>('DELETE', `/services`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a service by identifier
 */
export const deleteServicePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteServiceQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/services`,
    props,
    signal
  )

export interface GetServiceQueryParams {
  accountId?: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetServicePathParams {
  serviceIdentifier: string
}

export type GetServiceProps = Omit<
  GetProps<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>,
  'path'
> &
  GetServicePathParams

/**
 * Gets a Service by identifier
 */
export const GetService = ({ serviceIdentifier, ...props }: GetServiceProps) => (
  <Get<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>
    path={`/services/${serviceIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceProps = Omit<
  UseGetProps<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>,
  'path'
> &
  GetServicePathParams

/**
 * Gets a Service by identifier
 */
export const useGetService = ({ serviceIdentifier, ...props }: UseGetServiceProps) =>
  useGet<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>(
    (paramsInPath: GetServicePathParams) => `/services/${paramsInPath.serviceIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { serviceIdentifier }, ...props }
  )

/**
 * Gets a Service by identifier
 */
export const getServicePromise = (
  {
    serviceIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams> & {
    serviceIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceResponseDTO, Failure | Error, GetServiceQueryParams, GetServicePathParams>(
    getConfig('ng/api'),
    `/services/${serviceIdentifier}`,
    props,
    signal
  )

export interface GetServiceListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  serviceIdentifiers?: string[]
  sort?: string[]
}

export type GetServiceListProps = Omit<
  GetProps<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>,
  'path'
>

/**
 * Gets Service list
 */
export const GetServiceList = (props: GetServiceListProps) => (
  <Get<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>
    path={`/servicesV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceListProps = Omit<
  UseGetProps<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>,
  'path'
>

/**
 * Gets Service list
 */
export const useGetServiceList = (props: UseGetServiceListProps) =>
  useGet<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>(`/servicesV2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Service list
 */
export const getServiceListPromise = (
  props: GetUsingFetchProps<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageServiceResponse, Failure | Error, GetServiceListQueryParams, void>(
    getConfig('ng/api'),
    `/servicesV2`,
    props,
    signal
  )

export interface CreateServiceV2QueryParams {
  accountIdentifier: string
}

export type CreateServiceV2Props = Omit<
  MutateProps<ResponseServiceResponse, Failure | Error, CreateServiceV2QueryParams, ServiceRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const CreateServiceV2 = (props: CreateServiceV2Props) => (
  <Mutate<ResponseServiceResponse, Failure | Error, CreateServiceV2QueryParams, ServiceRequestDTORequestBody, void>
    verb="POST"
    path={`/servicesV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServiceV2Props = Omit<
  UseMutateProps<
    ResponseServiceResponse,
    Failure | Error,
    CreateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a Service
 */
export const useCreateServiceV2 = (props: UseCreateServiceV2Props) =>
  useMutate<ResponseServiceResponse, Failure | Error, CreateServiceV2QueryParams, ServiceRequestDTORequestBody, void>(
    'POST',
    `/servicesV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a Service
 */
export const createServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponse,
    Failure | Error,
    CreateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponse,
    Failure | Error,
    CreateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/servicesV2`, props, signal)

export interface UpdateServiceV2QueryParams {
  accountIdentifier: string
}

export type UpdateServiceV2Props = Omit<
  MutateProps<ResponseServiceResponse, Failure | Error, UpdateServiceV2QueryParams, ServiceRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const UpdateServiceV2 = (props: UpdateServiceV2Props) => (
  <Mutate<ResponseServiceResponse, Failure | Error, UpdateServiceV2QueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path={`/servicesV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateServiceV2Props = Omit<
  UseMutateProps<
    ResponseServiceResponse,
    Failure | Error,
    UpdateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a service by identifier
 */
export const useUpdateServiceV2 = (props: UseUpdateServiceV2Props) =>
  useMutate<ResponseServiceResponse, Failure | Error, UpdateServiceV2QueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/servicesV2`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Update a service by identifier
 */
export const updateServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponse,
    Failure | Error,
    UpdateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponse,
    Failure | Error,
    UpdateServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/servicesV2`, props, signal)

export interface CreateServicesV2QueryParams {
  accountIdentifier: string
}

export type CreateServicesV2Props = Omit<
  MutateProps<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const CreateServicesV2 = (props: CreateServicesV2Props) => (
  <Mutate<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >
    verb="POST"
    path={`/servicesV2/batch`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateServicesV2Props = Omit<
  UseMutateProps<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create Services
 */
export const useCreateServicesV2 = (props: UseCreateServicesV2Props) =>
  useMutate<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >('POST', `/servicesV2/batch`, { base: getConfig('ng/api'), ...props })

/**
 * Create Services
 */
export const createServicesV2Promise = (
  props: MutateUsingFetchProps<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageServiceResponse,
    Failure | Error,
    CreateServicesV2QueryParams,
    ServiceRequestDTOArrayRequestBody,
    void
  >('POST', getConfig('ng/api'), `/servicesV2/batch`, props, signal)

export interface GetServiceAccessListQueryParams {
  page?: number
  size?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  serviceIdentifiers?: string[]
  sort?: string[]
}

export type GetServiceAccessListProps = Omit<
  GetProps<ResponseListServiceResponse, Failure | Error, GetServiceAccessListQueryParams, void>,
  'path'
>

/**
 * Gets Service Access list
 */
export const GetServiceAccessList = (props: GetServiceAccessListProps) => (
  <Get<ResponseListServiceResponse, Failure | Error, GetServiceAccessListQueryParams, void>
    path={`/servicesV2/list/access`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceAccessListProps = Omit<
  UseGetProps<ResponseListServiceResponse, Failure | Error, GetServiceAccessListQueryParams, void>,
  'path'
>

/**
 * Gets Service Access list
 */
export const useGetServiceAccessList = (props: UseGetServiceAccessListProps) =>
  useGet<ResponseListServiceResponse, Failure | Error, GetServiceAccessListQueryParams, void>(
    `/servicesV2/list/access`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Gets Service Access list
 */
export const getServiceAccessListPromise = (
  props: GetUsingFetchProps<ResponseListServiceResponse, Failure | Error, GetServiceAccessListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListServiceResponse, Failure | Error, GetServiceAccessListQueryParams, void>(
    getConfig('ng/api'),
    `/servicesV2/list/access`,
    props,
    signal
  )

export interface UpsertServiceV2QueryParams {
  accountIdentifier: string
}

export type UpsertServiceV2Props = Omit<
  MutateProps<ResponseServiceResponse, Failure | Error, UpsertServiceV2QueryParams, ServiceRequestDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const UpsertServiceV2 = (props: UpsertServiceV2Props) => (
  <Mutate<ResponseServiceResponse, Failure | Error, UpsertServiceV2QueryParams, ServiceRequestDTORequestBody, void>
    verb="PUT"
    path={`/servicesV2/upsert`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpsertServiceV2Props = Omit<
  UseMutateProps<
    ResponseServiceResponse,
    Failure | Error,
    UpsertServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Upsert a service by identifier
 */
export const useUpsertServiceV2 = (props: UseUpsertServiceV2Props) =>
  useMutate<ResponseServiceResponse, Failure | Error, UpsertServiceV2QueryParams, ServiceRequestDTORequestBody, void>(
    'PUT',
    `/servicesV2/upsert`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Upsert a service by identifier
 */
export const upsertServiceV2Promise = (
  props: MutateUsingFetchProps<
    ResponseServiceResponse,
    Failure | Error,
    UpsertServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseServiceResponse,
    Failure | Error,
    UpsertServiceV2QueryParams,
    ServiceRequestDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/servicesV2/upsert`, props, signal)

export interface DeleteServiceV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteServiceV2Props = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const DeleteServiceV2 = (props: DeleteServiceV2Props) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>
    verb="DELETE"
    path={`/servicesV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteServiceV2Props = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a service by identifier
 */
export const useDeleteServiceV2 = (props: UseDeleteServiceV2Props) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>('DELETE', `/servicesV2`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete a service by identifier
 */
export const deleteServiceV2Promise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteServiceV2QueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/servicesV2`,
    props,
    signal
  )

export interface GetServiceV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  deleted?: boolean
}

export interface GetServiceV2PathParams {
  serviceIdentifier: string
}

export type GetServiceV2Props = Omit<
  GetProps<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>,
  'path'
> &
  GetServiceV2PathParams

/**
 * Gets a Service by identifier
 */
export const GetServiceV2 = ({ serviceIdentifier, ...props }: GetServiceV2Props) => (
  <Get<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>
    path={`/servicesV2/${serviceIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetServiceV2Props = Omit<
  UseGetProps<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>,
  'path'
> &
  GetServiceV2PathParams

/**
 * Gets a Service by identifier
 */
export const useGetServiceV2 = ({ serviceIdentifier, ...props }: UseGetServiceV2Props) =>
  useGet<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>(
    (paramsInPath: GetServiceV2PathParams) => `/servicesV2/${paramsInPath.serviceIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { serviceIdentifier }, ...props }
  )

/**
 * Gets a Service by identifier
 */
export const getServiceV2Promise = (
  {
    serviceIdentifier,
    ...props
  }: GetUsingFetchProps<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams> & {
    serviceIdentifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseServiceResponse, Failure | Error, GetServiceV2QueryParams, GetServiceV2PathParams>(
    getConfig('ng/api'),
    `/servicesV2/${serviceIdentifier}`,
    props,
    signal
  )

export interface SignupQueryParams {
  captchaToken?: string
}

export type SignupProps = Omit<
  MutateProps<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTORequestBody, void>,
  'path' | 'verb'
>

export const Signup = (props: SignupProps) => (
  <Mutate<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTORequestBody, void>
    verb="POST"
    path={`/signup`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSignupProps = Omit<
  UseMutateProps<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTORequestBody, void>,
  'path' | 'verb'
>

export const useSignup = (props: UseSignupProps) =>
  useMutate<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTORequestBody, void>('POST', `/signup`, {
    base: getConfig('ng/api'),
    ...props
  })

export const signupPromise = (
  props: MutateUsingFetchProps<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseVoid, Failure | Error, SignupQueryParams, SignupDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/signup`,
    props,
    signal
  )

export type CommunitySignupProps = Omit<
  MutateProps<RestResponseUserInfo, Failure | Error, void, SignupDTORequestBody, void>,
  'path' | 'verb'
>

export const CommunitySignup = (props: CommunitySignupProps) => (
  <Mutate<RestResponseUserInfo, Failure | Error, void, SignupDTORequestBody, void>
    verb="POST"
    path={`/signup/community`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCommunitySignupProps = Omit<
  UseMutateProps<RestResponseUserInfo, Failure | Error, void, SignupDTORequestBody, void>,
  'path' | 'verb'
>

export const useCommunitySignup = (props: UseCommunitySignupProps) =>
  useMutate<RestResponseUserInfo, Failure | Error, void, SignupDTORequestBody, void>('POST', `/signup/community`, {
    base: getConfig('ng/api'),
    ...props
  })

export const communitySignupPromise = (
  props: MutateUsingFetchProps<RestResponseUserInfo, Failure | Error, void, SignupDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseUserInfo, Failure | Error, void, SignupDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/signup/community`,
    props,
    signal
  )

export interface CompleteSignupInvitePathParams {
  token: string
}

export type CompleteSignupInviteProps = Omit<
  MutateProps<RestResponseUserInfo, Failure | Error, void, void, CompleteSignupInvitePathParams>,
  'path' | 'verb'
> &
  CompleteSignupInvitePathParams

export const CompleteSignupInvite = ({ token, ...props }: CompleteSignupInviteProps) => (
  <Mutate<RestResponseUserInfo, Failure | Error, void, void, CompleteSignupInvitePathParams>
    verb="PUT"
    path={`/signup/complete/${token}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCompleteSignupInviteProps = Omit<
  UseMutateProps<RestResponseUserInfo, Failure | Error, void, void, CompleteSignupInvitePathParams>,
  'path' | 'verb'
> &
  CompleteSignupInvitePathParams

export const useCompleteSignupInvite = ({ token, ...props }: UseCompleteSignupInviteProps) =>
  useMutate<RestResponseUserInfo, Failure | Error, void, void, CompleteSignupInvitePathParams>(
    'PUT',
    (paramsInPath: CompleteSignupInvitePathParams) => `/signup/complete/${paramsInPath.token}`,
    { base: getConfig('ng/api'), pathParams: { token }, ...props }
  )

export const completeSignupInvitePromise = (
  {
    token,
    ...props
  }: MutateUsingFetchProps<RestResponseUserInfo, Failure | Error, void, void, CompleteSignupInvitePathParams> & {
    token: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseUserInfo, Failure | Error, void, void, CompleteSignupInvitePathParams>(
    'PUT',
    getConfig('ng/api'),
    `/signup/complete/${token}`,
    props,
    signal
  )

export type SignupOAuthProps = Omit<
  MutateProps<RestResponseUserInfo, Failure | Error, void, OAuthSignupDTO, void>,
  'path' | 'verb'
>

export const SignupOAuth = (props: SignupOAuthProps) => (
  <Mutate<RestResponseUserInfo, Failure | Error, void, OAuthSignupDTO, void>
    verb="POST"
    path={`/signup/oauth`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSignupOAuthProps = Omit<
  UseMutateProps<RestResponseUserInfo, Failure | Error, void, OAuthSignupDTO, void>,
  'path' | 'verb'
>

export const useSignupOAuth = (props: UseSignupOAuthProps) =>
  useMutate<RestResponseUserInfo, Failure | Error, void, OAuthSignupDTO, void>('POST', `/signup/oauth`, {
    base: getConfig('ng/api'),
    ...props
  })

export const signupOAuthPromise = (
  props: MutateUsingFetchProps<RestResponseUserInfo, Failure | Error, void, OAuthSignupDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseUserInfo, Failure | Error, void, OAuthSignupDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/signup/oauth`,
    props,
    signal
  )

export interface ResendVerifyEmailQueryParams {
  email: string
}

export type ResendVerifyEmailProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, ResendVerifyEmailQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Resend user verification email
 */
export const ResendVerifyEmail = (props: ResendVerifyEmailProps) => (
  <Mutate<ResponseBoolean, Failure | Error, ResendVerifyEmailQueryParams, void, void>
    verb="POST"
    path={`/signup/verify-notification`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseResendVerifyEmailProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, ResendVerifyEmailQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Resend user verification email
 */
export const useResendVerifyEmail = (props: UseResendVerifyEmailProps) =>
  useMutate<ResponseBoolean, Failure | Error, ResendVerifyEmailQueryParams, void, void>(
    'POST',
    `/signup/verify-notification`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Resend user verification email
 */
export const resendVerifyEmailPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, ResendVerifyEmailQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, ResendVerifyEmailQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/signup/verify-notification`,
    props,
    signal
  )

export interface VerifyTokenPathParams {
  token: string
}

export type VerifyTokenProps = Omit<
  MutateProps<RestResponseVerifyTokenResponseDTO, Failure | Error, void, void, VerifyTokenPathParams>,
  'path' | 'verb'
> &
  VerifyTokenPathParams

export const VerifyToken = ({ token, ...props }: VerifyTokenProps) => (
  <Mutate<RestResponseVerifyTokenResponseDTO, Failure | Error, void, void, VerifyTokenPathParams>
    verb="POST"
    path={`/signup/verify/${token}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseVerifyTokenProps = Omit<
  UseMutateProps<RestResponseVerifyTokenResponseDTO, Failure | Error, void, void, VerifyTokenPathParams>,
  'path' | 'verb'
> &
  VerifyTokenPathParams

export const useVerifyToken = ({ token, ...props }: UseVerifyTokenProps) =>
  useMutate<RestResponseVerifyTokenResponseDTO, Failure | Error, void, void, VerifyTokenPathParams>(
    'POST',
    (paramsInPath: VerifyTokenPathParams) => `/signup/verify/${paramsInPath.token}`,
    { base: getConfig('ng/api'), pathParams: { token }, ...props }
  )

export const verifyTokenPromise = (
  {
    token,
    ...props
  }: MutateUsingFetchProps<RestResponseVerifyTokenResponseDTO, Failure | Error, void, void, VerifyTokenPathParams> & {
    token: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseVerifyTokenResponseDTO, Failure | Error, void, void, VerifyTokenPathParams>(
    'POST',
    getConfig('ng/api'),
    `/signup/verify/${token}`,
    props,
    signal
  )

export interface GetSmtpConfigQueryParams {
  accountId?: string
}

export type GetSmtpConfigProps = Omit<
  GetProps<ResponseNgSmtpDTO, Failure | Error, GetSmtpConfigQueryParams, void>,
  'path'
>

/**
 * Gets Smtp config by accountId
 */
export const GetSmtpConfig = (props: GetSmtpConfigProps) => (
  <Get<ResponseNgSmtpDTO, Failure | Error, GetSmtpConfigQueryParams, void>
    path={`/smtpConfig`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSmtpConfigProps = Omit<
  UseGetProps<ResponseNgSmtpDTO, Failure | Error, GetSmtpConfigQueryParams, void>,
  'path'
>

/**
 * Gets Smtp config by accountId
 */
export const useGetSmtpConfig = (props: UseGetSmtpConfigProps) =>
  useGet<ResponseNgSmtpDTO, Failure | Error, GetSmtpConfigQueryParams, void>(`/smtpConfig`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Gets Smtp config by accountId
 */
export const getSmtpConfigPromise = (
  props: GetUsingFetchProps<ResponseNgSmtpDTO, Failure | Error, GetSmtpConfigQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNgSmtpDTO, Failure | Error, GetSmtpConfigQueryParams, void>(
    getConfig('ng/api'),
    `/smtpConfig`,
    props,
    signal
  )

export type CreateSmtpConfigProps = Omit<
  MutateProps<ResponseNgSmtpDTO, Failure | Error, void, NgSmtpDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create SMTP config
 */
export const CreateSmtpConfig = (props: CreateSmtpConfigProps) => (
  <Mutate<ResponseNgSmtpDTO, Failure | Error, void, NgSmtpDTORequestBody, void>
    verb="POST"
    path={`/smtpConfig`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateSmtpConfigProps = Omit<
  UseMutateProps<ResponseNgSmtpDTO, Failure | Error, void, NgSmtpDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create SMTP config
 */
export const useCreateSmtpConfig = (props: UseCreateSmtpConfigProps) =>
  useMutate<ResponseNgSmtpDTO, Failure | Error, void, NgSmtpDTORequestBody, void>('POST', `/smtpConfig`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create SMTP config
 */
export const createSmtpConfigPromise = (
  props: MutateUsingFetchProps<ResponseNgSmtpDTO, Failure | Error, void, NgSmtpDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseNgSmtpDTO, Failure | Error, void, NgSmtpDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/smtpConfig`,
    props,
    signal
  )

export type UpdateSmtpProps = Omit<
  MutateProps<ResponseNgSmtpDTO, Failure | Error, void, NgSmtpDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update SmtpConfig
 */
export const UpdateSmtp = (props: UpdateSmtpProps) => (
  <Mutate<ResponseNgSmtpDTO, Failure | Error, void, NgSmtpDTORequestBody, void>
    verb="PUT"
    path={`/smtpConfig`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSmtpProps = Omit<
  UseMutateProps<ResponseNgSmtpDTO, Failure | Error, void, NgSmtpDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update SmtpConfig
 */
export const useUpdateSmtp = (props: UseUpdateSmtpProps) =>
  useMutate<ResponseNgSmtpDTO, Failure | Error, void, NgSmtpDTORequestBody, void>('PUT', `/smtpConfig`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Update SmtpConfig
 */
export const updateSmtpPromise = (
  props: MutateUsingFetchProps<ResponseNgSmtpDTO, Failure | Error, void, NgSmtpDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseNgSmtpDTO, Failure | Error, void, NgSmtpDTORequestBody, void>(
    'PUT',
    getConfig('ng/api'),
    `/smtpConfig`,
    props,
    signal
  )

export interface ValidateConnectivityQueryParams {
  identifier: string
  accountId: string
  to: string
  subject: string
  body: string
}

export type ValidateConnectivityProps = Omit<
  MutateProps<ResponseValidationResultDTO, Failure | Error, ValidateConnectivityQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Tests the connectivity
 */
export const ValidateConnectivity = (props: ValidateConnectivityProps) => (
  <Mutate<ResponseValidationResultDTO, Failure | Error, ValidateConnectivityQueryParams, void, void>
    verb="POST"
    path={`/smtpConfig/validate-connectivity`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateConnectivityProps = Omit<
  UseMutateProps<ResponseValidationResultDTO, Failure | Error, ValidateConnectivityQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Tests the connectivity
 */
export const useValidateConnectivity = (props: UseValidateConnectivityProps) =>
  useMutate<ResponseValidationResultDTO, Failure | Error, ValidateConnectivityQueryParams, void, void>(
    'POST',
    `/smtpConfig/validate-connectivity`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Tests the connectivity
 */
export const validateConnectivityPromise = (
  props: MutateUsingFetchProps<
    ResponseValidationResultDTO,
    Failure | Error,
    ValidateConnectivityQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseValidationResultDTO, Failure | Error, ValidateConnectivityQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/smtpConfig/validate-connectivity`,
    props,
    signal
  )

export interface ValidateNameQueryParams {
  name?: string
  accountId?: string
}

export type ValidateNameProps = Omit<
  MutateProps<ResponseValidationResultDTO, Failure | Error, ValidateNameQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Checks whether other connectors exist with the same name
 */
export const ValidateName = (props: ValidateNameProps) => (
  <Mutate<ResponseValidationResultDTO, Failure | Error, ValidateNameQueryParams, void, void>
    verb="POST"
    path={`/smtpConfig/validateName`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateNameProps = Omit<
  UseMutateProps<ResponseValidationResultDTO, Failure | Error, ValidateNameQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Checks whether other connectors exist with the same name
 */
export const useValidateName = (props: UseValidateNameProps) =>
  useMutate<ResponseValidationResultDTO, Failure | Error, ValidateNameQueryParams, void, void>(
    'POST',
    `/smtpConfig/validateName`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Checks whether other connectors exist with the same name
 */
export const validateNamePromise = (
  props: MutateUsingFetchProps<ResponseValidationResultDTO, Failure | Error, ValidateNameQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseValidationResultDTO, Failure | Error, ValidateNameQueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/smtpConfig/validateName`,
    props,
    signal
  )

export type DeleteSmtpConfigProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, void, string, void>,
  'path' | 'verb'
>

/**
 * Delete Smtp Config
 */
export const DeleteSmtpConfig = (props: DeleteSmtpConfigProps) => (
  <Mutate<ResponseBoolean, Failure | Error, void, string, void>
    verb="DELETE"
    path={`/smtpConfig`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSmtpConfigProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, void, string, void>,
  'path' | 'verb'
>

/**
 * Delete Smtp Config
 */
export const useDeleteSmtpConfig = (props: UseDeleteSmtpConfigProps) =>
  useMutate<ResponseBoolean, Failure | Error, void, string, void>('DELETE', `/smtpConfig`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete Smtp Config
 */
export const deleteSmtpConfigPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, void, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, void, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/smtpConfig`,
    props,
    signal
  )

export interface GetSourceCodeManagersQueryParams {
  accountIdentifier: string
}

export type GetSourceCodeManagersProps = Omit<
  GetProps<ResponseListSourceCodeManagerDTO, Failure | Error, GetSourceCodeManagersQueryParams, void>,
  'path'
>

/**
 * get source code manager information
 */
export const GetSourceCodeManagers = (props: GetSourceCodeManagersProps) => (
  <Get<ResponseListSourceCodeManagerDTO, Failure | Error, GetSourceCodeManagersQueryParams, void>
    path={`/source-code-manager`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSourceCodeManagersProps = Omit<
  UseGetProps<ResponseListSourceCodeManagerDTO, Failure | Error, GetSourceCodeManagersQueryParams, void>,
  'path'
>

/**
 * get source code manager information
 */
export const useGetSourceCodeManagers = (props: UseGetSourceCodeManagersProps) =>
  useGet<ResponseListSourceCodeManagerDTO, Failure | Error, GetSourceCodeManagersQueryParams, void>(
    `/source-code-manager`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * get source code manager information
 */
export const getSourceCodeManagersPromise = (
  props: GetUsingFetchProps<ResponseListSourceCodeManagerDTO, Failure | Error, GetSourceCodeManagersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListSourceCodeManagerDTO, Failure | Error, GetSourceCodeManagersQueryParams, void>(
    getConfig('ng/api'),
    `/source-code-manager`,
    props,
    signal
  )

export type SaveSourceCodeManagersProps = Omit<
  MutateProps<ResponseSourceCodeManagerDTO, Failure | Error, void, SourceCodeManagerDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * save source code manager
 */
export const SaveSourceCodeManagers = (props: SaveSourceCodeManagersProps) => (
  <Mutate<ResponseSourceCodeManagerDTO, Failure | Error, void, SourceCodeManagerDTORequestBody, void>
    verb="POST"
    path={`/source-code-manager`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseSaveSourceCodeManagersProps = Omit<
  UseMutateProps<ResponseSourceCodeManagerDTO, Failure | Error, void, SourceCodeManagerDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * save source code manager
 */
export const useSaveSourceCodeManagers = (props: UseSaveSourceCodeManagersProps) =>
  useMutate<ResponseSourceCodeManagerDTO, Failure | Error, void, SourceCodeManagerDTORequestBody, void>(
    'POST',
    `/source-code-manager`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * save source code manager
 */
export const saveSourceCodeManagersPromise = (
  props: MutateUsingFetchProps<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseSourceCodeManagerDTO, Failure | Error, void, SourceCodeManagerDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/source-code-manager`,
    props,
    signal
  )

export interface DeleteSourceCodeManagersQueryParams {
  accountIdentifier: string
}

export type DeleteSourceCodeManagersProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteSourceCodeManagersQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * delete source code manager
 */
export const DeleteSourceCodeManagers = (props: DeleteSourceCodeManagersProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteSourceCodeManagersQueryParams, string, void>
    verb="DELETE"
    path={`/source-code-manager`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSourceCodeManagersProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteSourceCodeManagersQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * delete source code manager
 */
export const useDeleteSourceCodeManagers = (props: UseDeleteSourceCodeManagersProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteSourceCodeManagersQueryParams, string, void>(
    'DELETE',
    `/source-code-manager`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * delete source code manager
 */
export const deleteSourceCodeManagersPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteSourceCodeManagersQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteSourceCodeManagersQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/source-code-manager`,
    props,
    signal
  )

export interface UpdateSourceCodeManagersPathParams {
  identifier: string
}

export type UpdateSourceCodeManagersProps = Omit<
  MutateProps<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >,
  'path' | 'verb'
> &
  UpdateSourceCodeManagersPathParams

/**
 * update source code manager
 */
export const UpdateSourceCodeManagers = ({ identifier, ...props }: UpdateSourceCodeManagersProps) => (
  <Mutate<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >
    verb="PUT"
    path={`/source-code-manager/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSourceCodeManagersProps = Omit<
  UseMutateProps<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >,
  'path' | 'verb'
> &
  UpdateSourceCodeManagersPathParams

/**
 * update source code manager
 */
export const useUpdateSourceCodeManagers = ({ identifier, ...props }: UseUpdateSourceCodeManagersProps) =>
  useMutate<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >('PUT', (paramsInPath: UpdateSourceCodeManagersPathParams) => `/source-code-manager/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * update source code manager
 */
export const updateSourceCodeManagersPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSourceCodeManagerDTO,
    Failure | Error,
    void,
    SourceCodeManagerDTORequestBody,
    UpdateSourceCodeManagersPathParams
  >('PUT', getConfig('ng/api'), `/source-code-manager/${identifier}`, props, signal)

export interface GetTokenQueryParams {
  tokenId?: string
}

export type GetTokenProps = Omit<GetProps<ResponseTokenDTO, Failure | Error, GetTokenQueryParams, void>, 'path'>

/**
 * Get token
 */
export const GetToken = (props: GetTokenProps) => (
  <Get<ResponseTokenDTO, Failure | Error, GetTokenQueryParams, void>
    path={`/token`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTokenProps = Omit<UseGetProps<ResponseTokenDTO, Failure | Error, GetTokenQueryParams, void>, 'path'>

/**
 * Get token
 */
export const useGetToken = (props: UseGetTokenProps) =>
  useGet<ResponseTokenDTO, Failure | Error, GetTokenQueryParams, void>(`/token`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get token
 */
export const getTokenPromise = (
  props: GetUsingFetchProps<ResponseTokenDTO, Failure | Error, GetTokenQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTokenDTO, Failure | Error, GetTokenQueryParams, void>(
    getConfig('ng/api'),
    `/token`,
    props,
    signal
  )

export type CreateTokenProps = Omit<
  MutateProps<ResponseString, Failure | Error, void, TokenDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create token
 */
export const CreateToken = (props: CreateTokenProps) => (
  <Mutate<ResponseString, Failure | Error, void, TokenDTORequestBody, void>
    verb="POST"
    path={`/token`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCreateTokenProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, void, TokenDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create token
 */
export const useCreateToken = (props: UseCreateTokenProps) =>
  useMutate<ResponseString, Failure | Error, void, TokenDTORequestBody, void>('POST', `/token`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Create token
 */
export const createTokenPromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, void, TokenDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, void, TokenDTORequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/token`,
    props,
    signal
  )

export interface ListAggregatedTokensQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
  apiKeyIdentifier: string
  identifiers?: string[]
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
  searchTerm?: string
}

export type ListAggregatedTokensProps = Omit<
  GetProps<ResponsePageTokenAggregateDTO, Failure | Error, ListAggregatedTokensQueryParams, void>,
  'path'
>

/**
 * List tokens
 */
export const ListAggregatedTokens = (props: ListAggregatedTokensProps) => (
  <Get<ResponsePageTokenAggregateDTO, Failure | Error, ListAggregatedTokensQueryParams, void>
    path={`/token/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListAggregatedTokensProps = Omit<
  UseGetProps<ResponsePageTokenAggregateDTO, Failure | Error, ListAggregatedTokensQueryParams, void>,
  'path'
>

/**
 * List tokens
 */
export const useListAggregatedTokens = (props: UseListAggregatedTokensProps) =>
  useGet<ResponsePageTokenAggregateDTO, Failure | Error, ListAggregatedTokensQueryParams, void>(`/token/aggregate`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * List tokens
 */
export const listAggregatedTokensPromise = (
  props: GetUsingFetchProps<ResponsePageTokenAggregateDTO, Failure | Error, ListAggregatedTokensQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageTokenAggregateDTO, Failure | Error, ListAggregatedTokensQueryParams, void>(
    getConfig('ng/api'),
    `/token/aggregate`,
    props,
    signal
  )

export interface RotateTokenQueryParams {
  rotateTimestamp?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
  apiKeyIdentifier: string
}

export interface RotateTokenPathParams {
  identifier: string
}

export type RotateTokenProps = Omit<
  MutateProps<ResponseString, Failure | Error, RotateTokenQueryParams, void, RotateTokenPathParams>,
  'path' | 'verb'
> &
  RotateTokenPathParams

/**
 * Rotate token
 */
export const RotateToken = ({ identifier, ...props }: RotateTokenProps) => (
  <Mutate<ResponseString, Failure | Error, RotateTokenQueryParams, void, RotateTokenPathParams>
    verb="POST"
    path={`/token/rotate/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRotateTokenProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, RotateTokenQueryParams, void, RotateTokenPathParams>,
  'path' | 'verb'
> &
  RotateTokenPathParams

/**
 * Rotate token
 */
export const useRotateToken = ({ identifier, ...props }: UseRotateTokenProps) =>
  useMutate<ResponseString, Failure | Error, RotateTokenQueryParams, void, RotateTokenPathParams>(
    'POST',
    (paramsInPath: RotateTokenPathParams) => `/token/rotate/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Rotate token
 */
export const rotateTokenPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<ResponseString, Failure | Error, RotateTokenQueryParams, void, RotateTokenPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, RotateTokenQueryParams, void, RotateTokenPathParams>(
    'POST',
    getConfig('ng/api'),
    `/token/rotate/${identifier}`,
    props,
    signal
  )

export interface DeleteTokenQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  apiKeyType: 'USER' | 'SERVICE_ACCOUNT'
  parentIdentifier: string
  apiKeyIdentifier: string
}

export type DeleteTokenProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteTokenQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete token
 */
export const DeleteToken = (props: DeleteTokenProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteTokenQueryParams, string, void>
    verb="DELETE"
    path={`/token`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteTokenProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteTokenQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete token
 */
export const useDeleteToken = (props: UseDeleteTokenProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteTokenQueryParams, string, void>('DELETE', `/token`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete token
 */
export const deleteTokenPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteTokenQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteTokenQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/token`,
    props,
    signal
  )

export interface UpdateTokenPathParams {
  identifier: string
}

export type UpdateTokenProps = Omit<
  MutateProps<ResponseTokenDTO, Failure | Error, void, TokenDTORequestBody, UpdateTokenPathParams>,
  'path' | 'verb'
> &
  UpdateTokenPathParams

/**
 * Update token
 */
export const UpdateToken = ({ identifier, ...props }: UpdateTokenProps) => (
  <Mutate<ResponseTokenDTO, Failure | Error, void, TokenDTORequestBody, UpdateTokenPathParams>
    verb="PUT"
    path={`/token/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateTokenProps = Omit<
  UseMutateProps<ResponseTokenDTO, Failure | Error, void, TokenDTORequestBody, UpdateTokenPathParams>,
  'path' | 'verb'
> &
  UpdateTokenPathParams

/**
 * Update token
 */
export const useUpdateToken = ({ identifier, ...props }: UseUpdateTokenProps) =>
  useMutate<ResponseTokenDTO, Failure | Error, void, TokenDTORequestBody, UpdateTokenPathParams>(
    'PUT',
    (paramsInPath: UpdateTokenPathParams) => `/token/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Update token
 */
export const updateTokenPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<ResponseTokenDTO, Failure | Error, void, TokenDTORequestBody, UpdateTokenPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseTokenDTO, Failure | Error, void, TokenDTORequestBody, UpdateTokenPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/token/${identifier}`,
    props,
    signal
  )

export interface GetLicenseUsageQueryParams {
  accountIdentifier?: string
  timestamp?: number
  CDLicenseType?: string
}

export interface GetLicenseUsagePathParams {
  module: string
}

export type GetLicenseUsageProps = Omit<
  GetProps<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>,
  'path'
> &
  GetLicenseUsagePathParams

/**
 * Gets License Usage By Module and Timestamp
 */
export const GetLicenseUsage = ({ module, ...props }: GetLicenseUsageProps) => (
  <Get<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>
    path={`/usage/${module}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetLicenseUsageProps = Omit<
  UseGetProps<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>,
  'path'
> &
  GetLicenseUsagePathParams

/**
 * Gets License Usage By Module and Timestamp
 */
export const useGetLicenseUsage = ({ module, ...props }: UseGetLicenseUsageProps) =>
  useGet<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>(
    (paramsInPath: GetLicenseUsagePathParams) => `/usage/${paramsInPath.module}`,
    { base: getConfig('ng/api'), pathParams: { module }, ...props }
  )

/**
 * Gets License Usage By Module and Timestamp
 */
export const getLicenseUsagePromise = (
  {
    module,
    ...props
  }: GetUsingFetchProps<
    ResponseLicenseUsageDTO,
    Failure | Error,
    GetLicenseUsageQueryParams,
    GetLicenseUsagePathParams
  > & { module: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>(
    getConfig('ng/api'),
    `/usage/${module}`,
    props,
    signal
  )

export type UpdateUserInfoProps = Omit<
  MutateProps<ResponseUserInfo, Failure | Error, void, UserInfo, void>,
  'path' | 'verb'
>

/**
 * update user information
 */
export const UpdateUserInfo = (props: UpdateUserInfoProps) => (
  <Mutate<ResponseUserInfo, Failure | Error, void, UserInfo, void>
    verb="PUT"
    path={`/user`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateUserInfoProps = Omit<
  UseMutateProps<ResponseUserInfo, Failure | Error, void, UserInfo, void>,
  'path' | 'verb'
>

/**
 * update user information
 */
export const useUpdateUserInfo = (props: UseUpdateUserInfoProps) =>
  useMutate<ResponseUserInfo, Failure | Error, void, UserInfo, void>('PUT', `/user`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * update user information
 */
export const updateUserInfoPromise = (
  props: MutateUsingFetchProps<ResponseUserInfo, Failure | Error, void, UserInfo, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserInfo, Failure | Error, void, UserInfo, void>(
    'PUT',
    getConfig('ng/api'),
    `/user`,
    props,
    signal
  )

export interface GetUserGroupListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetUserGroupListProps = Omit<
  GetProps<ResponsePageUserGroupDTO, Failure | AccessControlCheckError | Error, GetUserGroupListQueryParams, void>,
  'path'
>

/**
 * Get User Group List
 */
export const GetUserGroupList = (props: GetUserGroupListProps) => (
  <Get<ResponsePageUserGroupDTO, Failure | AccessControlCheckError | Error, GetUserGroupListQueryParams, void>
    path={`/user-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupListProps = Omit<
  UseGetProps<ResponsePageUserGroupDTO, Failure | AccessControlCheckError | Error, GetUserGroupListQueryParams, void>,
  'path'
>

/**
 * Get User Group List
 */
export const useGetUserGroupList = (props: UseGetUserGroupListProps) =>
  useGet<ResponsePageUserGroupDTO, Failure | AccessControlCheckError | Error, GetUserGroupListQueryParams, void>(
    `/user-groups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get User Group List
 */
export const getUserGroupListPromise = (
  props: GetUsingFetchProps<
    ResponsePageUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetUserGroupListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageUserGroupDTO, Failure | AccessControlCheckError | Error, GetUserGroupListQueryParams, void>(
    getConfig('ng/api'),
    `/user-groups`,
    props,
    signal
  )

export interface PostUserGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PostUserGroupProps = Omit<
  MutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a User Group
 */
export const PostUserGroup = (props: PostUserGroupProps) => (
  <Mutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >
    verb="POST"
    path={`/user-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostUserGroupProps = Omit<
  UseMutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a User Group
 */
export const usePostUserGroup = (props: UsePostUserGroupProps) =>
  useMutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >('POST', `/user-groups`, { base: getConfig('ng/api'), ...props })

/**
 * Create a User Group
 */
export const postUserGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PostUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >('POST', getConfig('ng/api'), `/user-groups`, props, signal)

export interface PutUserGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type PutUserGroupProps = Omit<
  MutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a User Group
 */
export const PutUserGroup = (props: PutUserGroupProps) => (
  <Mutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >
    verb="PUT"
    path={`/user-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutUserGroupProps = Omit<
  UseMutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Update a User Group
 */
export const usePutUserGroup = (props: UsePutUserGroupProps) =>
  useMutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >('PUT', `/user-groups`, { base: getConfig('ng/api'), ...props })

/**
 * Update a User Group
 */
export const putUserGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    PutUserGroupQueryParams,
    UserGroupDTORequestBody,
    void
  >('PUT', getConfig('ng/api'), `/user-groups`, props, signal)

export type GetBatchUserGroupListProps = Omit<
  MutateProps<ResponseListUserGroupDTO, Failure | AccessControlCheckError | Error, void, UserGroupFilterDTO, void>,
  'path' | 'verb'
>

/**
 * Get Batch User Group List
 */
export const GetBatchUserGroupList = (props: GetBatchUserGroupListProps) => (
  <Mutate<ResponseListUserGroupDTO, Failure | AccessControlCheckError | Error, void, UserGroupFilterDTO, void>
    verb="POST"
    path={`/user-groups/batch`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetBatchUserGroupListProps = Omit<
  UseMutateProps<ResponseListUserGroupDTO, Failure | AccessControlCheckError | Error, void, UserGroupFilterDTO, void>,
  'path' | 'verb'
>

/**
 * Get Batch User Group List
 */
export const useGetBatchUserGroupList = (props: UseGetBatchUserGroupListProps) =>
  useMutate<ResponseListUserGroupDTO, Failure | AccessControlCheckError | Error, void, UserGroupFilterDTO, void>(
    'POST',
    `/user-groups/batch`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get Batch User Group List
 */
export const getBatchUserGroupListPromise = (
  props: MutateUsingFetchProps<
    ResponseListUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    void,
    UserGroupFilterDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseListUserGroupDTO, Failure | AccessControlCheckError | Error, void, UserGroupFilterDTO, void>(
    'POST',
    getConfig('ng/api'),
    `/user-groups/batch`,
    props,
    signal
  )

export interface CopyUserGroupQueryParams {
  accountIdentifier?: string
  groupIdentifier?: string
}

export type CopyUserGroupProps = Omit<
  MutateProps<ResponseBoolean, Failure | AccessControlCheckError | Error, CopyUserGroupQueryParams, Scope[], void>,
  'path' | 'verb'
>

/**
 * Copy a User Group to several scopes
 */
export const CopyUserGroup = (props: CopyUserGroupProps) => (
  <Mutate<ResponseBoolean, Failure | AccessControlCheckError | Error, CopyUserGroupQueryParams, Scope[], void>
    verb="PUT"
    path={`/user-groups/copy`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCopyUserGroupProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | AccessControlCheckError | Error, CopyUserGroupQueryParams, Scope[], void>,
  'path' | 'verb'
>

/**
 * Copy a User Group to several scopes
 */
export const useCopyUserGroup = (props: UseCopyUserGroupProps) =>
  useMutate<ResponseBoolean, Failure | AccessControlCheckError | Error, CopyUserGroupQueryParams, Scope[], void>(
    'PUT',
    `/user-groups/copy`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Copy a User Group to several scopes
 */
export const copyUserGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | AccessControlCheckError | Error,
    CopyUserGroupQueryParams,
    Scope[],
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | AccessControlCheckError | Error, CopyUserGroupQueryParams, Scope[], void>(
    'PUT',
    getConfig('ng/api'),
    `/user-groups/copy`,
    props,
    signal
  )

export interface DeleteUserGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteUserGroupProps = Omit<
  MutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    DeleteUserGroupQueryParams,
    string,
    void
  >,
  'path' | 'verb'
>

/**
 * Delete a User Group
 */
export const DeleteUserGroup = (props: DeleteUserGroupProps) => (
  <Mutate<ResponseUserGroupDTO, Failure | AccessControlCheckError | Error, DeleteUserGroupQueryParams, string, void>
    verb="DELETE"
    path={`/user-groups`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteUserGroupProps = Omit<
  UseMutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    DeleteUserGroupQueryParams,
    string,
    void
  >,
  'path' | 'verb'
>

/**
 * Delete a User Group
 */
export const useDeleteUserGroup = (props: UseDeleteUserGroupProps) =>
  useMutate<ResponseUserGroupDTO, Failure | AccessControlCheckError | Error, DeleteUserGroupQueryParams, string, void>(
    'DELETE',
    `/user-groups`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Delete a User Group
 */
export const deleteUserGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    DeleteUserGroupQueryParams,
    string,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    DeleteUserGroupQueryParams,
    string,
    void
  >('DELETE', getConfig('ng/api'), `/user-groups`, props, signal)

export interface GetUserGroupQueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetUserGroupPathParams {
  identifier: string
}

export type GetUserGroupProps = Omit<
  GetProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetUserGroupQueryParams,
    GetUserGroupPathParams
  >,
  'path'
> &
  GetUserGroupPathParams

/**
 * Get a User Group
 */
export const GetUserGroup = ({ identifier, ...props }: GetUserGroupProps) => (
  <Get<ResponseUserGroupDTO, Failure | AccessControlCheckError | Error, GetUserGroupQueryParams, GetUserGroupPathParams>
    path={`/user-groups/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserGroupProps = Omit<
  UseGetProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetUserGroupQueryParams,
    GetUserGroupPathParams
  >,
  'path'
> &
  GetUserGroupPathParams

/**
 * Get a User Group
 */
export const useGetUserGroup = ({ identifier, ...props }: UseGetUserGroupProps) =>
  useGet<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetUserGroupQueryParams,
    GetUserGroupPathParams
  >((paramsInPath: GetUserGroupPathParams) => `/user-groups/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Get a User Group
 */
export const getUserGroupPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetUserGroupQueryParams,
    GetUserGroupPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    GetUserGroupQueryParams,
    GetUserGroupPathParams
  >(getConfig('ng/api'), `/user-groups/${identifier}`, props, signal)

export interface RemoveMemberQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface RemoveMemberPathParams {
  identifier: string
}

export type RemoveMemberProps = Omit<
  MutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  >,
  'path' | 'verb'
> &
  RemoveMemberPathParams

/**
 * Remove a user from the user group
 */
export const RemoveMember = ({ identifier, ...props }: RemoveMemberProps) => (
  <Mutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  >
    verb="DELETE"
    path={`/user-groups/${identifier}/member`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRemoveMemberProps = Omit<
  UseMutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  >,
  'path' | 'verb'
> &
  RemoveMemberPathParams

/**
 * Remove a user from the user group
 */
export const useRemoveMember = ({ identifier, ...props }: UseRemoveMemberProps) =>
  useMutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  >('DELETE', (paramsInPath: RemoveMemberPathParams) => `/user-groups/${paramsInPath.identifier}/member`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Remove a user from the user group
 */
export const removeMemberPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    RemoveMemberQueryParams,
    string,
    RemoveMemberPathParams
  >('DELETE', getConfig('ng/api'), `/user-groups/${identifier}/member`, props, signal)

export interface CheckMemberQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface CheckMemberPathParams {
  identifier: string
  userIdentifier: string
}

export type CheckMemberProps = Omit<
  GetProps<ResponseBoolean, Failure | AccessControlCheckError | Error, CheckMemberQueryParams, CheckMemberPathParams>,
  'path'
> &
  CheckMemberPathParams

/**
 * Check if the user is part of the user group
 */
export const CheckMember = ({ identifier, userIdentifier, ...props }: CheckMemberProps) => (
  <Get<ResponseBoolean, Failure | AccessControlCheckError | Error, CheckMemberQueryParams, CheckMemberPathParams>
    path={`/user-groups/${identifier}/member/${userIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCheckMemberProps = Omit<
  UseGetProps<
    ResponseBoolean,
    Failure | AccessControlCheckError | Error,
    CheckMemberQueryParams,
    CheckMemberPathParams
  >,
  'path'
> &
  CheckMemberPathParams

/**
 * Check if the user is part of the user group
 */
export const useCheckMember = ({ identifier, userIdentifier, ...props }: UseCheckMemberProps) =>
  useGet<ResponseBoolean, Failure | AccessControlCheckError | Error, CheckMemberQueryParams, CheckMemberPathParams>(
    (paramsInPath: CheckMemberPathParams) =>
      `/user-groups/${paramsInPath.identifier}/member/${paramsInPath.userIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier, userIdentifier }, ...props }
  )

/**
 * Check if the user is part of the user group
 */
export const checkMemberPromise = (
  {
    identifier,
    userIdentifier,
    ...props
  }: GetUsingFetchProps<
    ResponseBoolean,
    Failure | AccessControlCheckError | Error,
    CheckMemberQueryParams,
    CheckMemberPathParams
  > & { identifier: string; userIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseBoolean,
    Failure | AccessControlCheckError | Error,
    CheckMemberQueryParams,
    CheckMemberPathParams
  >(getConfig('ng/api'), `/user-groups/${identifier}/member/${userIdentifier}`, props, signal)

export interface AddMemberQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface AddMemberPathParams {
  identifier: string
  userIdentifier: string
}

export type AddMemberProps = Omit<
  MutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    AddMemberQueryParams,
    void,
    AddMemberPathParams
  >,
  'path' | 'verb'
> &
  AddMemberPathParams

/**
 * Add a user to the user group
 */
export const AddMember = ({ identifier, userIdentifier, ...props }: AddMemberProps) => (
  <Mutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    AddMemberQueryParams,
    void,
    AddMemberPathParams
  >
    verb="PUT"
    path={`/user-groups/${identifier}/member/${userIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddMemberProps = Omit<
  UseMutateProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    AddMemberQueryParams,
    void,
    AddMemberPathParams
  >,
  'path' | 'verb'
> &
  AddMemberPathParams

/**
 * Add a user to the user group
 */
export const useAddMember = ({ identifier, userIdentifier, ...props }: UseAddMemberProps) =>
  useMutate<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    AddMemberQueryParams,
    void,
    AddMemberPathParams
  >(
    'PUT',
    (paramsInPath: AddMemberPathParams) =>
      `/user-groups/${paramsInPath.identifier}/member/${paramsInPath.userIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier, userIdentifier }, ...props }
  )

/**
 * Add a user to the user group
 */
export const addMemberPromise = (
  {
    identifier,
    userIdentifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    AddMemberQueryParams,
    void,
    AddMemberPathParams
  > & { identifier: string; userIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseUserGroupDTO,
    Failure | AccessControlCheckError | Error,
    AddMemberQueryParams,
    void,
    AddMemberPathParams
  >('PUT', getConfig('ng/api'), `/user-groups/${identifier}/member/${userIdentifier}`, props, signal)

export interface GetUsersInUserGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export interface GetUsersInUserGroupPathParams {
  identifier: string
}

export type GetUsersInUserGroupProps = Omit<
  MutateProps<
    ResponsePageUserMetadataDTO,
    Failure | AccessControlCheckError | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >,
  'path' | 'verb'
> &
  GetUsersInUserGroupPathParams

/**
 * List users in a user group
 */
export const GetUsersInUserGroup = ({ identifier, ...props }: GetUsersInUserGroupProps) => (
  <Mutate<
    ResponsePageUserMetadataDTO,
    Failure | AccessControlCheckError | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >
    verb="POST"
    path={`/user-groups/${identifier}/users`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUsersInUserGroupProps = Omit<
  UseMutateProps<
    ResponsePageUserMetadataDTO,
    Failure | AccessControlCheckError | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >,
  'path' | 'verb'
> &
  GetUsersInUserGroupPathParams

/**
 * List users in a user group
 */
export const useGetUsersInUserGroup = ({ identifier, ...props }: UseGetUsersInUserGroupProps) =>
  useMutate<
    ResponsePageUserMetadataDTO,
    Failure | AccessControlCheckError | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >('POST', (paramsInPath: GetUsersInUserGroupPathParams) => `/user-groups/${paramsInPath.identifier}/users`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * List users in a user group
 */
export const getUsersInUserGroupPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponsePageUserMetadataDTO,
    Failure | AccessControlCheckError | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageUserMetadataDTO,
    Failure | AccessControlCheckError | Error,
    GetUsersInUserGroupQueryParams,
    UserFilterRequestBody,
    GetUsersInUserGroupPathParams
  >('POST', getConfig('ng/api'), `/user-groups/${identifier}/users`, props, signal)

export interface LinkToSamlGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface LinkToSamlGroupPathParams {
  userGroupId: string
  samlId: string
}

export type LinkToSamlGroupProps = Omit<
  MutateProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToSamlGroupQueryParams,
    SamlLinkGroupRequest,
    LinkToSamlGroupPathParams
  >,
  'path' | 'verb'
> &
  LinkToSamlGroupPathParams

/**
 * Link to SAML group
 */
export const LinkToSamlGroup = ({ userGroupId, samlId, ...props }: LinkToSamlGroupProps) => (
  <Mutate<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToSamlGroupQueryParams,
    SamlLinkGroupRequest,
    LinkToSamlGroupPathParams
  >
    verb="PUT"
    path={`/user-groups/${userGroupId}/link/saml/${samlId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseLinkToSamlGroupProps = Omit<
  UseMutateProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToSamlGroupQueryParams,
    SamlLinkGroupRequest,
    LinkToSamlGroupPathParams
  >,
  'path' | 'verb'
> &
  LinkToSamlGroupPathParams

/**
 * Link to SAML group
 */
export const useLinkToSamlGroup = ({ userGroupId, samlId, ...props }: UseLinkToSamlGroupProps) =>
  useMutate<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToSamlGroupQueryParams,
    SamlLinkGroupRequest,
    LinkToSamlGroupPathParams
  >(
    'PUT',
    (paramsInPath: LinkToSamlGroupPathParams) =>
      `/user-groups/${paramsInPath.userGroupId}/link/saml/${paramsInPath.samlId}`,
    { base: getConfig('ng/api'), pathParams: { userGroupId, samlId }, ...props }
  )

/**
 * Link to SAML group
 */
export const linkToSamlGroupPromise = (
  {
    userGroupId,
    samlId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToSamlGroupQueryParams,
    SamlLinkGroupRequest,
    LinkToSamlGroupPathParams
  > & { userGroupId: string; samlId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    LinkToSamlGroupQueryParams,
    SamlLinkGroupRequest,
    LinkToSamlGroupPathParams
  >('PUT', getConfig('ng/api'), `/user-groups/${userGroupId}/link/saml/${samlId}`, props, signal)

export interface UnlinkSsoGroupQueryParams {
  retainMembers?: boolean
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UnlinkSsoGroupPathParams {
  userGroupId: string
}

export type UnlinkSsoGroupProps = Omit<
  MutateProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    UnlinkSsoGroupQueryParams,
    void,
    UnlinkSsoGroupPathParams
  >,
  'path' | 'verb'
> &
  UnlinkSsoGroupPathParams

/**
 * API to unlink the harness user group from SSO group
 */
export const UnlinkSsoGroup = ({ userGroupId, ...props }: UnlinkSsoGroupProps) => (
  <Mutate<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    UnlinkSsoGroupQueryParams,
    void,
    UnlinkSsoGroupPathParams
  >
    verb="PUT"
    path={`/user-groups/${userGroupId}/unlink`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUnlinkSsoGroupProps = Omit<
  UseMutateProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    UnlinkSsoGroupQueryParams,
    void,
    UnlinkSsoGroupPathParams
  >,
  'path' | 'verb'
> &
  UnlinkSsoGroupPathParams

/**
 * API to unlink the harness user group from SSO group
 */
export const useUnlinkSsoGroup = ({ userGroupId, ...props }: UseUnlinkSsoGroupProps) =>
  useMutate<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    UnlinkSsoGroupQueryParams,
    void,
    UnlinkSsoGroupPathParams
  >('PUT', (paramsInPath: UnlinkSsoGroupPathParams) => `/user-groups/${paramsInPath.userGroupId}/unlink`, {
    base: getConfig('ng/api'),
    pathParams: { userGroupId },
    ...props
  })

/**
 * API to unlink the harness user group from SSO group
 */
export const unlinkSsoGroupPromise = (
  {
    userGroupId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    UnlinkSsoGroupQueryParams,
    void,
    UnlinkSsoGroupPathParams
  > & { userGroupId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseUserGroup,
    Failure | AccessControlCheckError | Error,
    UnlinkSsoGroupQueryParams,
    void,
    UnlinkSsoGroupPathParams
  >('PUT', getConfig('ng/api'), `/user-groups/${userGroupId}/unlink`, props, signal)

export interface GetAggregatedUsersQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetAggregatedUsersProps = Omit<
  MutateProps<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>,
  'path' | 'verb'
>

/**
 * Get a page of active users for access control
 */
export const GetAggregatedUsers = (props: GetAggregatedUsersProps) => (
  <Mutate<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>
    verb="POST"
    path={`/user/aggregate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAggregatedUsersProps = Omit<
  UseMutateProps<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>,
  'path' | 'verb'
>

/**
 * Get a page of active users for access control
 */
export const useGetAggregatedUsers = (props: UseGetAggregatedUsersProps) =>
  useMutate<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>(
    'POST',
    `/user/aggregate`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get a page of active users for access control
 */
export const getAggregatedUsersPromise = (
  props: MutateUsingFetchProps<
    ResponsePageUserAggregate,
    Failure | Error,
    GetAggregatedUsersQueryParams,
    ACLAggregateFilter,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePageUserAggregate, Failure | Error, GetAggregatedUsersQueryParams, ACLAggregateFilter, void>(
    'POST',
    getConfig('ng/api'),
    `/user/aggregate`,
    props,
    signal
  )

export interface GetAggregatedUserQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetAggregatedUserPathParams {
  userId: string
}

export type GetAggregatedUserProps = Omit<
  GetProps<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>,
  'path'
> &
  GetAggregatedUserPathParams

/**
 * Get a user by userId for access control
 */
export const GetAggregatedUser = ({ userId, ...props }: GetAggregatedUserProps) => (
  <Get<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>
    path={`/user/aggregate/${userId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAggregatedUserProps = Omit<
  UseGetProps<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>,
  'path'
> &
  GetAggregatedUserPathParams

/**
 * Get a user by userId for access control
 */
export const useGetAggregatedUser = ({ userId, ...props }: UseGetAggregatedUserProps) =>
  useGet<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>(
    (paramsInPath: GetAggregatedUserPathParams) => `/user/aggregate/${paramsInPath.userId}`,
    { base: getConfig('ng/api'), pathParams: { userId }, ...props }
  )

/**
 * Get a user by userId for access control
 */
export const getAggregatedUserPromise = (
  {
    userId,
    ...props
  }: GetUsingFetchProps<
    ResponseUserAggregate,
    Failure | Error,
    GetAggregatedUserQueryParams,
    GetAggregatedUserPathParams
  > & { userId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseUserAggregate, Failure | Error, GetAggregatedUserQueryParams, GetAggregatedUserPathParams>(
    getConfig('ng/api'),
    `/user/aggregate/${userId}`,
    props,
    signal
  )

export interface GetUserAllProjectsInfoQueryParams {
  accountId?: string
  userId?: string
}

export type GetUserAllProjectsInfoProps = Omit<
  GetProps<ResponseListProject, Failure | Error, GetUserAllProjectsInfoQueryParams, void>,
  'path'
>

/**
 * get user all projects information
 */
export const GetUserAllProjectsInfo = (props: GetUserAllProjectsInfoProps) => (
  <Get<ResponseListProject, Failure | Error, GetUserAllProjectsInfoQueryParams, void>
    path={`/user/all-projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserAllProjectsInfoProps = Omit<
  UseGetProps<ResponseListProject, Failure | Error, GetUserAllProjectsInfoQueryParams, void>,
  'path'
>

/**
 * get user all projects information
 */
export const useGetUserAllProjectsInfo = (props: UseGetUserAllProjectsInfoProps) =>
  useGet<ResponseListProject, Failure | Error, GetUserAllProjectsInfoQueryParams, void>(`/user/all-projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get user all projects information
 */
export const getUserAllProjectsInfoPromise = (
  props: GetUsingFetchProps<ResponseListProject, Failure | Error, GetUserAllProjectsInfoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListProject, Failure | Error, GetUserAllProjectsInfoQueryParams, void>(
    getConfig('ng/api'),
    `/user/all-projects`,
    props,
    signal
  )

export interface GetUsersQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetUsersProps = Omit<
  MutateProps<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>,
  'path' | 'verb'
>

/**
 * Get a list of users
 */
export const GetUsers = (props: GetUsersProps) => (
  <Mutate<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>
    verb="POST"
    path={`/user/batch`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUsersProps = Omit<
  UseMutateProps<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>,
  'path' | 'verb'
>

/**
 * Get a list of users
 */
export const useGetUsers = (props: UseGetUsersProps) =>
  useMutate<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>(
    'POST',
    `/user/batch`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get a list of users
 */
export const getUsersPromise = (
  props: MutateUsingFetchProps<
    ResponsePageUserMetadataDTO,
    Failure | Error,
    GetUsersQueryParams,
    UserFilterRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePageUserMetadataDTO, Failure | Error, GetUsersQueryParams, UserFilterRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/user/batch`,
    props,
    signal
  )

export type GetCurrentUserInfoProps = Omit<GetProps<ResponseUserInfo, Failure | Error, void, void>, 'path'>

/**
 * get current user information
 */
export const GetCurrentUserInfo = (props: GetCurrentUserInfoProps) => (
  <Get<ResponseUserInfo, Failure | Error, void, void>
    path={`/user/currentUser`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCurrentUserInfoProps = Omit<UseGetProps<ResponseUserInfo, Failure | Error, void, void>, 'path'>

/**
 * get current user information
 */
export const useGetCurrentUserInfo = (props: UseGetCurrentUserInfoProps) =>
  useGet<ResponseUserInfo, Failure | Error, void, void>(`/user/currentUser`, { base: getConfig('ng/api'), ...props })

/**
 * get current user information
 */
export const getCurrentUserInfoPromise = (
  props: GetUsingFetchProps<ResponseUserInfo, Failure | Error, void, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseUserInfo, Failure | Error, void, void>(getConfig('ng/api'), `/user/currentUser`, props, signal)

export interface GetCurrentGenUsersQueryParams {
  accountIdentifier: string
  searchString?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetCurrentGenUsersProps = Omit<
  GetProps<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>,
  'path'
>

/**
 * Get users from current gen for an account
 */
export const GetCurrentGenUsers = (props: GetCurrentGenUsersProps) => (
  <Get<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>
    path={`/user/currentgen`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetCurrentGenUsersProps = Omit<
  UseGetProps<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>,
  'path'
>

/**
 * Get users from current gen for an account
 */
export const useGetCurrentGenUsers = (props: UseGetCurrentGenUsersProps) =>
  useGet<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>(`/user/currentgen`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get users from current gen for an account
 */
export const getCurrentGenUsersPromise = (
  props: GetUsingFetchProps<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageUserMetadataDTO, Failure | Error, GetCurrentGenUsersQueryParams, void>(
    getConfig('ng/api'),
    `/user/currentgen`,
    props,
    signal
  )

export interface DisableTwoFactorAuthQueryParams {
  routingId?: string
}

export type DisableTwoFactorAuthProps = Omit<
  MutateProps<ResponseUserInfo, Failure | Error, DisableTwoFactorAuthQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * disable two factor auth settings
 */
export const DisableTwoFactorAuth = (props: DisableTwoFactorAuthProps) => (
  <Mutate<ResponseUserInfo, Failure | Error, DisableTwoFactorAuthQueryParams, void, void>
    verb="PUT"
    path={`/user/disable-two-factor-auth`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDisableTwoFactorAuthProps = Omit<
  UseMutateProps<ResponseUserInfo, Failure | Error, DisableTwoFactorAuthQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * disable two factor auth settings
 */
export const useDisableTwoFactorAuth = (props: UseDisableTwoFactorAuthProps) =>
  useMutate<ResponseUserInfo, Failure | Error, DisableTwoFactorAuthQueryParams, void, void>(
    'PUT',
    `/user/disable-two-factor-auth`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * disable two factor auth settings
 */
export const disableTwoFactorAuthPromise = (
  props: MutateUsingFetchProps<ResponseUserInfo, Failure | Error, DisableTwoFactorAuthQueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserInfo, Failure | Error, DisableTwoFactorAuthQueryParams, void, void>(
    'PUT',
    getConfig('ng/api'),
    `/user/disable-two-factor-auth`,
    props,
    signal
  )

export interface EnableTwoFactorAuthQueryParams {
  routingId?: string
}

export type EnableTwoFactorAuthProps = Omit<
  MutateProps<ResponseUserInfo, Failure | Error, EnableTwoFactorAuthQueryParams, TwoFactorAuthSettingsInfo, void>,
  'path' | 'verb'
>

/**
 * enable two factor auth settings
 */
export const EnableTwoFactorAuth = (props: EnableTwoFactorAuthProps) => (
  <Mutate<ResponseUserInfo, Failure | Error, EnableTwoFactorAuthQueryParams, TwoFactorAuthSettingsInfo, void>
    verb="PUT"
    path={`/user/enable-two-factor-auth`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseEnableTwoFactorAuthProps = Omit<
  UseMutateProps<ResponseUserInfo, Failure | Error, EnableTwoFactorAuthQueryParams, TwoFactorAuthSettingsInfo, void>,
  'path' | 'verb'
>

/**
 * enable two factor auth settings
 */
export const useEnableTwoFactorAuth = (props: UseEnableTwoFactorAuthProps) =>
  useMutate<ResponseUserInfo, Failure | Error, EnableTwoFactorAuthQueryParams, TwoFactorAuthSettingsInfo, void>(
    'PUT',
    `/user/enable-two-factor-auth`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * enable two factor auth settings
 */
export const enableTwoFactorAuthPromise = (
  props: MutateUsingFetchProps<
    ResponseUserInfo,
    Failure | Error,
    EnableTwoFactorAuthQueryParams,
    TwoFactorAuthSettingsInfo,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserInfo, Failure | Error, EnableTwoFactorAuthQueryParams, TwoFactorAuthSettingsInfo, void>(
    'PUT',
    getConfig('ng/api'),
    `/user/enable-two-factor-auth`,
    props,
    signal
  )

export interface CheckIfLastAdminQueryParams {
  userId?: string
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CheckIfLastAdminProps = Omit<
  GetProps<ResponseBoolean, Failure | Error, CheckIfLastAdminQueryParams, void>,
  'path'
>

/**
 * check if user is last admin at the scope
 */
export const CheckIfLastAdmin = (props: CheckIfLastAdminProps) => (
  <Get<ResponseBoolean, Failure | Error, CheckIfLastAdminQueryParams, void>
    path={`/user/last-admin`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseCheckIfLastAdminProps = Omit<
  UseGetProps<ResponseBoolean, Failure | Error, CheckIfLastAdminQueryParams, void>,
  'path'
>

/**
 * check if user is last admin at the scope
 */
export const useCheckIfLastAdmin = (props: UseCheckIfLastAdminProps) =>
  useGet<ResponseBoolean, Failure | Error, CheckIfLastAdminQueryParams, void>(`/user/last-admin`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * check if user is last admin at the scope
 */
export const checkIfLastAdminPromise = (
  props: GetUsingFetchProps<ResponseBoolean, Failure | Error, CheckIfLastAdminQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseBoolean, Failure | Error, CheckIfLastAdminQueryParams, void>(
    getConfig('ng/api'),
    `/user/last-admin`,
    props,
    signal
  )

export type ChangeUserPasswordProps = Omit<
  MutateProps<ResponsePasswordChangeResponse, Failure | Error, void, PasswordChangeDTO, void>,
  'path' | 'verb'
>

/**
 * Change user password
 */
export const ChangeUserPassword = (props: ChangeUserPasswordProps) => (
  <Mutate<ResponsePasswordChangeResponse, Failure | Error, void, PasswordChangeDTO, void>
    verb="PUT"
    path={`/user/password`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseChangeUserPasswordProps = Omit<
  UseMutateProps<ResponsePasswordChangeResponse, Failure | Error, void, PasswordChangeDTO, void>,
  'path' | 'verb'
>

/**
 * Change user password
 */
export const useChangeUserPassword = (props: UseChangeUserPasswordProps) =>
  useMutate<ResponsePasswordChangeResponse, Failure | Error, void, PasswordChangeDTO, void>('PUT', `/user/password`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Change user password
 */
export const changeUserPasswordPromise = (
  props: MutateUsingFetchProps<ResponsePasswordChangeResponse, Failure | Error, void, PasswordChangeDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePasswordChangeResponse, Failure | Error, void, PasswordChangeDTO, void>(
    'PUT',
    getConfig('ng/api'),
    `/user/password`,
    props,
    signal
  )

export interface GetUserProjectInfoQueryParams {
  accountId?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetUserProjectInfoProps = Omit<
  GetProps<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>,
  'path'
>

/**
 * get user project information
 */
export const GetUserProjectInfo = (props: GetUserProjectInfoProps) => (
  <Get<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>
    path={`/user/projects`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetUserProjectInfoProps = Omit<
  UseGetProps<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>,
  'path'
>

/**
 * get user project information
 */
export const useGetUserProjectInfo = (props: UseGetUserProjectInfoProps) =>
  useGet<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>(`/user/projects`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * get user project information
 */
export const getUserProjectInfoPromise = (
  props: GetUsingFetchProps<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageProject, Failure | Error, GetUserProjectInfoQueryParams, void>(
    getConfig('ng/api'),
    `/user/projects`,
    props,
    signal
  )

export interface GetAccessibleProjectsCountQueryParams {
  accountIdentifier?: string
  userId?: string
  startTime?: number
  endTime?: number
}

export type GetAccessibleProjectsCountProps = Omit<
  GetProps<ResponseActiveProjectsCountDTO, Failure | Error, GetAccessibleProjectsCountQueryParams, void>,
  'path'
>

/**
 * Get count of projects accessible to a user
 */
export const GetAccessibleProjectsCount = (props: GetAccessibleProjectsCountProps) => (
  <Get<ResponseActiveProjectsCountDTO, Failure | Error, GetAccessibleProjectsCountQueryParams, void>
    path={`/user/projects-count`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetAccessibleProjectsCountProps = Omit<
  UseGetProps<ResponseActiveProjectsCountDTO, Failure | Error, GetAccessibleProjectsCountQueryParams, void>,
  'path'
>

/**
 * Get count of projects accessible to a user
 */
export const useGetAccessibleProjectsCount = (props: UseGetAccessibleProjectsCountProps) =>
  useGet<ResponseActiveProjectsCountDTO, Failure | Error, GetAccessibleProjectsCountQueryParams, void>(
    `/user/projects-count`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Get count of projects accessible to a user
 */
export const getAccessibleProjectsCountPromise = (
  props: GetUsingFetchProps<
    ResponseActiveProjectsCountDTO,
    Failure | Error,
    GetAccessibleProjectsCountQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseActiveProjectsCountDTO, Failure | Error, GetAccessibleProjectsCountQueryParams, void>(
    getConfig('ng/api'),
    `/user/projects-count`,
    props,
    signal
  )

export interface GetTwoFactorAuthSettingsPathParams {
  authMechanism: 'TOTP'
}

export type GetTwoFactorAuthSettingsProps = Omit<
  GetProps<ResponseTwoFactorAuthSettingsInfo, Failure | Error, void, GetTwoFactorAuthSettingsPathParams>,
  'path'
> &
  GetTwoFactorAuthSettingsPathParams

/**
 * get two factor auth settings
 */
export const GetTwoFactorAuthSettings = ({ authMechanism, ...props }: GetTwoFactorAuthSettingsProps) => (
  <Get<ResponseTwoFactorAuthSettingsInfo, Failure | Error, void, GetTwoFactorAuthSettingsPathParams>
    path={`/user/two-factor-auth/${authMechanism}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetTwoFactorAuthSettingsProps = Omit<
  UseGetProps<ResponseTwoFactorAuthSettingsInfo, Failure | Error, void, GetTwoFactorAuthSettingsPathParams>,
  'path'
> &
  GetTwoFactorAuthSettingsPathParams

/**
 * get two factor auth settings
 */
export const useGetTwoFactorAuthSettings = ({ authMechanism, ...props }: UseGetTwoFactorAuthSettingsProps) =>
  useGet<ResponseTwoFactorAuthSettingsInfo, Failure | Error, void, GetTwoFactorAuthSettingsPathParams>(
    (paramsInPath: GetTwoFactorAuthSettingsPathParams) => `/user/two-factor-auth/${paramsInPath.authMechanism}`,
    { base: getConfig('ng/api'), pathParams: { authMechanism }, ...props }
  )

/**
 * get two factor auth settings
 */
export const getTwoFactorAuthSettingsPromise = (
  {
    authMechanism,
    ...props
  }: GetUsingFetchProps<
    ResponseTwoFactorAuthSettingsInfo,
    Failure | Error,
    void,
    GetTwoFactorAuthSettingsPathParams
  > & { authMechanism: 'TOTP' },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTwoFactorAuthSettingsInfo, Failure | Error, void, GetTwoFactorAuthSettingsPathParams>(
    getConfig('ng/api'),
    `/user/two-factor-auth/${authMechanism}`,
    props,
    signal
  )

export interface UnlockUserQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UnlockUserPathParams {
  userId: string
}

export type UnlockUserProps = Omit<
  MutateProps<ResponseUserInfo, Failure | Error, UnlockUserQueryParams, void, UnlockUserPathParams>,
  'path' | 'verb'
> &
  UnlockUserPathParams

/**
 * unlock user
 */
export const UnlockUser = ({ userId, ...props }: UnlockUserProps) => (
  <Mutate<ResponseUserInfo, Failure | Error, UnlockUserQueryParams, void, UnlockUserPathParams>
    verb="PUT"
    path={`/user/unlock-user/${userId}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUnlockUserProps = Omit<
  UseMutateProps<ResponseUserInfo, Failure | Error, UnlockUserQueryParams, void, UnlockUserPathParams>,
  'path' | 'verb'
> &
  UnlockUserPathParams

/**
 * unlock user
 */
export const useUnlockUser = ({ userId, ...props }: UseUnlockUserProps) =>
  useMutate<ResponseUserInfo, Failure | Error, UnlockUserQueryParams, void, UnlockUserPathParams>(
    'PUT',
    (paramsInPath: UnlockUserPathParams) => `/user/unlock-user/${paramsInPath.userId}`,
    { base: getConfig('ng/api'), pathParams: { userId }, ...props }
  )

/**
 * unlock user
 */
export const unlockUserPromise = (
  {
    userId,
    ...props
  }: MutateUsingFetchProps<ResponseUserInfo, Failure | Error, UnlockUserQueryParams, void, UnlockUserPathParams> & {
    userId: string
  },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseUserInfo, Failure | Error, UnlockUserQueryParams, void, UnlockUserPathParams>(
    'PUT',
    getConfig('ng/api'),
    `/user/unlock-user/${userId}`,
    props,
    signal
  )

export interface AddUsersQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type AddUsersProps = Omit<
  MutateProps<ResponseAddUsersResponse, Failure | Error, AddUsersQueryParams, AddUsers, void>,
  'path' | 'verb'
>

/**
 * Add users to a scope
 */
export const AddUsers = (props: AddUsersProps) => (
  <Mutate<ResponseAddUsersResponse, Failure | Error, AddUsersQueryParams, AddUsers, void>
    verb="POST"
    path={`/user/users`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddUsersProps = Omit<
  UseMutateProps<ResponseAddUsersResponse, Failure | Error, AddUsersQueryParams, AddUsers, void>,
  'path' | 'verb'
>

/**
 * Add users to a scope
 */
export const useAddUsers = (props: UseAddUsersProps) =>
  useMutate<ResponseAddUsersResponse, Failure | Error, AddUsersQueryParams, AddUsers, void>('POST', `/user/users`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Add users to a scope
 */
export const addUsersPromise = (
  props: MutateUsingFetchProps<ResponseAddUsersResponse, Failure | Error, AddUsersQueryParams, AddUsers, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseAddUsersResponse, Failure | Error, AddUsersQueryParams, AddUsers, void>(
    'POST',
    getConfig('ng/api'),
    `/user/users`,
    props,
    signal
  )

export interface RemoveUserQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type RemoveUserProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Remove user as the collaborator from the scope
 */
export const RemoveUser = (props: RemoveUserProps) => (
  <Mutate<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>
    verb="DELETE"
    path={`/user`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseRemoveUserProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Remove user as the collaborator from the scope
 */
export const useRemoveUser = (props: UseRemoveUserProps) =>
  useMutate<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>('DELETE', `/user`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Remove user as the collaborator from the scope
 */
export const removeUserPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, RemoveUserQueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/user`,
    props,
    signal
  )

export interface ListDelegateConfigsNgV2QueryParams {
  offset?: string
  limit?: string
  fieldsIncluded?: string[]
  fieldsExcluded?: string[]
  orgId?: string
  projectId?: string
}

export interface ListDelegateConfigsNgV2PathParams {
  accountId: string
}

export type ListDelegateConfigsNgV2Props = Omit<
  GetProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2QueryParams,
    ListDelegateConfigsNgV2PathParams
  >,
  'path'
> &
  ListDelegateConfigsNgV2PathParams

/**
 * Lists the Delegate Configurations
 */
export const ListDelegateConfigsNgV2 = ({ accountId, ...props }: ListDelegateConfigsNgV2Props) => (
  <Get<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2QueryParams,
    ListDelegateConfigsNgV2PathParams
  >
    path={`/v2/accounts/${accountId}/delegate-configs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListDelegateConfigsNgV2Props = Omit<
  UseGetProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2QueryParams,
    ListDelegateConfigsNgV2PathParams
  >,
  'path'
> &
  ListDelegateConfigsNgV2PathParams

/**
 * Lists the Delegate Configurations
 */
export const useListDelegateConfigsNgV2 = ({ accountId, ...props }: UseListDelegateConfigsNgV2Props) =>
  useGet<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2QueryParams,
    ListDelegateConfigsNgV2PathParams
  >((paramsInPath: ListDelegateConfigsNgV2PathParams) => `/v2/accounts/${paramsInPath.accountId}/delegate-configs`, {
    base: getConfig('ng/api'),
    pathParams: { accountId },
    ...props
  })

/**
 * Lists the Delegate Configurations
 */
export const listDelegateConfigsNgV2Promise = (
  {
    accountId,
    ...props
  }: GetUsingFetchProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2QueryParams,
    ListDelegateConfigsNgV2PathParams
  > & { accountId: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2QueryParams,
    ListDelegateConfigsNgV2PathParams
  >(getConfig('ng/api'), `/v2/accounts/${accountId}/delegate-configs`, props, signal)

export interface AddDelegateProfileNgV2PathParams {
  accountId: string
}

export type AddDelegateProfileNgV2Props = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    AddDelegateProfileNgV2PathParams
  >,
  'path' | 'verb'
> &
  AddDelegateProfileNgV2PathParams

/**
 * Adds a Delegate profile
 */
export const AddDelegateProfileNgV2 = ({ accountId, ...props }: AddDelegateProfileNgV2Props) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    AddDelegateProfileNgV2PathParams
  >
    verb="POST"
    path={`/v2/accounts/${accountId}/delegate-configs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddDelegateProfileNgV2Props = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    AddDelegateProfileNgV2PathParams
  >,
  'path' | 'verb'
> &
  AddDelegateProfileNgV2PathParams

/**
 * Adds a Delegate profile
 */
export const useAddDelegateProfileNgV2 = ({ accountId, ...props }: UseAddDelegateProfileNgV2Props) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    AddDelegateProfileNgV2PathParams
  >(
    'POST',
    (paramsInPath: AddDelegateProfileNgV2PathParams) => `/v2/accounts/${paramsInPath.accountId}/delegate-configs`,
    { base: getConfig('ng/api'), pathParams: { accountId }, ...props }
  )

/**
 * Adds a Delegate profile
 */
export const addDelegateProfileNgV2Promise = (
  {
    accountId,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    AddDelegateProfileNgV2PathParams
  > & { accountId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    AddDelegateProfileNgV2PathParams
  >('POST', getConfig('ng/api'), `/v2/accounts/${accountId}/delegate-configs`, props, signal)

export interface ListDelegateConfigsNgV2WithFilterQueryParams {
  orgId?: string
  projectId?: string
  filterIdentifier?: string
  searchTerm?: string
  offset?: string
  limit?: string
  fieldsIncluded?: string[]
  fieldsExcluded?: string[]
}

export interface ListDelegateConfigsNgV2WithFilterPathParams {
  accountId: string
}

export type ListDelegateConfigsNgV2WithFilterProps = Omit<
  MutateProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2WithFilterQueryParams,
    DelegateProfileFilterProperties,
    ListDelegateConfigsNgV2WithFilterPathParams
  >,
  'path' | 'verb'
> &
  ListDelegateConfigsNgV2WithFilterPathParams

/**
 * Lists the Delegate configs with filter
 */
export const ListDelegateConfigsNgV2WithFilter = ({ accountId, ...props }: ListDelegateConfigsNgV2WithFilterProps) => (
  <Mutate<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2WithFilterQueryParams,
    DelegateProfileFilterProperties,
    ListDelegateConfigsNgV2WithFilterPathParams
  >
    verb="POST"
    path={`/v2/accounts/${accountId}/delegate-configs/listV2`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListDelegateConfigsNgV2WithFilterProps = Omit<
  UseMutateProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2WithFilterQueryParams,
    DelegateProfileFilterProperties,
    ListDelegateConfigsNgV2WithFilterPathParams
  >,
  'path' | 'verb'
> &
  ListDelegateConfigsNgV2WithFilterPathParams

/**
 * Lists the Delegate configs with filter
 */
export const useListDelegateConfigsNgV2WithFilter = ({
  accountId,
  ...props
}: UseListDelegateConfigsNgV2WithFilterProps) =>
  useMutate<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2WithFilterQueryParams,
    DelegateProfileFilterProperties,
    ListDelegateConfigsNgV2WithFilterPathParams
  >(
    'POST',
    (paramsInPath: ListDelegateConfigsNgV2WithFilterPathParams) =>
      `/v2/accounts/${paramsInPath.accountId}/delegate-configs/listV2`,
    { base: getConfig('ng/api'), pathParams: { accountId }, ...props }
  )

/**
 * Lists the Delegate configs with filter
 */
export const listDelegateConfigsNgV2WithFilterPromise = (
  {
    accountId,
    ...props
  }: MutateUsingFetchProps<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2WithFilterQueryParams,
    DelegateProfileFilterProperties,
    ListDelegateConfigsNgV2WithFilterPathParams
  > & { accountId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponsePageResponseDelegateProfileDetailsNg,
    unknown,
    ListDelegateConfigsNgV2WithFilterQueryParams,
    DelegateProfileFilterProperties,
    ListDelegateConfigsNgV2WithFilterPathParams
  >('POST', getConfig('ng/api'), `/v2/accounts/${accountId}/delegate-configs/listV2`, props, signal)

export interface DeleteDelegateConfigNgV2QueryParams {
  orgId?: string
  projectId?: string
}

export interface DeleteDelegateConfigNgV2PathParams {
  accountId: string
}

export type DeleteDelegateConfigNgV2Props = Omit<
  MutateProps<
    ResponseBoolean,
    unknown,
    DeleteDelegateConfigNgV2QueryParams,
    string,
    DeleteDelegateConfigNgV2PathParams
  >,
  'path' | 'verb'
> &
  DeleteDelegateConfigNgV2PathParams

/**
 * Deletes a Delegate config by identifier
 */
export const DeleteDelegateConfigNgV2 = ({ accountId, ...props }: DeleteDelegateConfigNgV2Props) => (
  <Mutate<ResponseBoolean, unknown, DeleteDelegateConfigNgV2QueryParams, string, DeleteDelegateConfigNgV2PathParams>
    verb="DELETE"
    path={`/v2/accounts/${accountId}/delegate-configs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteDelegateConfigNgV2Props = Omit<
  UseMutateProps<
    ResponseBoolean,
    unknown,
    DeleteDelegateConfigNgV2QueryParams,
    string,
    DeleteDelegateConfigNgV2PathParams
  >,
  'path' | 'verb'
> &
  DeleteDelegateConfigNgV2PathParams

/**
 * Deletes a Delegate config by identifier
 */
export const useDeleteDelegateConfigNgV2 = ({ accountId, ...props }: UseDeleteDelegateConfigNgV2Props) =>
  useMutate<ResponseBoolean, unknown, DeleteDelegateConfigNgV2QueryParams, string, DeleteDelegateConfigNgV2PathParams>(
    'DELETE',
    (paramsInPath: DeleteDelegateConfigNgV2PathParams) => `/v2/accounts/${paramsInPath.accountId}/delegate-configs`,
    { base: getConfig('ng/api'), pathParams: { accountId }, ...props }
  )

/**
 * Deletes a Delegate config by identifier
 */
export const deleteDelegateConfigNgV2Promise = (
  {
    accountId,
    ...props
  }: MutateUsingFetchProps<
    ResponseBoolean,
    unknown,
    DeleteDelegateConfigNgV2QueryParams,
    string,
    DeleteDelegateConfigNgV2PathParams
  > & { accountId: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    unknown,
    DeleteDelegateConfigNgV2QueryParams,
    string,
    DeleteDelegateConfigNgV2PathParams
  >('DELETE', getConfig('ng/api'), `/v2/accounts/${accountId}/delegate-configs`, props, signal)

export interface GetDelegateConfigNgV2QueryParams {
  orgId?: string
  projectId?: string
}

export interface GetDelegateConfigNgV2PathParams {
  accountId: string
  delegateConfigIdentifier: string
}

export type GetDelegateConfigNgV2Props = Omit<
  GetProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateConfigNgV2QueryParams,
    GetDelegateConfigNgV2PathParams
  >,
  'path'
> &
  GetDelegateConfigNgV2PathParams

/**
 * Gets Delegate config by identifier
 */
export const GetDelegateConfigNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: GetDelegateConfigNgV2Props) => (
  <Get<RestResponseDelegateProfileDetailsNg, unknown, GetDelegateConfigNgV2QueryParams, GetDelegateConfigNgV2PathParams>
    path={`/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetDelegateConfigNgV2Props = Omit<
  UseGetProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateConfigNgV2QueryParams,
    GetDelegateConfigNgV2PathParams
  >,
  'path'
> &
  GetDelegateConfigNgV2PathParams

/**
 * Gets Delegate config by identifier
 */
export const useGetDelegateConfigNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: UseGetDelegateConfigNgV2Props) =>
  useGet<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateConfigNgV2QueryParams,
    GetDelegateConfigNgV2PathParams
  >(
    (paramsInPath: GetDelegateConfigNgV2PathParams) =>
      `/v2/accounts/${paramsInPath.accountId}/delegate-configs/${paramsInPath.delegateConfigIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountId, delegateConfigIdentifier }, ...props }
  )

/**
 * Gets Delegate config by identifier
 */
export const getDelegateConfigNgV2Promise = (
  {
    accountId,
    delegateConfigIdentifier,
    ...props
  }: GetUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateConfigNgV2QueryParams,
    GetDelegateConfigNgV2PathParams
  > & { accountId: string; delegateConfigIdentifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    GetDelegateConfigNgV2QueryParams,
    GetDelegateConfigNgV2PathParams
  >(getConfig('ng/api'), `/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}`, props, signal)

export interface UpdateDelegateConfigNgV2QueryParams {
  orgId?: string
  projectId?: string
}

export interface UpdateDelegateConfigNgV2PathParams {
  accountId: string
  delegateConfigIdentifier: string
}

export type UpdateDelegateConfigNgV2Props = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateConfigNgV2QueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateConfigNgV2PathParams
  >,
  'path' | 'verb'
> &
  UpdateDelegateConfigNgV2PathParams

/**
 * Updates a Delegate Configuration
 */
export const UpdateDelegateConfigNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: UpdateDelegateConfigNgV2Props) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateConfigNgV2QueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateConfigNgV2PathParams
  >
    verb="PUT"
    path={`/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateDelegateConfigNgV2Props = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateConfigNgV2QueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateConfigNgV2PathParams
  >,
  'path' | 'verb'
> &
  UpdateDelegateConfigNgV2PathParams

/**
 * Updates a Delegate Configuration
 */
export const useUpdateDelegateConfigNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: UseUpdateDelegateConfigNgV2Props) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateConfigNgV2QueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateConfigNgV2PathParams
  >(
    'PUT',
    (paramsInPath: UpdateDelegateConfigNgV2PathParams) =>
      `/v2/accounts/${paramsInPath.accountId}/delegate-configs/${paramsInPath.delegateConfigIdentifier}`,
    { base: getConfig('ng/api'), pathParams: { accountId, delegateConfigIdentifier }, ...props }
  )

/**
 * Updates a Delegate Configuration
 */
export const updateDelegateConfigNgV2Promise = (
  {
    accountId,
    delegateConfigIdentifier,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateConfigNgV2QueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateConfigNgV2PathParams
  > & { accountId: string; delegateConfigIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateDelegateConfigNgV2QueryParams,
    DelegateProfileDetailsNgRequestBody,
    UpdateDelegateConfigNgV2PathParams
  >('PUT', getConfig('ng/api'), `/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}`, props, signal)

export interface UpdateScopingRulesNgV2QueryParams {
  orgId?: string
  projectId?: string
}

export interface UpdateScopingRulesNgV2PathParams {
  accountId: string
  delegateConfigIdentifier: string
}

export type UpdateScopingRulesNgV2Props = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgV2QueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgV2PathParams
  >,
  'path' | 'verb'
> &
  UpdateScopingRulesNgV2PathParams

/**
 * Updates the Scoping Rules inside the Delegate config
 */
export const UpdateScopingRulesNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: UpdateScopingRulesNgV2Props) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgV2QueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgV2PathParams
  >
    verb="PUT"
    path={`/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}/scoping-rules`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateScopingRulesNgV2Props = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgV2QueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgV2PathParams
  >,
  'path' | 'verb'
> &
  UpdateScopingRulesNgV2PathParams

/**
 * Updates the Scoping Rules inside the Delegate config
 */
export const useUpdateScopingRulesNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: UseUpdateScopingRulesNgV2Props) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgV2QueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgV2PathParams
  >(
    'PUT',
    (paramsInPath: UpdateScopingRulesNgV2PathParams) =>
      `/v2/accounts/${paramsInPath.accountId}/delegate-configs/${paramsInPath.delegateConfigIdentifier}/scoping-rules`,
    { base: getConfig('ng/api'), pathParams: { accountId, delegateConfigIdentifier }, ...props }
  )

/**
 * Updates the Scoping Rules inside the Delegate config
 */
export const updateScopingRulesNgV2Promise = (
  {
    accountId,
    delegateConfigIdentifier,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgV2QueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgV2PathParams
  > & { accountId: string; delegateConfigIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateScopingRulesNgV2QueryParams,
    ScopingRuleDetailsNgArrayRequestBody,
    UpdateScopingRulesNgV2PathParams
  >(
    'PUT',
    getConfig('ng/api'),
    `/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}/scoping-rules`,
    props,
    signal
  )

export interface UpdateSelectorsNgV2QueryParams {
  orgId?: string
  projectId?: string
}

export interface UpdateSelectorsNgV2PathParams {
  accountId: string
  delegateConfigIdentifier: string
}

export type UpdateSelectorsNgV2Props = Omit<
  MutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgV2QueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgV2PathParams
  >,
  'path' | 'verb'
> &
  UpdateSelectorsNgV2PathParams

/**
 * Updates the selectors inside the Delegate config
 */
export const UpdateSelectorsNgV2 = ({ accountId, delegateConfigIdentifier, ...props }: UpdateSelectorsNgV2Props) => (
  <Mutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgV2QueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgV2PathParams
  >
    verb="PUT"
    path={`/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}/selectors`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseUpdateSelectorsNgV2Props = Omit<
  UseMutateProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgV2QueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgV2PathParams
  >,
  'path' | 'verb'
> &
  UpdateSelectorsNgV2PathParams

/**
 * Updates the selectors inside the Delegate config
 */
export const useUpdateSelectorsNgV2 = ({
  accountId,
  delegateConfigIdentifier,
  ...props
}: UseUpdateSelectorsNgV2Props) =>
  useMutate<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgV2QueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgV2PathParams
  >(
    'PUT',
    (paramsInPath: UpdateSelectorsNgV2PathParams) =>
      `/v2/accounts/${paramsInPath.accountId}/delegate-configs/${paramsInPath.delegateConfigIdentifier}/selectors`,
    { base: getConfig('ng/api'), pathParams: { accountId, delegateConfigIdentifier }, ...props }
  )

/**
 * Updates the selectors inside the Delegate config
 */
export const updateSelectorsNgV2Promise = (
  {
    accountId,
    delegateConfigIdentifier,
    ...props
  }: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgV2QueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgV2PathParams
  > & { accountId: string; delegateConfigIdentifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    UpdateSelectorsNgV2QueryParams,
    UpdateWhitelistedDomainsBodyRequestBody,
    UpdateSelectorsNgV2PathParams
  >(
    'PUT',
    getConfig('ng/api'),
    `/v2/accounts/${accountId}/delegate-configs/${delegateConfigIdentifier}/selectors`,
    props,
    signal
  )

export type AddDelegateProfileNgV2noQueryParamsV2Props = Omit<
  MutateProps<RestResponseDelegateProfileDetailsNg, unknown, void, DelegateProfileDetailsNgRequestBody, void>,
  'path' | 'verb'
>

/**
 * Adds a Delegate profile
 */
export const AddDelegateProfileNgV2noQueryParamsV2 = (props: AddDelegateProfileNgV2noQueryParamsV2Props) => (
  <Mutate<RestResponseDelegateProfileDetailsNg, unknown, void, DelegateProfileDetailsNgRequestBody, void>
    verb="POST"
    path={`/v2/delegate-configs`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseAddDelegateProfileNgV2noQueryParamsV2Props = Omit<
  UseMutateProps<RestResponseDelegateProfileDetailsNg, unknown, void, DelegateProfileDetailsNgRequestBody, void>,
  'path' | 'verb'
>

/**
 * Adds a Delegate profile
 */
export const useAddDelegateProfileNgV2noQueryParamsV2 = (props: UseAddDelegateProfileNgV2noQueryParamsV2Props) =>
  useMutate<RestResponseDelegateProfileDetailsNg, unknown, void, DelegateProfileDetailsNgRequestBody, void>(
    'POST',
    `/v2/delegate-configs`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Adds a Delegate profile
 */
export const addDelegateProfileNgV2noQueryParamsV2Promise = (
  props: MutateUsingFetchProps<
    RestResponseDelegateProfileDetailsNg,
    unknown,
    void,
    DelegateProfileDetailsNgRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<RestResponseDelegateProfileDetailsNg, unknown, void, DelegateProfileDetailsNgRequestBody, void>(
    'POST',
    getConfig('ng/api'),
    `/v2/delegate-configs`,
    props,
    signal
  )

export interface ListSecretsV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifiers?: string[]
  type?: 'SecretFile' | 'SecretText' | 'SSHKey'
  searchTerm?: string
  types?: ('SecretFile' | 'SecretText' | 'SSHKey')[]
  source_category?:
    | 'CLOUD_PROVIDER'
    | 'SECRET_MANAGER'
    | 'CLOUD_COST'
    | 'ARTIFACTORY'
    | 'CODE_REPO'
    | 'MONITORING'
    | 'TICKETING'
  includeSecretsFromEverySubScope?: boolean
  pageIndex?: number
  pageSize?: number
}

export type ListSecretsV2Props = Omit<
  GetProps<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>,
  'path'
>

/**
 * Get secrets
 */
export const ListSecretsV2 = (props: ListSecretsV2Props) => (
  <Get<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>
    path={`/v2/secrets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListSecretsV2Props = Omit<
  UseGetProps<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>,
  'path'
>

/**
 * Get secrets
 */
export const useListSecretsV2 = (props: UseListSecretsV2Props) =>
  useGet<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>(`/v2/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get secrets
 */
export const listSecretsV2Promise = (
  props: GetUsingFetchProps<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV2QueryParams, void>(
    getConfig('ng/api'),
    `/v2/secrets`,
    props,
    signal
  )

export interface PostSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  privateSecret?: boolean
}

export type PostSecretProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret
 */
export const PostSecret = (props: PostSecretProps) => (
  <Mutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretQueryParams, SecretRequestWrapperRequestBody, void>
    verb="POST"
    path={`/v2/secrets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret
 */
export const usePostSecret = (props: UsePostSecretProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >('POST', `/v2/secrets`, { base: getConfig('ng/api'), ...props })

/**
 * Create a secret
 */
export const postSecretPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretQueryParams,
    SecretRequestWrapperRequestBody,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets`, props, signal)

export interface PostSecretFileV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  privateSecret?: boolean
}

export type PostSecretFileV2Props = Omit<
  MutateProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a secret file
 */
export const PostSecretFileV2 = (props: PostSecretFileV2Props) => (
  <Mutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>
    verb="POST"
    path={`/v2/secrets/files`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretFileV2Props = Omit<
  UseMutateProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Create a secret file
 */
export const usePostSecretFileV2 = (props: UsePostSecretFileV2Props) =>
  useMutate<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>(
    'POST',
    `/v2/secrets/files`,
    { base: getConfig('ng/api'), ...props }
  )

/**
 * Create a secret file
 */
export const postSecretFileV2Promise = (
  props: MutateUsingFetchProps<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseSecretResponseWrapper, Failure | Error, PostSecretFileV2QueryParams, void, void>(
    'POST',
    getConfig('ng/api'),
    `/v2/secrets/files`,
    props,
    signal
  )

export interface PutSecretFileV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface PutSecretFileV2PathParams {
  identifier: string
}

export type PutSecretFileV2Props = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >,
  'path' | 'verb'
> &
  PutSecretFileV2PathParams

/**
 * Update a secret file
 */
export const PutSecretFileV2 = ({ identifier, ...props }: PutSecretFileV2Props) => (
  <Mutate<ResponseSecretResponseWrapper, Failure | Error, PutSecretFileV2QueryParams, void, PutSecretFileV2PathParams>
    verb="PUT"
    path={`/v2/secrets/files/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretFileV2Props = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >,
  'path' | 'verb'
> &
  PutSecretFileV2PathParams

/**
 * Update a secret file
 */
export const usePutSecretFileV2 = ({ identifier, ...props }: UsePutSecretFileV2Props) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >('PUT', (paramsInPath: PutSecretFileV2PathParams) => `/v2/secrets/files/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret file
 */
export const putSecretFileV2Promise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretFileV2QueryParams,
    void,
    PutSecretFileV2PathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/files/${identifier}`, props, signal)

export interface ListSecretsV3QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  pageIndex?: number
  pageSize?: number
}

export type ListSecretsV3Props = Omit<
  MutateProps<
    ResponsePageSecretResponseWrapper,
    Failure | Error,
    ListSecretsV3QueryParams,
    SecretResourceFilterDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * List secrets
 */
export const ListSecretsV3 = (props: ListSecretsV3Props) => (
  <Mutate<ResponsePageSecretResponseWrapper, Failure | Error, ListSecretsV3QueryParams, SecretResourceFilterDTO, void>
    verb="POST"
    path={`/v2/secrets/list`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseListSecretsV3Props = Omit<
  UseMutateProps<
    ResponsePageSecretResponseWrapper,
    Failure | Error,
    ListSecretsV3QueryParams,
    SecretResourceFilterDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * List secrets
 */
export const useListSecretsV3 = (props: UseListSecretsV3Props) =>
  useMutate<
    ResponsePageSecretResponseWrapper,
    Failure | Error,
    ListSecretsV3QueryParams,
    SecretResourceFilterDTO,
    void
  >('POST', `/v2/secrets/list`, { base: getConfig('ng/api'), ...props })

/**
 * List secrets
 */
export const listSecretsV3Promise = (
  props: MutateUsingFetchProps<
    ResponsePageSecretResponseWrapper,
    Failure | Error,
    ListSecretsV3QueryParams,
    SecretResourceFilterDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageSecretResponseWrapper,
    Failure | Error,
    ListSecretsV3QueryParams,
    SecretResourceFilterDTO,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/list`, props, signal)

export interface ValidateSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  identifier?: string
}

export type ValidateSecretProps = Omit<
  MutateProps<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a secret
 */
export const ValidateSecret = (props: ValidateSecretProps) => (
  <Mutate<ResponseSecretValidationResultDTO, Failure | Error, ValidateSecretQueryParams, SecretValidationMetaData, void>
    verb="POST"
    path={`/v2/secrets/validate`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateSecretProps = Omit<
  UseMutateProps<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  'path' | 'verb'
>

/**
 * Validate a secret
 */
export const useValidateSecret = (props: UseValidateSecretProps) =>
  useMutate<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >('POST', `/v2/secrets/validate`, { base: getConfig('ng/api'), ...props })

/**
 * Validate a secret
 */
export const validateSecretPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretValidationResultDTO,
    Failure | Error,
    ValidateSecretQueryParams,
    SecretValidationMetaData,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/validate`, props, signal)

export interface ValidateSecretIdentifierIsUniqueQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ValidateSecretIdentifierIsUniquePathParams {
  identifier: string
}

export type ValidateSecretIdentifierIsUniqueProps = Omit<
  GetProps<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >,
  'path'
> &
  ValidateSecretIdentifierIsUniquePathParams

/**
 * Validate Secret Identifier is unique
 */
export const ValidateSecretIdentifierIsUnique = ({ identifier, ...props }: ValidateSecretIdentifierIsUniqueProps) => (
  <Get<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >
    path={`/v2/secrets/validateUniqueIdentifier/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseValidateSecretIdentifierIsUniqueProps = Omit<
  UseGetProps<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >,
  'path'
> &
  ValidateSecretIdentifierIsUniquePathParams

/**
 * Validate Secret Identifier is unique
 */
export const useValidateSecretIdentifierIsUnique = ({
  identifier,
  ...props
}: UseValidateSecretIdentifierIsUniqueProps) =>
  useGet<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >(
    (paramsInPath: ValidateSecretIdentifierIsUniquePathParams) =>
      `/v2/secrets/validateUniqueIdentifier/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Validate Secret Identifier is unique
 */
export const validateSecretIdentifierIsUniquePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseBoolean,
    Failure | Error,
    ValidateSecretIdentifierIsUniqueQueryParams,
    ValidateSecretIdentifierIsUniquePathParams
  >(getConfig('ng/api'), `/v2/secrets/validateUniqueIdentifier/${identifier}`, props, signal)

export interface PostSecretViaYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  privateSecret?: boolean
}

export type PostSecretViaYamlProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret via yaml
 */
export const PostSecretViaYaml = (props: PostSecretViaYamlProps) => (
  <Mutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >
    verb="POST"
    path={`/v2/secrets/yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePostSecretViaYamlProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a secret via yaml
 */
export const usePostSecretViaYaml = (props: UsePostSecretViaYamlProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >('POST', `/v2/secrets/yaml`, { base: getConfig('ng/api'), ...props })

/**
 * Create a secret via yaml
 */
export const postSecretViaYamlPromise = (
  props: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PostSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    void
  >('POST', getConfig('ng/api'), `/v2/secrets/yaml`, props, signal)

export interface DeleteSecretV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteSecretV2Props = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret
 */
export const DeleteSecretV2 = (props: DeleteSecretV2Props) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>
    verb="DELETE"
    path={`/v2/secrets`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseDeleteSecretV2Props = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete secret
 */
export const useDeleteSecretV2 = (props: UseDeleteSecretV2Props) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>('DELETE', `/v2/secrets`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Delete secret
 */
export const deleteSecretV2Promise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteSecretV2QueryParams, string, void>(
    'DELETE',
    getConfig('ng/api'),
    `/v2/secrets`,
    props,
    signal
  )

export interface GetSecretV2QueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetSecretV2PathParams {
  identifier: string
}

export type GetSecretV2Props = Omit<
  GetProps<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>,
  'path'
> &
  GetSecretV2PathParams

/**
 * Gets secret
 */
export const GetSecretV2 = ({ identifier, ...props }: GetSecretV2Props) => (
  <Get<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>
    path={`/v2/secrets/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetSecretV2Props = Omit<
  UseGetProps<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>,
  'path'
> &
  GetSecretV2PathParams

/**
 * Gets secret
 */
export const useGetSecretV2 = ({ identifier, ...props }: UseGetSecretV2Props) =>
  useGet<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>(
    (paramsInPath: GetSecretV2PathParams) => `/v2/secrets/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Gets secret
 */
export const getSecretV2Promise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    GetSecretV2QueryParams,
    GetSecretV2PathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseSecretResponseWrapper, Failure | Error, GetSecretV2QueryParams, GetSecretV2PathParams>(
    getConfig('ng/api'),
    `/v2/secrets/${identifier}`,
    props,
    signal
  )

export interface PutSecretQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface PutSecretPathParams {
  identifier: string
}

export type PutSecretProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >,
  'path' | 'verb'
> &
  PutSecretPathParams

/**
 * Update a secret
 */
export const PutSecret = ({ identifier, ...props }: PutSecretProps) => (
  <Mutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >
    verb="PUT"
    path={`/v2/secrets/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >,
  'path' | 'verb'
> &
  PutSecretPathParams

/**
 * Update a secret
 */
export const usePutSecret = ({ identifier, ...props }: UsePutSecretProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >('PUT', (paramsInPath: PutSecretPathParams) => `/v2/secrets/${paramsInPath.identifier}`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret
 */
export const putSecretPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretQueryParams,
    SecretRequestWrapperRequestBody,
    PutSecretPathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/${identifier}`, props, signal)

export interface PutSecretViaYamlQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface PutSecretViaYamlPathParams {
  identifier: string
}

export type PutSecretViaYamlProps = Omit<
  MutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretViaYamlPathParams

/**
 * Update a secret via yaml
 */
export const PutSecretViaYaml = ({ identifier, ...props }: PutSecretViaYamlProps) => (
  <Mutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >
    verb="PUT"
    path={`/v2/secrets/${identifier}/yaml`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UsePutSecretViaYamlProps = Omit<
  UseMutateProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >,
  'path' | 'verb'
> &
  PutSecretViaYamlPathParams

/**
 * Update a secret via yaml
 */
export const usePutSecretViaYaml = ({ identifier, ...props }: UsePutSecretViaYamlProps) =>
  useMutate<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >('PUT', (paramsInPath: PutSecretViaYamlPathParams) => `/v2/secrets/${paramsInPath.identifier}/yaml`, {
    base: getConfig('ng/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a secret via yaml
 */
export const putSecretViaYamlPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseSecretResponseWrapper,
    Failure | Error,
    PutSecretViaYamlQueryParams,
    SecretRequestWrapper2RequestBody,
    PutSecretViaYamlPathParams
  >('PUT', getConfig('ng/api'), `/v2/secrets/${identifier}/yaml`, props, signal)

export interface WebhookEndpointQueryParams {
  accountIdentifier: string
}

export type WebhookEndpointProps = Omit<
  MutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const WebhookEndpoint = (props: WebhookEndpointProps) => (
  <Mutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>
    verb="POST"
    path={`/webhook`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseWebhookEndpointProps = Omit<
  UseMutateProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * accept webhook event
 */
export const useWebhookEndpoint = (props: UseWebhookEndpointProps) =>
  useMutate<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>('POST', `/webhook`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * accept webhook event
 */
export const webhookEndpointPromise = (
  props: MutateUsingFetchProps<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseString, Failure | Error, WebhookEndpointQueryParams, string, void>(
    'POST',
    getConfig('ng/api'),
    `/webhook`,
    props,
    signal
  )

export interface GetYamlSchemaQueryParams {
  entityType:
    | 'Projects'
    | 'Pipelines'
    | 'PipelineSteps'
    | 'Http'
    | 'JiraCreate'
    | 'ShellScript'
    | 'K8sCanaryDeploy'
    | 'Connectors'
    | 'Secrets'
    | 'Service'
    | 'Environment'
    | 'InputSets'
    | 'CvConfig'
    | 'Delegates'
    | 'DelegateConfigurations'
    | 'CvVerificationJob'
    | 'IntegrationStage'
    | 'IntegrationSteps'
    | 'CvKubernetesActivitySource'
    | 'DeploymentSteps'
    | 'DeploymentStage'
    | 'ApprovalStage'
    | 'FeatureFlagStage'
    | 'Template'
    | 'Triggers'
    | 'MonitoredService'
    | 'GitRepositories'
    | 'FeatureFlags'
    | 'ServiceNowApproval'
  subtype?:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
    | 'ServiceNow'
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
  identifier?: string
  accountIdentifier: string
}

export type GetYamlSchemaProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const GetYamlSchema = (props: GetYamlSchemaProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>
    path={`/yaml-schema`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSchemaProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  'path'
>

/**
 * Get Yaml Schema
 */
export const useGetYamlSchema = (props: UseGetYamlSchemaProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>(`/yaml-schema`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Yaml Schema
 */
export const getYamlSchemaPromise = (
  props: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetYamlSchemaQueryParams, void>(
    getConfig('ng/api'),
    `/yaml-schema`,
    props,
    signal
  )

export interface GetYamlSnippetMetadataQueryParams {
  tags: (
    | 'k8s'
    | 'git'
    | 'docker'
    | 'connector'
    | 'secretmanager'
    | 'secret'
    | 'secretText'
    | 'secretFile'
    | 'sshKey'
    | 'service'
    | 'infra'
    | 'steps'
    | 'pipeline'
    | 'http'
    | 'splunk'
    | 'appdynamics'
    | 'vault'
    | 'azurekeyvault'
    | 'local'
    | 'gcpkms'
    | 'gcp'
    | 'aws'
    | 'awskms'
    | 'awssecretmanager'
    | 'artifactory'
    | 'jira'
    | 'nexus'
    | 'github'
    | 'gitlab'
    | 'bitbucket'
    | 'ceaws'
    | 'ceazure'
    | 'cek8s'
    | 'codecommit'
    | 'httphelmrepo'
    | 'newrelic'
    | 'gcpcloudcost'
    | 'prometheus'
    | 'datadog'
    | 'sumologic'
    | 'dynatrace'
    | 'pagerduty'
    | 'customhealth'
    | 'servicenow'
  )[]
}

export type GetYamlSnippetMetadataProps = Omit<
  GetProps<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>,
  'path'
>

/**
 * Get Yaml Snippet Metadata
 */
export const GetYamlSnippetMetadata = (props: GetYamlSnippetMetadataProps) => (
  <Get<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>
    path={`/yaml-snippet`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSnippetMetadataProps = Omit<
  UseGetProps<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>,
  'path'
>

/**
 * Get Yaml Snippet Metadata
 */
export const useGetYamlSnippetMetadata = (props: UseGetYamlSnippetMetadataProps) =>
  useGet<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>(`/yaml-snippet`, {
    base: getConfig('ng/api'),
    ...props
  })

/**
 * Get Yaml Snippet Metadata
 */
export const getYamlSnippetMetadataPromise = (
  props: GetUsingFetchProps<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseYamlSnippets, Failure | Error, GetYamlSnippetMetadataQueryParams, void>(
    getConfig('ng/api'),
    `/yaml-snippet`,
    props,
    signal
  )

export interface GetYamlSnippetQueryParams {
  projectIdentifier?: string
  orgIdentifier?: string
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export interface GetYamlSnippetPathParams {
  identifier: string
}

export type GetYamlSnippetProps = Omit<
  GetProps<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>,
  'path'
> &
  GetYamlSnippetPathParams

/**
 * Get Yaml Snippet
 */
export const GetYamlSnippet = ({ identifier, ...props }: GetYamlSnippetProps) => (
  <Get<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>
    path={`/yaml-snippet/${identifier}`}
    base={getConfig('ng/api')}
    {...props}
  />
)

export type UseGetYamlSnippetProps = Omit<
  UseGetProps<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>,
  'path'
> &
  GetYamlSnippetPathParams

/**
 * Get Yaml Snippet
 */
export const useGetYamlSnippet = ({ identifier, ...props }: UseGetYamlSnippetProps) =>
  useGet<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>(
    (paramsInPath: GetYamlSnippetPathParams) => `/yaml-snippet/${paramsInPath.identifier}`,
    { base: getConfig('ng/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Yaml Snippet
 */
export const getYamlSnippetPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseJsonNode, Failure | Error, GetYamlSnippetQueryParams, GetYamlSnippetPathParams>(
    getConfig('ng/api'),
    `/yaml-snippet/${identifier}`,
    props,
    signal
  )

export interface SchemafileQueryParams {
  filename?: string
}

export type SchemafileProps = Omit<GetProps<void, void, SchemafileQueryParams, void>, 'path'>

/**
 * Get Schema for the given entity type
 */
export const Schemafile = (props: SchemafileProps) => (
  <Get<void, void, SchemafileQueryParams, void> path={`/yamlschema/schemafile`} base={getConfig('ng/api')} {...props} />
)

export type UseSchemafileProps = Omit<UseGetProps<void, void, SchemafileQueryParams, void>, 'path'>

/**
 * Get Schema for the given entity type
 */
export const useSchemafile = (props: UseSchemafileProps) =>
  useGet<void, void, SchemafileQueryParams, void>(`/yamlschema/schemafile`, { base: getConfig('ng/api'), ...props })

/**
 * Get Schema for the given entity type
 */
export const schemafilePromise = (
  props: GetUsingFetchProps<void, void, SchemafileQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<void, void, SchemafileQueryParams, void>(getConfig('ng/api'), `/yamlschema/schemafile`, props, signal)
