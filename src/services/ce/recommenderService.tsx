/*
 * Copyright 2021 Harness Inc. All rights reserved.
 * Use of this source code is governed by the PolyForm Shield 1.0.0 license
 * that can be found in the licenses directory at the root of this repository, also available at
 * https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt.
 */

/* Generated by restful-react */

import React from 'react'
import { Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig } from '../config'
export const SPEC_VERSION = '0.0.1'
/**
 * ClusterRecommendationAccuracy encapsulates recommendation accuracy
 */
export interface ClusterRecommendationAccuracy {
  /**
   * Number of recommended allocatable cpus
   */
  allocatableCpu?: number
  /**
   * Number of recommended allocatable memory
   */
  allocatableMemory?: number
  /**
   * Number of recommended cpus
   */
  cpu?: number
  /**
   * Amount of master instance type prices in the recommended cluster
   */
  masterPrice?: number
  /**
   * The summarised amount of memory in the recommended cluster
   */
  memory?: number
  /**
   * Number of recommended nodes
   */
  nodes?: number
  /**
   * Number of regular instance type in the recommended cluster
   */
  regularNodes?: number
  /**
   * Amount of regular instance type prices in the recommended cluster
   */
  regularPrice?: number
  /**
   * Number of spot instance type in the recommended cluster
   */
  spotNodes?: number
  /**
   * Amount of spot instance type prices in the recommended cluster
   */
  spotPrice?: number
  /**
   * Total price in the recommended cluster
   */
  totalPrice?: number
  /**
   * Amount of worker instance type prices in the recommended cluster
   */
  workerPrice?: number
  /**
   * Availability zone in the recommendation
   */
  zone?: string
}

/**
 * ClusterRecommendationReq encapsulates the recommendation input data
 */
export interface ClusterRecommendationReq {
  /**
   * Are burst instances allowed in recommendation
   */
  allowBurst?: boolean
  /**
   * AllowOlderGen allow older generations of virtual machines (applies for EC2 only)
   */
  allowOlderGen?: boolean
  /**
   * Category specifies the virtual machine category
   */
  category?: string[]
  /**
   * Maximum number of nodes in the recommended cluster
   */
  maxNodes?: number
  /**
   * Max of CPUs requested by any Pod in the the cluster
   */
  minCpu?: number
  /**
   * Max of Memory requested by any Pod in the the cluster (GB)
   */
  minMem?: number
  /**
   * Minimum number of nodes in the recommended cluster
   */
  minNodes?: number
  /**
   * NetworkPerf specifies the network performance category
   */
  networkPerf?: string[]
  /**
   * Percentage of regular (on-demand) nodes in the recommended cluster
   */
  onDemandPct?: number
  /**
   * If true, recommended instance types will have a similar size
   */
  sameSize?: boolean
  /**
   * Total number of CPUs requested for the cluster
   */
  sumCpu?: number
  /**
   * Total number of GPUs requested for the cluster
   */
  sumGpu?: number
  /**
   * Total memory requested for the cluster (GB)
   */
  sumMem?: number
}

/**
 * ClusterRecommendationResp encapsulates recommendation result data
 */
export interface ClusterRecommendationResp {
  accuracy?: ClusterRecommendationAccuracy
  /**
   * Recommended node pools
   */
  nodePools?: NodePool[]
  /**
   * The cloud provider
   */
  provider?: string
  /**
   * Service's region
   */
  region?: string
  /**
   * Provider's service
   */
  service?: string
  /**
   * Availability zone in the recommendation - a multi-zone recommendation means that all node pools should expand to all zones
   */
  zone?: string
}

/**
 * NodePool represents a set of instances with a specific vm type
 */
export interface NodePool {
  /**
   * Role in the cluster, eg. master or worker
   */
  role?: string
  /**
   * Recommended number of nodes in the node pool
   */
  sumNodes?: number
  vm?: VirtualMachine
  /**
   * Specifies if the recommended node pool consists of regular or spot/preemptible instance types
   */
  vmClass?: string
}

export interface NodePoolDesc {
  /**
   * Instance type of VMs in the node pool
   */
  instanceType?: string
  /**
   * Number of VMs in the node pool
   */
  sumNodes?: number
  /**
   * Signals that the node pool consists of regular or spot/preemptible instance types
   */
  vmClass?: string
}

export interface Provider {
  provider?: string
  services?: string[]
}

/**
 * VirtualMachine describes an instance type
 */
export interface VirtualMachine {
  /**
   * Number of allocatable CPUs in the instance type
   */
  allocatableCpusPerVm?: number
  /**
   * Allocatable memory in the instance type (GB)
   */
  allocatableMemPerVm?: number
  /**
   * Average price of the instance (differs from on demand price in case of spot or preemptible instances)
   */
  avgPrice?: number
  /**
   * Burst signals a burst type instance
   */
  burst?: boolean
  /**
   * Instance type category
   */
  category?: string
  /**
   * Number of CPUs in the instance type
   */
  cpusPerVm?: number
  /**
   * CurrentGen the vm is of current generation
   */
  currentGen?: boolean
  /**
   * Number of GPUs in the instance type
   */
  gpusPerVm?: number
  /**
   * Memory capacity in the instance type (GB)
   */
  memPerVm?: number
  /**
   * NetworkPerf holds the network performance
   */
  networkPerf?: string
  /**
   * NetworkPerfCat holds the network performance category
   */
  networkPerfCategory?: string
  /**
   * Regular price of the instance type
   */
  onDemandPrice?: number
  /**
   * Instance type
   */
  type?: string
  /**
   * Zones
   */
  zones?: string[]
}

/**
 * SingleClusterRecommendationReq encapsulates the recommendation input data
 */
export interface RecommendClusterRequest {
  /**
   * Are burst instances allowed in recommendation
   */
  allowBurst?: boolean
  /**
   * AllowOlderGen allow older generations of virtual machines (applies for EC2 only)
   */
  allowOlderGen?: boolean
  /**
   * Category specifies the virtual machine category
   */
  category?: string[]
  /**
   * Excludes is a blacklist - a slice with vm types to be excluded from the recommendation
   */
  excludes?: string[]
  /**
   * Includes is a whitelist - a slice with vm types to be contained in the recommendation
   */
  includes?: string[]
  /**
   * Maximum number of nodes in the recommended cluster
   */
  maxNodes?: number
  /**
   * Max of CPUs requested by any Pod in the the cluster
   */
  minCpu?: number
  /**
   * Max of Memory requested by any Pod in the the cluster (GB)
   */
  minMem?: number
  /**
   * Minimum number of nodes in the recommended cluster
   */
  minNodes?: number
  /**
   * NetworkPerf specifies the network performance category
   */
  networkPerf?: string[]
  /**
   * Percentage of regular (on-demand) nodes in the recommended cluster
   */
  onDemandPct?: number
  /**
   * If true, recommended instance types will have a similar size
   */
  sameSize?: boolean
  /**
   * Total number of CPUs requested for the cluster
   */
  sumCpu?: number
  /**
   * Total number of GPUs requested for the cluster
   */
  sumGpu?: number
  /**
   * Total memory requested for the cluster (GB)
   */
  sumMem?: number
  /**
   * Availability zone that the cluster should expand to
   */
  zone?: string
}

/**
 * ClusterScaleoutRecommendationReq encapsulates the recommendation input data
 */
export interface RecommendClusterScaleOutRequest {
  /**
   * Description of the current cluster layout
   * in:body
   */
  actualLayout?: NodePoolDesc[]
  /**
   * Total desired number of CPUs in the cluster after the scale out
   */
  desiredCpu?: number
  /**
   * Total desired number of GPUs in the cluster after the scale out
   */
  desiredGpu?: number
  /**
   * Total desired memory (GB) in the cluster after the scale out
   */
  desiredMem?: number
  /**
   * Excludes is a blacklist - a slice with vm types to be excluded from the recommendation
   */
  excludes?: string[]
  /**
   * Percentage of regular (on-demand) nodes among the scale out nodes
   */
  onDemandPct?: number
  /**
   * Availability zone to be included in the recommendation
   */
  zone?: string
}

/**
 * MultiClusterRecommendationReq encapsulates the recommendation input data
 */
export interface RecommendMultiClusterRequest {
  /**
   * Are burst instances allowed in recommendation
   */
  allowBurst?: boolean
  /**
   * AllowOlderGen allow older generations of virtual machines (applies for EC2 only)
   */
  allowOlderGen?: boolean
  /**
   * Category specifies the virtual machine category
   */
  category?: string[]
  continents?: string[]
  /**
   * Excludes is a blacklist - a slice with vm types to be excluded from the recommendation
   */
  excludes?: {
    [key: string]: {
      [key: string]: string[]
    }
  }
  /**
   * Includes is a whitelist - a slice with vm types to be contained in the recommendation
   */
  includes?: {
    [key: string]: {
      [key: string]: string[]
    }
  }
  /**
   * Maximum number of nodes in the recommended cluster
   */
  maxNodes?: number
  /**
   * Max of CPUs requested by any Pod in the the cluster
   */
  minCpu?: number
  /**
   * Max of Memory requested by any Pod in the the cluster (GB)
   */
  minMem?: number
  /**
   * Minimum number of nodes in the recommended cluster
   */
  minNodes?: number
  /**
   * NetworkPerf specifies the network performance category
   */
  networkPerf?: string[]
  /**
   * Percentage of regular (on-demand) nodes in the recommended cluster
   */
  onDemandPct?: number
  providers?: Provider[]
  /**
   * Maximum number of response per service
   */
  respPerService?: number
  /**
   * If true, recommended instance types will have a similar size
   */
  sameSize?: boolean
  /**
   * Total number of CPUs requested for the cluster
   */
  sumCpu?: number
  /**
   * Total number of GPUs requested for the cluster
   */
  sumGpu?: number
  /**
   * Total memory requested for the cluster (GB)
   */
  sumMem?: number
}

/**
 * RecommendationResponse encapsulates the recommendation response
 */
export interface RecommendationResponse {
  accuracy?: ClusterRecommendationAccuracy
  /**
   * Recommended node pools
   */
  nodePools?: NodePool[]
  /**
   * The cloud provider
   */
  provider?: string
  /**
   * Service's region
   */
  region?: string
  /**
   * Provider's service
   */
  service?: string
  /**
   * Availability zone in the recommendation - a multi-zone recommendation means that all node pools should expand to all zones
   */
  zone?: string
}

export type RecommendMultiClusterProps = Omit<
  MutateProps<RecommendationResponse, unknown, void, RecommendMultiClusterRequest, void>,
  'path' | 'verb'
>

/**
 * Provides a recommended set of node pools on a given provider in a specific region.
 *
 * Provides a recommended set of node pools on a given provider in a specific region.
 */
export const RecommendMultiCluster = (props: RecommendMultiClusterProps) => (
  <Mutate<RecommendationResponse, unknown, void, RecommendMultiClusterRequest, void>
    verb="POST"
    path={`/recommender/multicloud`}
    base={getConfig('ccm/recommendations/api/v1')}
    {...props}
  />
)

export type UseRecommendMultiClusterProps = Omit<
  UseMutateProps<RecommendationResponse, unknown, void, RecommendMultiClusterRequest, void>,
  'path' | 'verb'
>

/**
 * Provides a recommended set of node pools on a given provider in a specific region.
 *
 * Provides a recommended set of node pools on a given provider in a specific region.
 */
export const useRecommendMultiCluster = (props: UseRecommendMultiClusterProps) =>
  useMutate<RecommendationResponse, unknown, void, RecommendMultiClusterRequest, void>(
    'POST',
    `/recommender/multicloud`,
    { base: getConfig('ccm/recommendations/api/v1'), ...props }
  )

export interface RecommendClusterPathParams {
  /**
   * provider
   */
  provider: string
  /**
   * service
   */
  service: string
  /**
   * region
   */
  region: string
}

export type RecommendClusterProps = Omit<
  MutateProps<RecommendationResponse, unknown, void, RecommendClusterRequest, RecommendClusterPathParams>,
  'path' | 'verb'
> &
  RecommendClusterPathParams

/**
 * Provides a recommended set of node pools on a given provider in a specific region.
 *
 * Provides a recommended set of node pools on a given provider in a specific region.
 */
export const RecommendCluster = ({ provider, service, region, ...props }: RecommendClusterProps) => (
  <Mutate<RecommendationResponse, unknown, void, RecommendClusterRequest, RecommendClusterPathParams>
    verb="POST"
    path={`/recommender/provider/${provider}/service/${service}/region/${region}/cluster`}
    base={getConfig('ccm/recommendations/api/v1')}
    {...props}
  />
)

export type UseRecommendClusterProps = Omit<
  UseMutateProps<RecommendationResponse, unknown, void, RecommendClusterRequest, RecommendClusterPathParams>,
  'path' | 'verb'
> &
  RecommendClusterPathParams

/**
 * Provides a recommended set of node pools on a given provider in a specific region.
 *
 * Provides a recommended set of node pools on a given provider in a specific region.
 */
export const useRecommendCluster = ({ provider, service, region, ...props }: UseRecommendClusterProps) =>
  useMutate<RecommendationResponse, unknown, void, RecommendClusterRequest, RecommendClusterPathParams>(
    'POST',
    (paramsInPath: RecommendClusterPathParams) =>
      `/recommender/provider/${paramsInPath.provider}/service/${paramsInPath.service}/region/${paramsInPath.region}/cluster`,
    { base: getConfig('ccm/recommendations/api/v1'), pathParams: { provider, service, region }, ...props }
  )

export interface RecommendClusterScaleOutPathParams {
  /**
   * provider
   */
  provider: string
  /**
   * service
   */
  service: string
  /**
   * region
   */
  region: string
}

export type RecommendClusterScaleOutProps = Omit<
  MutateProps<
    RecommendationResponse,
    unknown,
    void,
    RecommendClusterScaleOutRequest,
    RecommendClusterScaleOutPathParams
  >,
  'path' | 'verb'
> &
  RecommendClusterScaleOutPathParams

/**
 * Provides a recommendation for a scale-out, based on a current cluster layout on a given provider in a specific region.
 *
 * Provides a recommendation for a scale-out, based on a current cluster layout on a given provider in a specific region.
 */
export const RecommendClusterScaleOut = ({ provider, service, region, ...props }: RecommendClusterScaleOutProps) => (
  <Mutate<RecommendationResponse, unknown, void, RecommendClusterScaleOutRequest, RecommendClusterScaleOutPathParams>
    verb="PUT"
    path={`/recommender/provider/${provider}/service/${service}/region/${region}/cluster`}
    base={getConfig('ccm/recommendations/api/v1')}
    {...props}
  />
)

export type UseRecommendClusterScaleOutProps = Omit<
  UseMutateProps<
    RecommendationResponse,
    unknown,
    void,
    RecommendClusterScaleOutRequest,
    RecommendClusterScaleOutPathParams
  >,
  'path' | 'verb'
> &
  RecommendClusterScaleOutPathParams

/**
 * Provides a recommendation for a scale-out, based on a current cluster layout on a given provider in a specific region.
 *
 * Provides a recommendation for a scale-out, based on a current cluster layout on a given provider in a specific region.
 */
export const useRecommendClusterScaleOut = ({
  provider,
  service,
  region,
  ...props
}: UseRecommendClusterScaleOutProps) =>
  useMutate<RecommendationResponse, unknown, void, RecommendClusterScaleOutRequest, RecommendClusterScaleOutPathParams>(
    'PUT',
    (paramsInPath: RecommendClusterScaleOutPathParams) =>
      `/recommender/provider/${paramsInPath.provider}/service/${paramsInPath.service}/region/${paramsInPath.region}/cluster`,
    { base: getConfig('ccm/recommendations/api/v1'), pathParams: { provider, service, region }, ...props }
  )
