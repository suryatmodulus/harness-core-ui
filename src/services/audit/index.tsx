/*
 * Copyright 2021 Harness Inc. All rights reserved.
 * Use of this source code is governed by the PolyForm Shield 1.0.0 license
 * that can be found in the licenses directory at the root of this repository, also available at
 * https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt.
 */

/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig, getUsingFetch, mutateUsingFetch, GetUsingFetchProps, MutateUsingFetchProps } from '../config'
export const SPEC_VERSION = '2.0'
export interface AccessControlCheckError {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
  correlationId?: string
  detailedMessage?: string
  failedPermissionChecks?: PermissionCheck[]
  message?: string
  metadata?: ErrorMetadataDTO
  responseMessages?: ResponseMessage[]
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface AccountNotificationSettingDTO {
  accountId: string
  sendNotificationViaDelegate?: boolean
  smtpConfig?: SmtpConfig
}

export type AddCollaboratorAuditEventData = AuditEventData & {
  source: Source
}

export interface AuditEventDTO {
  action:
    | 'CREATE'
    | 'UPDATE'
    | 'RESTORE'
    | 'DELETE'
    | 'UPSERT'
    | 'INVITE'
    | 'RESEND_INVITE'
    | 'REVOKE_INVITE'
    | 'ADD_COLLABORATOR'
    | 'REMOVE_COLLABORATOR'
    | 'REVOKE_TOKEN'
    | 'ADD_MEMBERSHIP'
    | 'REMOVE_MEMBERSHIP'
  auditEventData?: AuditEventData
  auditId?: string
  authenticationInfo: AuthenticationInfoDTO
  environment?: Environment
  httpRequestInfo?: HttpRequestInfo
  insertId: string
  internalInfo?: {
    [key: string]: string
  }
  module: 'CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE'
  requestMetadata?: RequestMetadata
  resource: ResourceDTO
  resourceScope: ResourceScopeDTO
  timestamp: number
  yamlDiffRecord?: YamlDiffRecordDTO
}

export interface AuditEventData {
  type: string
}

export interface AuditFilterProperties {
  actions?: (
    | 'CREATE'
    | 'UPDATE'
    | 'RESTORE'
    | 'DELETE'
    | 'UPSERT'
    | 'INVITE'
    | 'RESEND_INVITE'
    | 'REVOKE_INVITE'
    | 'ADD_COLLABORATOR'
    | 'REMOVE_COLLABORATOR'
    | 'REVOKE_TOKEN'
    | 'ADD_MEMBERSHIP'
    | 'REMOVE_MEMBERSHIP'
  )[]
  endTime?: number
  environments?: Environment[]
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
  modules?: ('CD' | 'CI' | 'CV' | 'CF' | 'CE' | 'CORE' | 'PMS' | 'TEMPLATESERVICE')[]
  principals?: Principal[]
  resources?: ResourceDTO[]
  scopes?: ResourceScopeDTO[]
  startTime?: number
  tags?: {
    [key: string]: string
  }
}

export interface AuditSettingsDTO {
  retentionPeriodInMonths: number
}

export interface AuthenticationInfoDTO {
  labels?: {
    [key: string]: string
  }
  principal: Principal
}

export type DynamicResourceSelector = ResourceSelector & {
  resourceType: string
}

export type EmailSettingDTO = NotificationSettingDTO & {
  body: string
  subject: string
}

export interface Environment {
  identifier: string
  type: 'PreProduction' | 'Production'
}

export interface Error {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
  correlationId?: string
  detailedMessage?: string
  message?: string
  metadata?: ErrorMetadataDTO
  responseMessages?: ResponseMessage[]
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ErrorMetadataDTO {
  type?: string
}

export interface Failure {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
  correlationId?: string
  errors?: ValidationError[]
  message?: string
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface FilterDTO {
  filterProperties: FilterProperties
  filterVisibility?: 'EveryOne' | 'OnlyCreator'
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface FilterProperties {
  filterType?:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
  tags?: {
    [key: string]: string
  }
}

export interface HttpRequestInfo {
  requestMethod?: string
}

export type InvitationSource = Source & {}

export type MSTeamSettingDTO = NotificationSettingDTO & {}

export interface NotificationDTO {
  accountIdentifier?: string
  channelType?: 'EMAIL' | 'SLACK' | 'PAGERDUTY' | 'MSTEAMS'
  id?: string
  processingResponses?: boolean[]
  retries?: number
  team?: 'OTHER' | 'CD' | 'CV' | 'CI' | 'FFM' | 'PIPELINE' | 'PL' | 'GTM' | 'UNRECOGNIZED'
}

export interface NotificationSettingDTO {
  accountId: string
  notificationId: string
  recipient: string
  type?: 'EMAIL' | 'SLACK' | 'PAGERDUTY' | 'MSTEAMS'
}

export interface Page {
  content?: { [key: string]: any }[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageAuditEventDTO {
  content?: AuditEventDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageFilterDTO {
  content?: FilterDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageNotificationDTO {
  content?: NotificationDTO[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export interface PageResourceGroupResponse {
  content?: ResourceGroupResponse[]
  empty?: boolean
  pageIndex?: number
  pageItemCount?: number
  pageSize?: number
  totalItems?: number
  totalPages?: number
}

export type PagerDutySettingDTO = NotificationSettingDTO & {}

export interface PermissionCheck {
  permission?: string
  resourceIdentifier?: string
  resourceScope?: ResourceScope
  resourceType?: string
}

export interface Principal {
  identifier: string
  type: 'USER' | 'SYSTEM' | 'API_KEY' | 'SERVICE_ACCOUNT'
}

export interface RequestMetadata {
  clientIP?: string
}

export interface ResourceDTO {
  identifier: string
  labels?: {
    [key: string]: string
  }
  type:
    | 'ORGANIZATION'
    | 'PROJECT'
    | 'USER_GROUP'
    | 'SECRET'
    | 'RESOURCE_GROUP'
    | 'USER'
    | 'ROLE'
    | 'ROLE_ASSIGNMENT'
    | 'PIPELINE'
    | 'TRIGGER'
    | 'TEMPLATE'
    | 'INPUT_SET'
    | 'DELEGATE_CONFIGURATION'
    | 'SERVICE'
    | 'ENVIRONMENT'
    | 'DELEGATE'
    | 'SERVICE_ACCOUNT'
    | 'CONNECTOR'
    | 'API_KEY'
    | 'TOKEN'
    | 'DELEGATE_TOKEN'
}

export interface ResourceGroupDTO {
  accountIdentifier: string
  allowedScopeLevels?: string[]
  color?: string
  description?: string
  fullScopeSelected?: boolean
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  resourceSelectors?: ResourceSelector[]
  scope?: Scope
  tags?: {
    [key: string]: string
  }
}

export interface ResourceGroupFilterDTO {
  accountIdentifier?: string
  identifierFilter?: string[]
  managedFilter?: 'NO_FILTER' | 'ONLY_MANAGED' | 'ONLY_CUSTOM'
  orgIdentifier?: string
  projectIdentifier?: string
  resourceSelectorFilterList?: ResourceSelectorFilter[]
  searchTerm?: string
}

export interface ResourceGroupRequest {
  resourcegroup: ResourceGroupDTO
}

export interface ResourceGroupResponse {
  createdAt?: number
  harnessManaged?: boolean
  lastModifiedAt?: number
  resourceGroup: ResourceGroupDTO
}

export interface ResourceScope {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ResourceScopeDTO {
  accountIdentifier?: string
  labels?: {
    [key: string]: string
  }
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface ResourceSelector {
  [key: string]: any
}

export interface ResourceSelectorFilter {
  resourceIdentifier?: string
  resourceType: string
}

export interface ResourceType {
  name?: string
  validatorTypes?: ('STATIC' | 'DYNAMIC')[]
}

export interface ResourceTypeDTO {
  resourceTypes?: ResourceType[]
}

export interface Response {
  correlationId?: string
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAuditSettingsDTO {
  correlationId?: string
  data?: AuditSettingsDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBoolean {
  correlationId?: string
  data?: boolean
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseFilterDTO {
  correlationId?: string
  data?: FilterDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListTemplateDTO {
  correlationId?: string
  data?: TemplateDTO[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
  exception?: Throwable
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
  )[]
  level?: 'INFO' | 'ERROR'
  message?: string
}

export interface ResponseNotificationDTO {
  correlationId?: string
  data?: NotificationDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseOptionalAccountNotificationSettingDTO {
  correlationId?: string
  data?: AccountNotificationSettingDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageAuditEventDTO {
  correlationId?: string
  data?: PageAuditEventDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageFilterDTO {
  correlationId?: string
  data?: PageFilterDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageNotificationDTO {
  correlationId?: string
  data?: PageNotificationDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponsePageResourceGroupResponse {
  correlationId?: string
  data?: PageResourceGroupResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseResourceGroupResponse {
  correlationId?: string
  data?: ResourceGroupResponse
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseResourceTypeDTO {
  correlationId?: string
  data?: ResourceTypeDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseTemplateDTO {
  correlationId?: string
  data?: TemplateDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseYamlDiffRecordDTO {
  correlationId?: string
  data?: YamlDiffRecordDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface RoleBinding {
  resourceGroupIdentifier?: string
  roleIdentifier?: string
}

export type SampleErrorMetadataDTO = ErrorMetadataDTO & {
  sampleMap?: {
    [key: string]: string
  }
}

export interface Scope {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type SlackSettingDTO = NotificationSettingDTO & {}

export interface SmtpConfig {
  encryptedPassword?: string
  fromAddress?: string
  host?: string
  password?: string[]
  port?: number
  type?: string
  useSSL?: boolean
  username?: string
}

export interface Source {
  type: string
}

export interface StackTraceElement {
  className?: string
  fileName?: string
  lineNumber?: number
  methodName?: string
  nativeMethod?: boolean
}

export type StaticResourceSelector = ResourceSelector & {
  identifiers?: string[]
  resourceType: string
}

export interface TemplateDTO {
  createdAt?: number
  file?: string[]
  identifier?: string
  lastModifiedAt?: number
  team?: 'OTHER' | 'CD' | 'CV' | 'CI' | 'FFM' | 'PIPELINE' | 'PL' | 'GTM' | 'UNRECOGNIZED'
}

export type TemplateEventData = AuditEventData & {
  comments?: string
  templateUpdateEventType?: string
}

export interface TemplateInputsErrorDTO {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export type TemplateInputsErrorMetadataDTO = ErrorMetadataDTO & {
  errorMap?: {
    [key: string]: TemplateInputsErrorDTO
  }
  errorYaml?: string
}

export interface Throwable {
  cause?: Throwable
  localizedMessage?: string
  message?: string
  stackTrace?: StackTraceElement[]
  suppressed?: Throwable[]
}

export type UserInvitationAuditEventData = AuditEventData & {
  roleBindings?: RoleBinding[]
}

export type UserInviteAuditEventData = AuditEventData & {
  roleBindings?: RoleBinding[]
}

export type UserMembershipAuditEventData = AuditEventData & {
  mechanism?: string
}

export interface ValidationError {
  error?: string
  fieldId?: string
}

export interface YamlDiffRecordDTO {
  newYaml?: string
  oldYaml?: string
}

export type FilterDTORequestBody = FilterDTO

export type ResourceGroupRequestRequestBody = ResourceGroupRequest

export type PutTemplateRequestBody = void

export interface PutAuditSettingsQueryParams {
  accountIdentifier: string
}

export type PutAuditSettingsProps = Omit<
  MutateProps<ResponseAuditSettingsDTO, Failure | Error, PutAuditSettingsQueryParams, AuditSettingsDTO, void>,
  'path' | 'verb'
>

/**
 * Update Audit Settings for an account
 */
export const PutAuditSettings = (props: PutAuditSettingsProps) => (
  <Mutate<ResponseAuditSettingsDTO, Failure | Error, PutAuditSettingsQueryParams, AuditSettingsDTO, void>
    verb="PUT"
    path={`/auditSettings`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UsePutAuditSettingsProps = Omit<
  UseMutateProps<ResponseAuditSettingsDTO, Failure | Error, PutAuditSettingsQueryParams, AuditSettingsDTO, void>,
  'path' | 'verb'
>

/**
 * Update Audit Settings for an account
 */
export const usePutAuditSettings = (props: UsePutAuditSettingsProps) =>
  useMutate<ResponseAuditSettingsDTO, Failure | Error, PutAuditSettingsQueryParams, AuditSettingsDTO, void>(
    'PUT',
    `/auditSettings`,
    { base: getConfig('audit/api'), ...props }
  )

/**
 * Update Audit Settings for an account
 */
export const putAuditSettingsPromise = (
  props: MutateUsingFetchProps<
    ResponseAuditSettingsDTO,
    Failure | Error,
    PutAuditSettingsQueryParams,
    AuditSettingsDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseAuditSettingsDTO, Failure | Error, PutAuditSettingsQueryParams, AuditSettingsDTO, void>(
    'PUT',
    getConfig('audit/api'),
    `/auditSettings`,
    props,
    signal
  )

export interface GetYamlDiffQueryParams {
  accountIdentifier: string
  auditId: string
}

export type GetYamlDiffProps = Omit<
  GetProps<ResponseYamlDiffRecordDTO, Failure | Error, GetYamlDiffQueryParams, void>,
  'path'
>

/**
 * Get Yaml Diff for an audit
 */
export const GetYamlDiff = (props: GetYamlDiffProps) => (
  <Get<ResponseYamlDiffRecordDTO, Failure | Error, GetYamlDiffQueryParams, void>
    path={`/auditYaml`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseGetYamlDiffProps = Omit<
  UseGetProps<ResponseYamlDiffRecordDTO, Failure | Error, GetYamlDiffQueryParams, void>,
  'path'
>

/**
 * Get Yaml Diff for an audit
 */
export const useGetYamlDiff = (props: UseGetYamlDiffProps) =>
  useGet<ResponseYamlDiffRecordDTO, Failure | Error, GetYamlDiffQueryParams, void>(`/auditYaml`, {
    base: getConfig('audit/api'),
    ...props
  })

/**
 * Get Yaml Diff for an audit
 */
export const getYamlDiffPromise = (
  props: GetUsingFetchProps<ResponseYamlDiffRecordDTO, Failure | Error, GetYamlDiffQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseYamlDiffRecordDTO, Failure | Error, GetYamlDiffQueryParams, void>(
    getConfig('audit/api'),
    `/auditYaml`,
    props,
    signal
  )

export interface GetAuditListQueryParams {
  accountIdentifier: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetAuditListProps = Omit<
  MutateProps<ResponsePageAuditEventDTO, Failure | Error, GetAuditListQueryParams, AuditFilterProperties, void>,
  'path' | 'verb'
>

/**
 * Get Audit list
 */
export const GetAuditList = (props: GetAuditListProps) => (
  <Mutate<ResponsePageAuditEventDTO, Failure | Error, GetAuditListQueryParams, AuditFilterProperties, void>
    verb="POST"
    path={`/audits/list`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseGetAuditListProps = Omit<
  UseMutateProps<ResponsePageAuditEventDTO, Failure | Error, GetAuditListQueryParams, AuditFilterProperties, void>,
  'path' | 'verb'
>

/**
 * Get Audit list
 */
export const useGetAuditList = (props: UseGetAuditListProps) =>
  useMutate<ResponsePageAuditEventDTO, Failure | Error, GetAuditListQueryParams, AuditFilterProperties, void>(
    'POST',
    `/audits/list`,
    { base: getConfig('audit/api'), ...props }
  )

/**
 * Get Audit list
 */
export const getAuditListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageAuditEventDTO,
    Failure | Error,
    GetAuditListQueryParams,
    AuditFilterProperties,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponsePageAuditEventDTO, Failure | Error, GetAuditListQueryParams, AuditFilterProperties, void>(
    'POST',
    getConfig('audit/api'),
    `/audits/list`,
    props,
    signal
  )

export type TestNotificationSettingProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, void, NotificationSettingDTO, void>,
  'path' | 'verb'
>

/**
 * Test notification setting
 */
export const TestNotificationSetting = (props: TestNotificationSettingProps) => (
  <Mutate<ResponseBoolean, Failure | Error, void, NotificationSettingDTO, void>
    verb="POST"
    path={`/channels/test`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseTestNotificationSettingProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, void, NotificationSettingDTO, void>,
  'path' | 'verb'
>

/**
 * Test notification setting
 */
export const useTestNotificationSetting = (props: UseTestNotificationSettingProps) =>
  useMutate<ResponseBoolean, Failure | Error, void, NotificationSettingDTO, void>('POST', `/channels/test`, {
    base: getConfig('audit/api'),
    ...props
  })

/**
 * Test notification setting
 */
export const testNotificationSettingPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, void, NotificationSettingDTO, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, void, NotificationSettingDTO, void>(
    'POST',
    getConfig('audit/api'),
    `/channels/test`,
    props,
    signal
  )

export interface GetFilterListQueryParams {
  pageIndex?: number
  pageSize?: number
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
}

export type GetFilterListProps = Omit<
  GetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const GetFilterList = (props: GetFilterListProps) => (
  <Get<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>
    path={`/filters`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseGetFilterListProps = Omit<
  UseGetProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  'path'
>

/**
 * Get Filter
 */
export const useGetFilterList = (props: UseGetFilterListProps) =>
  useGet<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(`/filters`, {
    base: getConfig('audit/api'),
    ...props
  })

/**
 * Get Filter
 */
export const getFilterListPromise = (
  props: GetUsingFetchProps<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageFilterDTO, Failure | Error, GetFilterListQueryParams, void>(
    getConfig('audit/api'),
    `/filters`,
    props,
    signal
  )

export interface PostFilterQueryParams {
  accountIdentifier: string
}

export type PostFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const PostFilter = (props: PostFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>
    verb="POST"
    path={`/filters`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UsePostFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Create a Filter
 */
export const usePostFilter = (props: UsePostFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>('POST', `/filters`, {
    base: getConfig('audit/api'),
    ...props
  })

/**
 * Create a Filter
 */
export const postFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, PostFilterQueryParams, FilterDTORequestBody, void>(
    'POST',
    getConfig('audit/api'),
    `/filters`,
    props,
    signal
  )

export interface UpdateFilterQueryParams {
  accountIdentifier: string
}

export type UpdateFilterProps = Omit<
  MutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const UpdateFilter = (props: UpdateFilterProps) => (
  <Mutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>
    verb="PUT"
    path={`/filters`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseUpdateFilterProps = Omit<
  UseMutateProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a Filter
 */
export const useUpdateFilter = (props: UseUpdateFilterProps) =>
  useMutate<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    `/filters`,
    { base: getConfig('audit/api'), ...props }
  )

/**
 * Update a Filter
 */
export const updateFilterPromise = (
  props: MutateUsingFetchProps<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseFilterDTO, Failure | Error, UpdateFilterQueryParams, FilterDTORequestBody, void>(
    'PUT',
    getConfig('audit/api'),
    `/filters`,
    props,
    signal
  )

export interface DeleteFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
}

export type DeleteFilterProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const DeleteFilter = (props: DeleteFilterProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>
    verb="DELETE"
    path={`/filters`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseDeleteFilterProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a filter
 */
export const useDeleteFilter = (props: UseDeleteFilterProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>('DELETE', `/filters`, {
    base: getConfig('audit/api'),
    ...props
  })

/**
 * Delete a filter
 */
export const deleteFilterPromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteFilterQueryParams, string, void>(
    'DELETE',
    getConfig('audit/api'),
    `/filters`,
    props,
    signal
  )

export interface GetFilterQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  type:
    | 'Connector'
    | 'DelegateProfile'
    | 'Delegate'
    | 'PipelineSetup'
    | 'PipelineExecution'
    | 'Deployment'
    | 'Audit'
    | 'Template'
}

export interface GetFilterPathParams {
  identifier: string
}

export type GetFilterProps = Omit<
  GetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const GetFilter = ({ identifier, ...props }: GetFilterProps) => (
  <Get<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>
    path={`/filters/${identifier}`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseGetFilterProps = Omit<
  UseGetProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>,
  'path'
> &
  GetFilterPathParams

/**
 * Get Filter
 */
export const useGetFilter = ({ identifier, ...props }: UseGetFilterProps) =>
  useGet<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    (paramsInPath: GetFilterPathParams) => `/filters/${paramsInPath.identifier}`,
    { base: getConfig('audit/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get Filter
 */
export const getFilterPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseFilterDTO, Failure | Error, GetFilterQueryParams, GetFilterPathParams>(
    getConfig('audit/api'),
    `/filters/${identifier}`,
    props,
    signal
  )

export interface ListNotificationsQueryParams {
  team?: 'OTHER' | 'CD' | 'CV' | 'CI' | 'FFM' | 'PIPELINE' | 'PL' | 'GTM' | 'UNRECOGNIZED'
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type ListNotificationsProps = Omit<
  GetProps<ResponsePageNotificationDTO, Failure | Error, ListNotificationsQueryParams, void>,
  'path'
>

/**
 * List notifications
 */
export const ListNotifications = (props: ListNotificationsProps) => (
  <Get<ResponsePageNotificationDTO, Failure | Error, ListNotificationsQueryParams, void>
    path={`/notifications`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseListNotificationsProps = Omit<
  UseGetProps<ResponsePageNotificationDTO, Failure | Error, ListNotificationsQueryParams, void>,
  'path'
>

/**
 * List notifications
 */
export const useListNotifications = (props: UseListNotificationsProps) =>
  useGet<ResponsePageNotificationDTO, Failure | Error, ListNotificationsQueryParams, void>(`/notifications`, {
    base: getConfig('audit/api'),
    ...props
  })

/**
 * List notifications
 */
export const listNotificationsPromise = (
  props: GetUsingFetchProps<ResponsePageNotificationDTO, Failure | Error, ListNotificationsQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponsePageNotificationDTO, Failure | Error, ListNotificationsQueryParams, void>(
    getConfig('audit/api'),
    `/notifications`,
    props,
    signal
  )

export interface GetNotificationPathParams {
  id: string
}

export type GetNotificationProps = Omit<
  GetProps<ResponseNotificationDTO, Failure | Error, void, GetNotificationPathParams>,
  'path'
> &
  GetNotificationPathParams

/**
 * Get details of a notification
 */
export const GetNotification = ({ id, ...props }: GetNotificationProps) => (
  <Get<ResponseNotificationDTO, Failure | Error, void, GetNotificationPathParams>
    path={`/notifications/${id}`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseGetNotificationProps = Omit<
  UseGetProps<ResponseNotificationDTO, Failure | Error, void, GetNotificationPathParams>,
  'path'
> &
  GetNotificationPathParams

/**
 * Get details of a notification
 */
export const useGetNotification = ({ id, ...props }: UseGetNotificationProps) =>
  useGet<ResponseNotificationDTO, Failure | Error, void, GetNotificationPathParams>(
    (paramsInPath: GetNotificationPathParams) => `/notifications/${paramsInPath.id}`,
    { base: getConfig('audit/api'), pathParams: { id }, ...props }
  )

/**
 * Get details of a notification
 */
export const getNotificationPromise = (
  {
    id,
    ...props
  }: GetUsingFetchProps<ResponseNotificationDTO, Failure | Error, void, GetNotificationPathParams> & { id: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseNotificationDTO, Failure | Error, void, GetNotificationPathParams>(
    getConfig('audit/api'),
    `/notifications/${id}`,
    props,
    signal
  )

export interface GetResourceGroupListQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
  searchTerm?: string
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetResourceGroupListProps = Omit<
  GetProps<
    ResponsePageResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetResourceGroupListQueryParams,
    void
  >,
  'path'
>

/**
 * Get list of resource groups
 */
export const GetResourceGroupList = (props: GetResourceGroupListProps) => (
  <Get<
    ResponsePageResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetResourceGroupListQueryParams,
    void
  >
    path={`/resourcegroup`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseGetResourceGroupListProps = Omit<
  UseGetProps<
    ResponsePageResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetResourceGroupListQueryParams,
    void
  >,
  'path'
>

/**
 * Get list of resource groups
 */
export const useGetResourceGroupList = (props: UseGetResourceGroupListProps) =>
  useGet<
    ResponsePageResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetResourceGroupListQueryParams,
    void
  >(`/resourcegroup`, { base: getConfig('audit/api'), ...props })

/**
 * Get list of resource groups
 */
export const getResourceGroupListPromise = (
  props: GetUsingFetchProps<
    ResponsePageResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetResourceGroupListQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponsePageResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetResourceGroupListQueryParams,
    void
  >(getConfig('audit/api'), `/resourcegroup`, props, signal)

export interface CreateResourceGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type CreateResourceGroupProps = Omit<
  MutateProps<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    CreateResourceGroupQueryParams,
    ResourceGroupRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a resource group
 */
export const CreateResourceGroup = (props: CreateResourceGroupProps) => (
  <Mutate<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    CreateResourceGroupQueryParams,
    ResourceGroupRequestRequestBody,
    void
  >
    verb="POST"
    path={`/resourcegroup`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseCreateResourceGroupProps = Omit<
  UseMutateProps<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    CreateResourceGroupQueryParams,
    ResourceGroupRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * Create a resource group
 */
export const useCreateResourceGroup = (props: UseCreateResourceGroupProps) =>
  useMutate<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    CreateResourceGroupQueryParams,
    ResourceGroupRequestRequestBody,
    void
  >('POST', `/resourcegroup`, { base: getConfig('audit/api'), ...props })

/**
 * Create a resource group
 */
export const createResourceGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    CreateResourceGroupQueryParams,
    ResourceGroupRequestRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    CreateResourceGroupQueryParams,
    ResourceGroupRequestRequestBody,
    void
  >('POST', getConfig('audit/api'), `/resourcegroup`, props, signal)

export interface GetFilterResourceGroupListQueryParams {
  pageIndex?: number
  pageSize?: number
  sortOrders?: string[]
}

export type GetFilterResourceGroupListProps = Omit<
  MutateProps<
    ResponsePageResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetFilterResourceGroupListQueryParams,
    ResourceGroupFilterDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get filtered resource group list
 */
export const GetFilterResourceGroupList = (props: GetFilterResourceGroupListProps) => (
  <Mutate<
    ResponsePageResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetFilterResourceGroupListQueryParams,
    ResourceGroupFilterDTO,
    void
  >
    verb="POST"
    path={`/resourcegroup/filter`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseGetFilterResourceGroupListProps = Omit<
  UseMutateProps<
    ResponsePageResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetFilterResourceGroupListQueryParams,
    ResourceGroupFilterDTO,
    void
  >,
  'path' | 'verb'
>

/**
 * Get filtered resource group list
 */
export const useGetFilterResourceGroupList = (props: UseGetFilterResourceGroupListProps) =>
  useMutate<
    ResponsePageResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetFilterResourceGroupListQueryParams,
    ResourceGroupFilterDTO,
    void
  >('POST', `/resourcegroup/filter`, { base: getConfig('audit/api'), ...props })

/**
 * Get filtered resource group list
 */
export const getFilterResourceGroupListPromise = (
  props: MutateUsingFetchProps<
    ResponsePageResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetFilterResourceGroupListQueryParams,
    ResourceGroupFilterDTO,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponsePageResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetFilterResourceGroupListQueryParams,
    ResourceGroupFilterDTO,
    void
  >('POST', getConfig('audit/api'), `/resourcegroup/filter`, props, signal)

export interface DeleteResourceGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type DeleteResourceGroupProps = Omit<
  MutateProps<ResponseBoolean, Failure | AccessControlCheckError | Error, DeleteResourceGroupQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a resource group
 */
export const DeleteResourceGroup = (props: DeleteResourceGroupProps) => (
  <Mutate<ResponseBoolean, Failure | AccessControlCheckError | Error, DeleteResourceGroupQueryParams, string, void>
    verb="DELETE"
    path={`/resourcegroup`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseDeleteResourceGroupProps = Omit<
  UseMutateProps<
    ResponseBoolean,
    Failure | AccessControlCheckError | Error,
    DeleteResourceGroupQueryParams,
    string,
    void
  >,
  'path' | 'verb'
>

/**
 * Delete a resource group
 */
export const useDeleteResourceGroup = (props: UseDeleteResourceGroupProps) =>
  useMutate<ResponseBoolean, Failure | AccessControlCheckError | Error, DeleteResourceGroupQueryParams, string, void>(
    'DELETE',
    `/resourcegroup`,
    { base: getConfig('audit/api'), ...props }
  )

/**
 * Delete a resource group
 */
export const deleteResourceGroupPromise = (
  props: MutateUsingFetchProps<
    ResponseBoolean,
    Failure | AccessControlCheckError | Error,
    DeleteResourceGroupQueryParams,
    string,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseBoolean,
    Failure | AccessControlCheckError | Error,
    DeleteResourceGroupQueryParams,
    string,
    void
  >('DELETE', getConfig('audit/api'), `/resourcegroup`, props, signal)

export interface GetResourceGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface GetResourceGroupPathParams {
  identifier: string
}

export type GetResourceGroupProps = Omit<
  GetProps<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetResourceGroupQueryParams,
    GetResourceGroupPathParams
  >,
  'path'
> &
  GetResourceGroupPathParams

/**
 * Get a resource group by identifier
 */
export const GetResourceGroup = ({ identifier, ...props }: GetResourceGroupProps) => (
  <Get<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetResourceGroupQueryParams,
    GetResourceGroupPathParams
  >
    path={`/resourcegroup/${identifier}`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseGetResourceGroupProps = Omit<
  UseGetProps<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetResourceGroupQueryParams,
    GetResourceGroupPathParams
  >,
  'path'
> &
  GetResourceGroupPathParams

/**
 * Get a resource group by identifier
 */
export const useGetResourceGroup = ({ identifier, ...props }: UseGetResourceGroupProps) =>
  useGet<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetResourceGroupQueryParams,
    GetResourceGroupPathParams
  >((paramsInPath: GetResourceGroupPathParams) => `/resourcegroup/${paramsInPath.identifier}`, {
    base: getConfig('audit/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Get a resource group by identifier
 */
export const getResourceGroupPromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetResourceGroupQueryParams,
    GetResourceGroupPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    GetResourceGroupQueryParams,
    GetResourceGroupPathParams
  >(getConfig('audit/api'), `/resourcegroup/${identifier}`, props, signal)

export interface UpdateResourceGroupQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface UpdateResourceGroupPathParams {
  identifier: string
}

export type UpdateResourceGroupProps = Omit<
  MutateProps<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    UpdateResourceGroupQueryParams,
    ResourceGroupRequestRequestBody,
    UpdateResourceGroupPathParams
  >,
  'path' | 'verb'
> &
  UpdateResourceGroupPathParams

/**
 * Update a resource group
 */
export const UpdateResourceGroup = ({ identifier, ...props }: UpdateResourceGroupProps) => (
  <Mutate<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    UpdateResourceGroupQueryParams,
    ResourceGroupRequestRequestBody,
    UpdateResourceGroupPathParams
  >
    verb="PUT"
    path={`/resourcegroup/${identifier}`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseUpdateResourceGroupProps = Omit<
  UseMutateProps<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    UpdateResourceGroupQueryParams,
    ResourceGroupRequestRequestBody,
    UpdateResourceGroupPathParams
  >,
  'path' | 'verb'
> &
  UpdateResourceGroupPathParams

/**
 * Update a resource group
 */
export const useUpdateResourceGroup = ({ identifier, ...props }: UseUpdateResourceGroupProps) =>
  useMutate<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    UpdateResourceGroupQueryParams,
    ResourceGroupRequestRequestBody,
    UpdateResourceGroupPathParams
  >('PUT', (paramsInPath: UpdateResourceGroupPathParams) => `/resourcegroup/${paramsInPath.identifier}`, {
    base: getConfig('audit/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a resource group
 */
export const updateResourceGroupPromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    UpdateResourceGroupQueryParams,
    ResourceGroupRequestRequestBody,
    UpdateResourceGroupPathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseResourceGroupResponse,
    Failure | AccessControlCheckError | Error,
    UpdateResourceGroupQueryParams,
    ResourceGroupRequestRequestBody,
    UpdateResourceGroupPathParams
  >('PUT', getConfig('audit/api'), `/resourcegroup/${identifier}`, props, signal)

export interface GetResourceTypesQueryParams {
  accountIdentifier: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type GetResourceTypesProps = Omit<
  GetProps<ResponseResourceTypeDTO, Failure | Error, GetResourceTypesQueryParams, void>,
  'path'
>

/**
 * Gets all resource types available at this scope
 */
export const GetResourceTypes = (props: GetResourceTypesProps) => (
  <Get<ResponseResourceTypeDTO, Failure | Error, GetResourceTypesQueryParams, void>
    path={`/resourcetype`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseGetResourceTypesProps = Omit<
  UseGetProps<ResponseResourceTypeDTO, Failure | Error, GetResourceTypesQueryParams, void>,
  'path'
>

/**
 * Gets all resource types available at this scope
 */
export const useGetResourceTypes = (props: UseGetResourceTypesProps) =>
  useGet<ResponseResourceTypeDTO, Failure | Error, GetResourceTypesQueryParams, void>(`/resourcetype`, {
    base: getConfig('audit/api'),
    ...props
  })

/**
 * Gets all resource types available at this scope
 */
export const getResourceTypesPromise = (
  props: GetUsingFetchProps<ResponseResourceTypeDTO, Failure | Error, GetResourceTypesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseResourceTypeDTO, Failure | Error, GetResourceTypesQueryParams, void>(
    getConfig('audit/api'),
    `/resourcetype`,
    props,
    signal
  )

export interface GetNotificationSettingQueryParams {
  accountIdentifier: string
}

export type GetNotificationSettingProps = Omit<
  GetProps<ResponseOptionalAccountNotificationSettingDTO, Failure | Error, GetNotificationSettingQueryParams, void>,
  'path'
>

/**
 * Get NotificationSetting
 */
export const GetNotificationSetting = (props: GetNotificationSettingProps) => (
  <Get<ResponseOptionalAccountNotificationSettingDTO, Failure | Error, GetNotificationSettingQueryParams, void>
    path={`/settings`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseGetNotificationSettingProps = Omit<
  UseGetProps<ResponseOptionalAccountNotificationSettingDTO, Failure | Error, GetNotificationSettingQueryParams, void>,
  'path'
>

/**
 * Get NotificationSetting
 */
export const useGetNotificationSetting = (props: UseGetNotificationSettingProps) =>
  useGet<ResponseOptionalAccountNotificationSettingDTO, Failure | Error, GetNotificationSettingQueryParams, void>(
    `/settings`,
    { base: getConfig('audit/api'), ...props }
  )

/**
 * Get NotificationSetting
 */
export const getNotificationSettingPromise = (
  props: GetUsingFetchProps<
    ResponseOptionalAccountNotificationSettingDTO,
    Failure | Error,
    GetNotificationSettingQueryParams,
    void
  >,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<
    ResponseOptionalAccountNotificationSettingDTO,
    Failure | Error,
    GetNotificationSettingQueryParams,
    void
  >(getConfig('audit/api'), `/settings`, props, signal)

export interface PostSendNotificationViaDelegateQueryParams {
  accountIdentifier?: string
  SendNotificationViaDelegate?: boolean
}

export type PostSendNotificationViaDelegateProps = Omit<
  MutateProps<
    ResponseOptionalAccountNotificationSettingDTO,
    Failure | Error,
    PostSendNotificationViaDelegateQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Set sendNotificationViaDelegate
 */
export const PostSendNotificationViaDelegate = (props: PostSendNotificationViaDelegateProps) => (
  <Mutate<
    ResponseOptionalAccountNotificationSettingDTO,
    Failure | Error,
    PostSendNotificationViaDelegateQueryParams,
    void,
    void
  >
    verb="PUT"
    path={`/settings`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UsePostSendNotificationViaDelegateProps = Omit<
  UseMutateProps<
    ResponseOptionalAccountNotificationSettingDTO,
    Failure | Error,
    PostSendNotificationViaDelegateQueryParams,
    void,
    void
  >,
  'path' | 'verb'
>

/**
 * Set sendNotificationViaDelegate
 */
export const usePostSendNotificationViaDelegate = (props: UsePostSendNotificationViaDelegateProps) =>
  useMutate<
    ResponseOptionalAccountNotificationSettingDTO,
    Failure | Error,
    PostSendNotificationViaDelegateQueryParams,
    void,
    void
  >('PUT', `/settings`, { base: getConfig('audit/api'), ...props })

/**
 * Set sendNotificationViaDelegate
 */
export const postSendNotificationViaDelegatePromise = (
  props: MutateUsingFetchProps<
    ResponseOptionalAccountNotificationSettingDTO,
    Failure | Error,
    PostSendNotificationViaDelegateQueryParams,
    void,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseOptionalAccountNotificationSettingDTO,
    Failure | Error,
    PostSendNotificationViaDelegateQueryParams,
    void,
    void
  >('PUT', getConfig('audit/api'), `/settings`, props, signal)

export interface GetTemplatesQueryParams {
  team: 'OTHER' | 'CD' | 'CV' | 'CI' | 'FFM' | 'PIPELINE' | 'PL' | 'GTM' | 'UNRECOGNIZED'
}

export type GetTemplatesProps = Omit<
  GetProps<ResponseListTemplateDTO, Failure | Error, GetTemplatesQueryParams, void>,
  'path'
>

/**
 * Get templates
 */
export const GetTemplates = (props: GetTemplatesProps) => (
  <Get<ResponseListTemplateDTO, Failure | Error, GetTemplatesQueryParams, void>
    path={`/templates`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseGetTemplatesProps = Omit<
  UseGetProps<ResponseListTemplateDTO, Failure | Error, GetTemplatesQueryParams, void>,
  'path'
>

/**
 * Get templates
 */
export const useGetTemplates = (props: UseGetTemplatesProps) =>
  useGet<ResponseListTemplateDTO, Failure | Error, GetTemplatesQueryParams, void>(`/templates`, {
    base: getConfig('audit/api'),
    ...props
  })

/**
 * Get templates
 */
export const getTemplatesPromise = (
  props: GetUsingFetchProps<ResponseListTemplateDTO, Failure | Error, GetTemplatesQueryParams, void>,
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseListTemplateDTO, Failure | Error, GetTemplatesQueryParams, void>(
    getConfig('audit/api'),
    `/templates`,
    props,
    signal
  )

export type PostTemplateProps = Omit<
  MutateProps<ResponseTemplateDTO, Failure | Error, void, void, void>,
  'path' | 'verb'
>

/**
 * Create a template
 */
export const PostTemplate = (props: PostTemplateProps) => (
  <Mutate<ResponseTemplateDTO, Failure | Error, void, void, void>
    verb="POST"
    path={`/templates`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UsePostTemplateProps = Omit<
  UseMutateProps<ResponseTemplateDTO, Failure | Error, void, void, void>,
  'path' | 'verb'
>

/**
 * Create a template
 */
export const usePostTemplate = (props: UsePostTemplateProps) =>
  useMutate<ResponseTemplateDTO, Failure | Error, void, void, void>('POST', `/templates`, {
    base: getConfig('audit/api'),
    ...props
  })

/**
 * Create a template
 */
export const postTemplatePromise = (
  props: MutateUsingFetchProps<ResponseTemplateDTO, Failure | Error, void, void, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseTemplateDTO, Failure | Error, void, void, void>(
    'POST',
    getConfig('audit/api'),
    `/templates`,
    props,
    signal
  )

export interface InsertOrUpdateTemplateQueryParams {
  team?: 'OTHER' | 'CD' | 'CV' | 'CI' | 'FFM' | 'PIPELINE' | 'PL' | 'GTM' | 'UNRECOGNIZED'
  identifier?: string
  harnessManaged?: boolean
}

export type InsertOrUpdateTemplateProps = Omit<
  MutateProps<ResponseTemplateDTO, Failure | Error, InsertOrUpdateTemplateQueryParams, PutTemplateRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a template if exists else create
 */
export const InsertOrUpdateTemplate = (props: InsertOrUpdateTemplateProps) => (
  <Mutate<ResponseTemplateDTO, Failure | Error, InsertOrUpdateTemplateQueryParams, PutTemplateRequestBody, void>
    verb="PUT"
    path={`/templates/insertOrUpdate`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseInsertOrUpdateTemplateProps = Omit<
  UseMutateProps<ResponseTemplateDTO, Failure | Error, InsertOrUpdateTemplateQueryParams, PutTemplateRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update a template if exists else create
 */
export const useInsertOrUpdateTemplate = (props: UseInsertOrUpdateTemplateProps) =>
  useMutate<ResponseTemplateDTO, Failure | Error, InsertOrUpdateTemplateQueryParams, PutTemplateRequestBody, void>(
    'PUT',
    `/templates/insertOrUpdate`,
    { base: getConfig('audit/api'), ...props }
  )

/**
 * Update a template if exists else create
 */
export const insertOrUpdateTemplatePromise = (
  props: MutateUsingFetchProps<
    ResponseTemplateDTO,
    Failure | Error,
    InsertOrUpdateTemplateQueryParams,
    PutTemplateRequestBody,
    void
  >,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseTemplateDTO,
    Failure | Error,
    InsertOrUpdateTemplateQueryParams,
    PutTemplateRequestBody,
    void
  >('PUT', getConfig('audit/api'), `/templates/insertOrUpdate`, props, signal)

export interface DeleteTemplateQueryParams {
  team: 'OTHER' | 'CD' | 'CV' | 'CI' | 'FFM' | 'PIPELINE' | 'PL' | 'GTM' | 'UNRECOGNIZED'
}

export type DeleteTemplateProps = Omit<
  MutateProps<ResponseBoolean, Failure | Error, DeleteTemplateQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a template
 */
export const DeleteTemplate = (props: DeleteTemplateProps) => (
  <Mutate<ResponseBoolean, Failure | Error, DeleteTemplateQueryParams, string, void>
    verb="DELETE"
    path={`/templates`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseDeleteTemplateProps = Omit<
  UseMutateProps<ResponseBoolean, Failure | Error, DeleteTemplateQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete a template
 */
export const useDeleteTemplate = (props: UseDeleteTemplateProps) =>
  useMutate<ResponseBoolean, Failure | Error, DeleteTemplateQueryParams, string, void>('DELETE', `/templates`, {
    base: getConfig('audit/api'),
    ...props
  })

/**
 * Delete a template
 */
export const deleteTemplatePromise = (
  props: MutateUsingFetchProps<ResponseBoolean, Failure | Error, DeleteTemplateQueryParams, string, void>,
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<ResponseBoolean, Failure | Error, DeleteTemplateQueryParams, string, void>(
    'DELETE',
    getConfig('audit/api'),
    `/templates`,
    props,
    signal
  )

export interface GetTemplateQueryParams {
  team?: 'OTHER' | 'CD' | 'CV' | 'CI' | 'FFM' | 'PIPELINE' | 'PL' | 'GTM' | 'UNRECOGNIZED'
}

export interface GetTemplatePathParams {
  identifier: string
}

export type GetTemplateProps = Omit<
  GetProps<ResponseTemplateDTO, Failure | Error, GetTemplateQueryParams, GetTemplatePathParams>,
  'path'
> &
  GetTemplatePathParams

/**
 * Get template by identifier
 */
export const GetTemplate = ({ identifier, ...props }: GetTemplateProps) => (
  <Get<ResponseTemplateDTO, Failure | Error, GetTemplateQueryParams, GetTemplatePathParams>
    path={`/templates/${identifier}`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UseGetTemplateProps = Omit<
  UseGetProps<ResponseTemplateDTO, Failure | Error, GetTemplateQueryParams, GetTemplatePathParams>,
  'path'
> &
  GetTemplatePathParams

/**
 * Get template by identifier
 */
export const useGetTemplate = ({ identifier, ...props }: UseGetTemplateProps) =>
  useGet<ResponseTemplateDTO, Failure | Error, GetTemplateQueryParams, GetTemplatePathParams>(
    (paramsInPath: GetTemplatePathParams) => `/templates/${paramsInPath.identifier}`,
    { base: getConfig('audit/api'), pathParams: { identifier }, ...props }
  )

/**
 * Get template by identifier
 */
export const getTemplatePromise = (
  {
    identifier,
    ...props
  }: GetUsingFetchProps<ResponseTemplateDTO, Failure | Error, GetTemplateQueryParams, GetTemplatePathParams> & {
    identifier: string
  },
  signal?: RequestInit['signal']
) =>
  getUsingFetch<ResponseTemplateDTO, Failure | Error, GetTemplateQueryParams, GetTemplatePathParams>(
    getConfig('audit/api'),
    `/templates/${identifier}`,
    props,
    signal
  )

export interface PutTemplateQueryParams {
  team: 'OTHER' | 'CD' | 'CV' | 'CI' | 'FFM' | 'PIPELINE' | 'PL' | 'GTM' | 'UNRECOGNIZED'
}

export interface PutTemplatePathParams {
  identifier: string
}

export type PutTemplateProps = Omit<
  MutateProps<
    ResponseTemplateDTO,
    Failure | Error,
    PutTemplateQueryParams,
    PutTemplateRequestBody,
    PutTemplatePathParams
  >,
  'path' | 'verb'
> &
  PutTemplatePathParams

/**
 * Update a template
 */
export const PutTemplate = ({ identifier, ...props }: PutTemplateProps) => (
  <Mutate<ResponseTemplateDTO, Failure | Error, PutTemplateQueryParams, PutTemplateRequestBody, PutTemplatePathParams>
    verb="PUT"
    path={`/templates/${identifier}`}
    base={getConfig('audit/api')}
    {...props}
  />
)

export type UsePutTemplateProps = Omit<
  UseMutateProps<
    ResponseTemplateDTO,
    Failure | Error,
    PutTemplateQueryParams,
    PutTemplateRequestBody,
    PutTemplatePathParams
  >,
  'path' | 'verb'
> &
  PutTemplatePathParams

/**
 * Update a template
 */
export const usePutTemplate = ({ identifier, ...props }: UsePutTemplateProps) =>
  useMutate<
    ResponseTemplateDTO,
    Failure | Error,
    PutTemplateQueryParams,
    PutTemplateRequestBody,
    PutTemplatePathParams
  >('PUT', (paramsInPath: PutTemplatePathParams) => `/templates/${paramsInPath.identifier}`, {
    base: getConfig('audit/api'),
    pathParams: { identifier },
    ...props
  })

/**
 * Update a template
 */
export const putTemplatePromise = (
  {
    identifier,
    ...props
  }: MutateUsingFetchProps<
    ResponseTemplateDTO,
    Failure | Error,
    PutTemplateQueryParams,
    PutTemplateRequestBody,
    PutTemplatePathParams
  > & { identifier: string },
  signal?: RequestInit['signal']
) =>
  mutateUsingFetch<
    ResponseTemplateDTO,
    Failure | Error,
    PutTemplateQueryParams,
    PutTemplateRequestBody,
    PutTemplatePathParams
  >('PUT', getConfig('audit/api'), `/templates/${identifier}`, props, signal)
