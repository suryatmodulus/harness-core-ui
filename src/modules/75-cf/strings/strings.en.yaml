continuous: '{{$.common.purpose.cf.continuous}}'
shared:
  individual: Individual
  target: '{{ $.pipelineSteps.targetLabel }}'
  targets: '{{ $.pipeline.targets.title }}'
  targetManagement: Target Management
  segment: Target group
  segments: Target Groups
  environment: environment
  lastEvaluated: Last Evaluated
  variation: Variation
  variations: Variations
  prerequisites: '{{$.preRequisitesTitle}}'
  selectEnvironment: Select Environment
  evaluations: Evaluations
  flags: '{{$.common.purpose.cf.flags}}'
  rules: Rules
  archived: archived
  selected: '{{ counter }} selected'
  pleaseSelectVariation: Please select a variation first.
  getStarted: '{{ $.getStarted }}'
  quickGuide: Quick Guide
messages:
  flagCreated: Flag created.
  flagUpdated: Flag updated.
  flagDeleted: Flag deleted.
  flagArchived: Flag archived.
  targetCreated: Target(s) created.
  targetUpdated: Target updated.
  targetDeleted: Target deleted.
  segmentCreated: Target group created.
  segmentUpdated: Target group updated.
  segmentDeleted: Target group deleted.
rbac:
  category: '{{ $.common.purpose.cf.continuous }}'
  featureflag:
    label: Feature flags
    edit: '{{ $.edit }}'
    delete: '{{ $.delete }}'
    toggle: Toggle
  targetgroup:
    label: '{{ $.cf.shared.targetManagement }}'
    edit: '{{ $.edit }}'
    delete: '{{ $.delete }}'
creationModal:
  jsonType: JSON
  variationSettingsHeading: Variation settings
  flagType: Flag Type
  defaultRules: Default rules for the flag
  flagOn: If the flag is ON, serve
  flagOff: If the flag is OFF, serve
  saveAndClose: '{{$.common.saveAndClose}}'
  nameIsRequired: Variation name is required
  valueIsRequired: Variation value is required
  idIsRequired: Variation identifier is required
  defaultVariationIsRequired: Default variation is required
  mustBeNumber: Value must be a number
  mustBeValidJSON: Value must be a valid JSON object.
  dataType: Data type
  defaultRulesTooltip: Define which variation users will see by default when the flag is ON or OFF
  testFlagOption: Test the Flag

  aboutFlag:
    aboutFlagHeading: About the flag
    permaFlag: This is a permanent flag
    nameRequired: Flag name is required
    idRequired: Flag identifier is required
    ffNamePlaceholder: Enter Feature Flag name...
    ffRegex: '{{$.common.validation.formatMustBeAlphanumeric}}'
    tagsOptional: Tags (optional)
    tagsPlaceholder: Add Tags
    permaFlagTooltip: A flag is permanent if you wish to keep it in your code for the long term. We won't remind you to these types of flags.
testTheFlag:
  testFlagHeading: Test the flag
  setupAppText: "Let's set up your application and code so that it can communicate with our platform"
  selectSdk: Select Your SDK
  sdkClient: Client
  sdkServer: Server
  selectSdkLanguage: Select the language
  installNode: Install Node.js dependency
  initClient: Initialize Client SDK
  codeSample: Place this sample code we generated of your feature flag into your code
  codeSampleNote: Please note that in the above example, it is whatever gets generated. This is just an example. This area can contain some minor notes if necessary.
  verify: '{{ $.verify }}'
  verifyText: "Once you're done, run your application so that we can verify that we are able to receive analytic events for your feature."
  testFlagTargetHeading: Testing feature flag on production environment
  confirmClose: Are you sure you want to close this modal?
editVariation:
  title: Edit Variations
  subTitle: '{{ type }} ({{ count }} variations)'
  add: + Variation
  defaultRulesDesc: "Changes will only apply to newly created environments. Existing environments won't be affected"
  envNote: Changes will only apply to newly created environments. Existing environments won’t be affected.
  applyToExistingEnvironments: Also apply to existing environments
addPrerequisites:
  addPrerequisitesHeading: Add Prerequisites
  addPrerequisitesDesc: The following must be met before your flag can be enabled
  selectFlag: Select a Flag
  selectVariation: Select a Variation
  editPrerequisitesHeading: Edit Prerequisites
editDetails:
  editDetailsHeading: Edit Flag Details
  permaFlag: '{{ $.cf.creationModal.aboutFlag.permaFlag }}'
boolean: Boolean
multivariate: Multivariate
featureNotReady: This feature is not yet ready. Please check back later.
noFlag: You currently have no flags
noResultMatch: No results match your search criteria
noTarget: There are currently no targets
noTargetForEnv: There are currently no targets for this environment
homepage:
  slogan: '{{ $.common.purpose.cf.descriptionOnly }}'
  learnMore: Learn more about Feature Flags
selectFlagRepo:
  introText: 'Git Experience has already been enabled for your project. Please confirm your Git setup before creating feature flags.'
  useExistingRepo: 'Use an Existing Repository'
  newRepo: 'Set up a New Repository'
  dialogTitle: 'Set up with Existing Repository'
  createRepoError: 'Unable to save flags to repository'
clause:
  operators:
    and: and
    in: '{{ $.common.in }}'
    startsWith: 'starts with'
    endsWith: 'ends with'
    match: 'match'
    contains: 'contains'
    equal: 'equals'
    equalSensitive: 'equals (sensitive)'
    matchSegment: 'Match Target Group'
featureFlags:
  newFlag: + Flag
  typeOfFlag: Select the Type of Flag You Want to Create
  startVariation: Start by selecting the variation type that the flag will use
  booleanBtnText: This is a simple ON/OFF toggle
  multi: '{{ $.cf.multivariate }}'
  multiBtnText: This is suitable for experiments
  percentageRollout: 'Percentage Rollout'
  turnOnHeading: Turn ON Flag
  turnOffHeading: Turn OFF Flag
  turnOnMessage: 'Please confirm that you want to turn on <strong>{{name}}</strong> on <strong>{{env}}</strong> environment.'
  turnOffMessage: 'Please confirm that you want to turn off <strong>{{name}}</strong> on <strong>{{env}}</strong> environment.'
  defaultWillBeServed: '<strong>{{defaultVariation}}</strong> will be served.'
  customRuleMessage: There are custom rules configured for this flag, please review the rules on detail page.
  defaultServedOn: '{{defaultVariation}} when flag is ON'
  defaultServedOff: '{{defaultVariation}} when flag is OFF'
  createdDate: 'Created: {{date}}'
  modifiedDate: 'Modified: {{date}}'
  prerequisitesDesc: '(what’s required before enabling flags)'
  ifFlagOnServe: 'If the flag is <strong>ON</strong>, serve '
  ifFlagOffServe: 'If the flag is <strong>OFF</strong>, serve '
  bucketBy: Bucket by <strong>{{targetField}}</strong>
  bucketOverflow: Cannot set above 100%
  serveVariationToTarget: '+ Serve variation to Target'
  serveVariationToTargetLabel: Serve Variation to Target
  customRuleOnRequest: '+ On Request, check for condition and serve variation'
  toTarget: to target
  ifClause: 'If <strong>{{attribute}}</strong> {{operator}} {{values}}'
  ifClauseServe: 'If <strong>{{attribute}}</strong> {{operator}} {{values}}, serve'
  ifClauseServePercentageRollout: 'If <strong>{{attribute}}</strong> {{operator}} {{values}}, serve <strong>percentage rollout</strong>'
  andClause: '- and <strong>{{attribute}}</strong> {{operator}} {{values}}'
  commaSeparator: ', '
  serve: serve
  servePercentageRollout: serve <strong>percentage rollout</strong>
  deleteFlag: Delete Flag
  deleteFlagMessage: Are you sure you want to delete flag <strong>{{name}}</strong>? This action cannot be undone.
  archiveFlag: Archive Flag
  archiveFlagMessage: Are you sure you want to archive flag <strong>{{name}}</strong>? This action cannot be undone.
  flagOff: Flag is OFF
  flagOn: Flag is ON
  flagWillTurnOn: Turn flag on for this environment upon save
  flagWillTurnOff: Turn flag off for this environment upon save
  targeting: Targeting
  activity: '{{ $.activity }}'
  results: Results
  makeSure: Make sure your code is deployed
  rules:
    editRules: Edit Rules
    flagOn: '{{ $.cf.creationModal.flagOn }}'
    flagOff: '{{ $.cf.creationModal.flagOff }}'
    defaultRules: Default Rules
    customRules: Custom Rules (Serve specific targets differently)
    serveVariationToTarget: '{{ $.cf.featureFlags.serveVariationToTargetLabel }}'
    add: '{{ $.add }}'
    toTarget: '{{ $.cf.featureFlags.toTarget }}'
    following: to following
    serveToFollowing: 'serve to following:'
    onRequest: On Request
    onRequestVariation: 'On Request, check for condition and serve variation'
  flagFilters:
    environment: '{{ $.environment }}'
    envDefault: Production (Default)
    any: Any
    term: Term
    switchOnOff: Switch (ON/OFF)
    status: '{{ $.status }}'
    createdDate: '{{ $.cf.targets.createdDate }}'
    modifiedDate: Modified Date
    owner: Owner
    ownerOrPinPlaceholder: Individual or Team
    creator: Creator
    tagsPlaceholder: '{{ $.valueLabel }}'
    flagsBy: Only list flags pinned by
    target: '{{ $.pipelineSteps.targetLabel }}'
    individualTargets: Individual Target or Target Group
    apply: '{{ $.filters.apply }}'
    saveFilters: Save Filters
    overwriteRadio: Overwrite Existing
    createFilter: Create New Filter
    defaultFilter: Default Filter
    defaultFilterText: This filter will be applied by default when this listing is viewed everytime
    filterVisible: Who can see this filter?
    onlyMe: Only Me
    everyone: '{{ $.filters.visibleToEveryone }}'
    save: '{{ $.save }}'
    cancel: '{{ $.cancel }}'
  metrics:
    title: 'Metrics '
    noMetrics: No Evaluations
    evaluations: '{{ count }} evaluations'
    evaluationStatistics: Evaluation Statistics
    flagEvaluations: Flag Evaluations ({{ count }})
    targetServed: Target Served  ({{ count }})
    noData: No metrics found in this time range.
    totalEvaluations: Total Evaluations
featureFlagDetail:
  variationCount: '{{ count }} variations'
targets:
  ID: '{{ $.common.ID }}'
  name: name
  targetSegment: Target Group
  lastActivity: '{{ $.lastActivity }}'
  createdDate: Created Date
  create: + Target(s)
  list: Add a target
  upload: Upload a list of targets (CSV files only)
  enterName: 'Enter target name'
  enterValue: 'Enter target identifier'
  addTargetsLabel: Add Target(s)
  addTargets: + Add Target(s)
  noTargetFound: 'No target found in this environment. Click the button above to create target(s).'
  noSegmentFound: 'No target group found in this environment. Click the button above to create a target group.'
  uploadHeadline: Please upload a CSV file according to our <a href="https://ngdocs.harness.io/article/dbk9uoaid3-add-targets#step_upload_a_list_of_targets" target="_blank" rel="noreferrer">template</a>.
  uploadHelp: 'Target CSV entry format: Name,Identifier'
  uploadYourFile: Click to upload your file
  uploadStats: <strong>Targets</strong> ({{ count }})
  noneDefined: None Defined
  deleteTarget: Delete Target
  deleteTargetMessage: Are you sure you want to delete target <strong>{{name}}</strong>? This action cannot be undone.
  deleteTargetSuccess: Target <strong>{{name}}</strong> deleted.
  pageDescription: This list displays targets manually added or impacted by flags.
targetDetail:
  title: 'Targets: Individual'
  environmentLine: '<strong>Environment</strong>: {{name}}'
  createdOnDate: Created on {{ date }}, {{ time }} PST
  targetSetting: Target Settings
  flagSetting: Flag Settings
  attribute: ATTRIBUTE
  attributes: Attributes ({{ counter }})
  learnMore: To learn how to mark specific target attributes or information as private, read <a href="https://ngdocs.harness.io/category/vjolt35atg-feature-flags" target="_blank" rel="noreferrer">documentation</a>.
  manuallyAdded: MANUALLY ADDED
  addToSegment: Add to Target Group
  autoAdded: AUTOMATICALLY ADDED THROUGH CONDITIONS
  exclusionList: EXCLUSION LIST
  excludefromSegment: Exclude from Target Group
  removeSegment: Remove from list
  noSegmentAdded: No Target Group added
  noSegmentMatched: No Target Group matched
  noSegmentExcluded: No Target Group excluded
  addTargetToSegment: Add Target to Target Group
  excludeTargetFromSegment: Exclude Target from Target Group
  exclude: Exclude
  removeFromIncludeListTitle: Remove from include list
  removeFromIncludeList: Are you sure you want to remove target <strong>{{targetName}}</strong> from include target group <strong>{{ segmentName}}</strong>? This action cannot be undone.
  removeFromExcludeListTitle: Remove from exclusion list
  removeFromExcludeList: Are you sure you want to remove target <strong>{{targetName}}</strong> from exclusion target group <strong>{{ segmentName}}</strong>? This action cannot be undone.
  noFlagConfigured: No feature flags configured for this target
  searchPlaceholder: Search Feature Flags...
  deleteTargetSuccess: Target <strong>{{name}}</strong> deleted.
  flagDisabled: This flag is disabled. The default off value will be served.
selectSegmentModal:
  searchSegmentPlaceholder: Search for Target Group by Name or Description
  flagsUsingSegment: '{{ counter }} flag'
  flagsUsingThisSegment: FLAGS USING THIS TARGET GROUP
  empty: No Target Group found
segments:
  create: + Target Group
  targetDefinition: Target Definition
  usingSegment: Flags using this target group
  usingSegmentWithCount: Flags using this target group ({{ count }})
  modalTitle: Create a Target Group
  displayIcon: Display Icon
  uploadImage: Upload an image
  delete:
    message: 'Are you sure you want to delete target group <strong>{{segmentName}}</strong>? This action cannot be undone.'
    title: Delete Target Group
  nameRequired: Target Group name is required
  idRequired: Target Group identifier is required
  noSegment: There are currently no target groups
  noSegmentForEnv: There are currently no target groups for this environment
  pageDescription: Target Groups allow you to serve flag variations to a list of targets in bulk.
environments:
  title: '{{ $.environments }}'
  empty: 'There are currently no environments'
  modifiedBy: 'Modified by'
  adminEnvironments: 'Admin: Environments'
  delete:
    message: 'Are you sure you want to delete environment <strong>{{name}}</strong>?'
    title: 'Delete Environment'
  create:
    title: 'Create an Environment'
    description: 'An environment is the representation of your production or non-production infrastructure'
    envTypeLabel: 'Environment type'
    nameLabel: 'Name of your environment'
  apiKeys:
    addKeyTitle: Create SDK Key
    message: 'Secrets are only visible right after creation and redacted once you leave the page. Please make sure to copy and store your secret somewhere safe'
    title: 'SDK Keys'
    emptyName: 'SDK Key name is required'
    addKey: '+ Add Key'
    clientType: '{{ $.cf.testTheFlag.sdkClient }}'
    serverType: '{{ $.cf.testTheFlag.sdkServer }}'
    deleteTitle: 'Confirm Key Delete'
    deleteMessage: 'Are you sure you want to delete Key: {{keyName}}? You cannot recover it afterwards'
    deleteSuccess: 'Successfully deleted Key: {{keyName}}'
    keyType: 'Key Type'
    noKeysFound: 'No SDK Keys found in this environment. Click the button below to create a Key'
    redactionWarning: Your secret will be redacted once you leave the page. Please make sure to copy and store your secret.
auditLogs:
  title: Audit Logs
  summaryHeading: 'Module: Feature Flags • Project: {{project}} • Environment: {{environment}}'
  searchPlaceholder: Search Activity
  viewEventSummary: View Event Summary
  timePST: 'TIME (PST)'
  user: USER
  action: ACTION
  moduleFF: 'Module: Feature Flags'
  flagCreated: Feature activation created
  segmentCreated: Target Group created
  flagUpdated: Feature activation updated
  unknown: Unknown activity
  empty: No activity found during this time.
  eventSummary: Event Summary
  createdMessageFF: 'created feature flag'
  createdMessageFFUpdate: 'updated feature flag'
  createdMessageSegment: 'created target group'
  updateMessageSegment: 'updated target group'
  yamlDifference: YAML Difference
  changeDetails: Change details
  events:
    updateClause: A clause was updated for a rule
    reorderRules: Rules reordered
    updateDefaultServe:
      bucketBy: Default serve updated for bucket by '{{bucketBy}}'
      variation: Default serve updated with variation '{{variation}}'
    addTargetsToVariationTargetMap: Target '{{target}}' was added for Variation '{{variation}}'
    updateDescription: Description updated to '{{description}}'
    updateName: Name updated to '{{name}}'
    updatePermanent: Permanent set to '{{permanent}}'
    addRule: A rule was added with clauses '{{clauses}}'
    updateRule: Rule updated
    removeRule: Rule removed
    addVariation: Variation '{{variation}}' added
    updateVariation: Variation '{{variation}}' updated
    deleteVariation: Variation '{{variation}}' deleted
    setDefaultOnVariation: Default on variation set to '{{variation}}'
    setDefaultOffVariation: Default off variation set to '{{variation}}'
    addSegmentToVariationTargetMap: Target Group '{{segment}}' added for Variation '{{variation}}'
    setFeatureFlagStateOn: Flag turned on
    setFeatureFlagStateOff: Flag turned off
    tagUpdated: Tags updated
    addPrerequisite: Prerequisite '{{name}}' added
    removePrerequisite: Prerequisite '{{name}}' removed
    updatePrerequisite: Prerequisite '{{name}}' updated
    removeTargetsToVariationTargetMap: Variation '{{variation}}' removed for targets '{{targets}}'
    clearVariationTargetMapping: Variation target mapping removed
    updateOffVariation: Off variation updated to '{{variation}}'
    removeClause: A clause was removed
noEnvironment:
  title: No Environment Available
  message: Create an environment and let’s start configuring the targeting rules of your flag
pipeline:
  listing: Pipeline Listing
  rollloutStrategy:
    title: Rollout Strategy
  advanced:
    title: '{{ $.advancedTitle }}'
  flagConfiguration:
    fixedInput: Fixed Input List
    runtimeInput: Runtime Input List
    environmentRequired: An environment is required
    flagRequired: A feature flag is required
    flagState: Feature flag state is required
    stepName: 'Step Name '
    selectEnvironment: '{{ $.cf.shared.selectEnvironment }}'
    flagSwitchRuntime: Your flag switch setting will be configured at runtime.
    selectFlag: Select Flag
    viewDetail: View Flag Details
    whatToConfigure: What are you configuring?
    flagSwitch: Flag Switch
    conditionalRules: Conditional Rules
    serveMapping: Serve Variation to Targets/Target Groups
    switchTo: Set Flag Switch To
    variationMappingRuntime: Variation to Target/Target Groups setting will be configured at runtime.
    addVariationMappingTitle: Add Variations Served to Targets/Target Groups
    editVariationMappingTitle: Edit Variations Served to Targets/Target Groups
    addEditMapping: + Add/edit specific variation to Targets/Target Groups
    addNewMapping: + Add variation to Target/Target Groups
    removeMapping: '- Remove specific variation from Targets/Target Groups'
    conditionRuntime: Conditional rules setting will be configured at runtime.
    addOrEdit: + Add/edit
    remove: '- Remove'
    configureMore: + Configure More
    addConditionalRules: '+ Add conditional rules'
    allRuntimeInput:
      Flag switch, default and custom targeting rules for this step are defined during runtime. You can also make the
      values static by updating your option to Fixed Input List to test things out.
    serve: Serve
    toGroups: to Target(s)/Target Group(s)
    flagChanges: Flag Changes
    flagChangesRuntime: 'At runtime, you may choose the following flag configuration changes:'
    flagChangesRuntimeSetFlagSwitch: Set flag switch
    flagChangesRuntimeSetDefaultRules: Set default rules
    flagChangesRuntimeServeVariationToTargets: Serve variation to targets
    flagChangesRuntimeServeVariationToTargetGroups: Serve variation to target groups
    flagChangesRuntimeServePercentageRollout: Serve a percentage rollout
    setFlagSwitch: Set Flag Switch
    serveVariationToIndividualTarget: Serve Variation to Individual Target
    serveVariationToTargetGroup: Serve Variation to Target Group
    servePercentageRollout: Serve Percentage Rollout
    selectOnOrOff: Select ON or OFF
    whenTheFlagIsOnServe: 'When the flag is ON, serve:'
    whenTheFlagIsOffServe: 'When the flag is OFF, serve:'
    addEditVariationToSpecificTargets: + Add/edit variation to specific targets
    addEditVariationToTargetGroups: + Add/edit variation to target groups
    enterTarget: Enter Target
    enterTargetGroup: Enter Target Group
    selectVariation: Select a variation
    variationServed: Variation Served
    toTargets: to targets
    toTargetGroup: to target group
    toTargetGroups: to target groups
    pleaseSelectAFeatureFlag: Please select an environment and feature flag.
segmentDetail:
  directlyAdded: Directly Added
  autoAdded: Automatically Added Through Conditions
  removeFomFlag: Remove from Flag
  noFlagsUseThisSegment: No Flags use this target group.
  addToFlag: + Add to Flag
  addSegmentToFlag: Add Target Group to Flag
  criteria: Criteria
  specificTargets: Specific Targets
  targetBasedOnCondition: Target based on condition
  noTargetDefined: No Target defined
  includeTheFollowing: Include the following
  excludeTheFollowing: Exclude the following
  noConditionDefined: No Condition defined
selectFlagsModal:
  empty: No feature flags found.
  searchPlaceholder: Search for Flag by name or description
gitSync:
  saveFlagToGit: Save {{ flagName }} to Git
  commitChanges: Commit Changes
  autoCommitMsg: '[AUTO-COMMIT] : {{msg}}'
  commitMsgRequired: Commit message is required
  flagName: Feature Flag Name
  autoCommitLabel: Always commit to this branch and do not prompt for commit message.
  branchStatus: Auto-commit to {{branch}} is {{status}}
  syncingPaused: Syncing with Git is currently OFF. Click to view settings
  toggleGitSyncPause: Sync with Git
  autoCommitStatusLabel: Auto-commit to selected branch
  turnOffGitAndContinue: Turn off Git and Continue
  gitErrorModalTitle: Changes can't be saved to Git
  gitServiceApiError: To continue work you can turn off Git Syncronization. All changes will be saved to Harness. When Git Sync is re-enabled we'll attempt to push the latest changes to Git
  tryAgain: Try Again
  goToGit: Go to Git to fix issue
  invalidYaml: 'We are unable to render your {{ flagsYamlFilename }} file because it is invalid. Fix the following issues on Git and try again.'
planEnforcement:
  freePlan:
    approachingLimit: 'You have used {{ clientMauUsagePercentage }}% of Monthly Active Users (MAU) included in the free plan. After {{ clientMauPlanLimitFormatted }} MAUs, flag management will be restricted.'
    upgradeRequired: 'You have used {{ clientMauPlanLimitFormatted }} / {{ clientMauPlanLimitFormatted }}  free Monthly Active Users (MAU) this month. Consider upgrading to manage more MAUs.'
  teamEnterprisePlan:
    approachingLimit: 'You have used {{ clientMauUsagePercentage }}% of your Monthly Active Users (MAU) subscription limit.'
    upgradeRequired: 'You have exceeded your Monthly Active Users (MAU) subscription limit.'
onboarding:
  listeningToEvent: We’re listening for your flag event...
  simpliestFlag: Our Simplest Flag
  simpliestFlagDescription: 'You’re creating our simplest feature flag type: Boolean Flag. This flag type is commonly used as a feature toggle, which effectively shows/hides features from your targets.'
  otherTypes: Check out other flag types
  connected: "\r\n\r\nSDK is connected\r\nFlag variation is served\r\n\r\nVerification complete."
  behindTheSenes: In case you’re wondering what’s happening behind the scenes…
  waitForConnect: Waiting for SDK...{{ message }}
  allSet: Congratulations! You’re all set!
  tryTarget: Try out our robust <a href='{{ link }}'>targeting rules for this flag</a> for more granular rollouts.
  backToStart: Back to Quick Start Guide
  title: Feature Flags Quick Start Guide
  subTitle: Everything you need to know in less than 15 minutes.
  upAndRunning: Get a flag up and running in 3 steps
  tryItOut: '{{ $.getStarted }}'
  createAFlag: '1. Create a Flag'
  setUpApp: '2. Set Up Your Application'
  testYourFlag: '3. Test Your Flag'
  letsStart: Let's start off by creating a simple flag
  inputLabel: Give your flag a memorable name
  successLabel: 'You have created <strong>{{name}}</strong> with Id: <strong>{{identifier}}</strong>'
  setupLabel: Set up your application and code to communicate with our platform.
  selectLanguage: Select your language
  selectEnvironment: Select your environment
  createEnv: + Create an environment
  envCreated: Environment Created
  sdkKeyLabel: Please create an SDK key for your environment
  sdkButtonLabel: + Create SDK Key
  keyDescriptionServer: We generated a secret as the server-side SDK key of your new environment for you to use in your code below. This secret will be redacted once you leave the page, so make sure to copy and store your secret somewhere safe.
  keyDescriptionClient: We generated a client-side SDK key of your new environment for you to use in your code below.
  secret: SDK Secret
  clientKey: Client SDK Key
  setUpYourCode: Set up your code
  listenToEvent: We’re listening for the event of your feature flag.
  toggleLabel: Toggle your flag ON/OFF and verify that the event we received has the same value.
  help:
    heading1: The Importance of Your Flag Id
    text1: Your flag Id is required to reference the flag in your code.
    heading2: Installing an SDK to Your Environment
    text2: Your flag is automatically available for use in all environments of your project. However, you need to install our SDK to environments you wish to initiate your flag in.
    getStarted: Get started with SDKs
    test:
      heading: About Flag Events
      text1: Every time a feature flag is evaluated by your application or platform, it creates an event to let our service know that the flag was used.
      text2: Flag events are necessary to provide more information about the overall health and performance of your flags.
      readmore: Read more...
  readme:
    java: |
      # Setup

      Add the following snippet to your project's `pom.xml` file (version >= 1.0.4):

      ```xml
      <dependency>
        <groupId>io.harness.cf</groupId>
        <artifactId>cf-client-sdk-java</artifactId>
        <version>1.0.4</version>
      </dependency>
      ```

      After dependency has been added, the SDK elements, primarily CfClient should be accessible in the main application.

      # Initialization

      `CfClient` is a base class that provides all features of SDK.

      ```java
      /**
      * Put the API Key here from your environment
      */
      String apiKey = '{{apiKey}}';

      CfClient cfClient = new CfClient(apiKey, Config.builder().build());

      /**
      * Define you target on which you would like to evaluate
      * the featureFlag
      */
      Target target = Target.builder()
                          .name("User1")
                          .attributes(new HashMap<String, Object>())
                          .identifier("user1@example.com")
                          .build();
      ```

      `target` represents the desired target for which we want features to be evaluated.

      Your Harness SDK is now initialized. Congratulations!

      # Public API Methods

      The Public API exposes a few methods that you can utilize:

      ```
      public boolean boolVariation(String key, Target target, boolean defaultValue)

      public String stringVariation(String key, Target target, String defaultValue)

      public double numberVariation(String key, Target target, int defaultValue)

      public JsonObject jsonVariation(String key, Target target, JsonObject defaultValue)

      public void destroy()
      ```

      # Fetch evaluation's value

      It is possible to fetch a value for a given evaluation. Evaluation is performed based on a different type. In case there is no evaluation with provided id, the default value is returned.

      Use the appropriate method to fetch the desired Evaluation of a certain type.

      # Bool variation

      ```java
      boolean result = cfClient.boolVariation("sample_boolean_flag", target, false);
      ```

      # Number variation

      ```java
      boolean result = cfClient.numberVariation("sample_number_flag", target, 0);

      ```

      # String variation

      ```java
      boolean result = cfClient.stringVariation("sample_string_flag", target, "");
      ```

    javascript: |
      # Install

      You can use npm or yarn to install <a href="https://www.npmjs.com/package/@harnessio/ff-javascript-client-sdk">ff-javascript-client-sdk</a> into your project:

      ```
      npm i @harnessio/ff-javascript-client-sdk
      ```

      If you use yarn

      ```
      yarn add @harnessio/ff-javascript-client-sdk
      ```

      # Usage

      ```
      import { initialize, Event } from '@harnessio/ff-javascript-client-sdk'
      ```

      Initialize SDK with api key and target information.

      ```
      initialize(FeatureFlagSDKKey: string, target: Target, options?: Options)
      ```

      In which Target and Options are defined as:

      ```
      interface Target {
        identifier: string
        name?: string
        anonymous?: boolean
        attributes?: object
      }

      interface Options {
        baseUrl?: string
        debug?: boolean
      }
      ```

      For example:

      ```
      const cf = initialize('{{apiKey}}', {
        identifier: YOUR-TARGET-IDENTIFIER,      // Target identifier
        name: YOUR-TARGET-NAME,                  // Optional target name
        attributes: {                            // Optional target attributes
          email: 'sample@sample.com'
        }
      })
      ```

      # Listening to events from the cf instance.

      ```
      cf.on(Event.READY, flags => {
        // Event happens when connection to server is established
        // flags contains all evaluations against SDK key
      })

      cf.on(Event.CHANGED, flagInfo => {
        // Event happens when a changed event is pushed
        // flagInfo contains information about the updated feature flag
      })

      cf.on(Event.DISCONNECTED, () => {
        // Event happens when connection is disconnected
      })

      cf.on(Event.ERROR, () => {
        // Event happens when connection some error has occurred
      })
      ```

      # Getting value for a particular feature flag

      ```
      // second argument is default value when variation does not exist
      const value = cf.variation('Dark_Theme', false)
      ```

      # Cleaning up

      Remove a listener of an event by cf.off.

      ```
      cf.off(Event.ERROR, () => {
        // Do something when an error occurs
      })
      ```

      Remove all listeners:

      ```
      cf.off()
      ```

      On closing your application, call cf.close() to close the event stream.

      ```
      cf.close();
      ```

      # Import directly from unpkg

      In case you want to import this library directly (without having to use npm or yarn):

      ```html
      <script type="module">
        import { initialize, Event } from 'https://unpkg.com/@harnessio/ff-javascript-client-sdk@1.3.7/dist/sdk.client.js'
      </script>
      ```

      If you need to support old browsers which don't support ES Module:

      ```html
      <script src="https://unpkg.com/@harnessio/ff-javascript-client-sdk@1.3.7/dist/sdk.client.js"></script>
      <script>
        var initialize = HarnessFFSDK.initialize
        var Event = HarnessFFSDK.Event
      </script>
      ```

      Remember to change the version 1.3.7 in the unpkg url accordingly.

    golang: |
      # Supported GO versions

      This version of FFM has been tested with GO 1.14

      # Install

      ```
      go get github.com/wings-software/ff-client-sdk-go
      ```

      # Usage

      First we need to import lib with harness alias `import harness "github.com/wings-software/ff-client-sdk-go/pkg/api"`

      Next we create client instance for interaction with api `client := harness.NewClient(sdkKey)`

      Target definition can be user, device, app etc.

      ```
      target := dto.NewTargetBuilder("{{apiKey}}").
      Firstname("John").
      Lastname("doe").
      Email("johndoe@acme.com").
      Country("USA").
      Custom("height", 160).
      Build()
      ```

      Evaluating Feature Flag:

      ```
      showFeature, err := client.BoolVariation(featureFlagKey, target, false)
      ```
    android: |
      # Setup

      Add following snippet to root project's `build.gradle` file:

      ```
      buildscript {
          repositories {
              mavenCentral()
          }
      ```

      In app module's `build.gradle` file add dependency for Harness's SDK (version >= 1.0.3)
      `implementation 'io.harness:ff-android-client-sdk:1.0.3'`

      After this step, the SDK elements, primarily `CfClient` should be accessible in main application.

      # Initialization

      `CfClient` is base class that provides all features of SDK. This is singleton and it is acessed with `CfClient.getInstance()`.

      ```Kotlin
      val sdkConfiguration = CfConfiguration.builder()
          .baseUrl("BASE_API_URL")
          .pollingInterval(30) //time in seconds
          .enableStream(true)
          .streamUrl("STREAM_URL")
          .build()

      val target = Target().identifier("target")

      CfClient.getInstance().initialize(context, '{{apiKey}}', sdkConfiguration, target)
      ```

      `target` represents a desired target for which we want features to be evaluated.

      **Your Harness SDK is now initialized. Congratulations!!!**

      # Public API Methods

      The Public API exposes a few methods that you can utilize:

      ```
      public void initialize(Context context, String clientId, CfConfiguration configuration, CloudCache cloudCache, AuthCallback authCallback)

      public boolean boolEvaluation(String evaluationId, boolean defaultValue)

      public String stringEvaluation(String evaluationId, String defaultValue)

      public double numberEvaluation(String evaluationId, double defaultValue)

      public JSONObject jsonVariation(String evaluationId, JSONObject defaultValue)

      public void registerEventsListener(EventsListener listener)

      public void unregisterEventsListener(EventsListener observer)

      public void destroy()
      ```

      # Fetch evaluation's value

      It is possible to fetch a value for a given evaluation. Evaluation is performed based on different type. In case there is no evaluation with provided id, the default value is returned.

      Use appropriate method to fetch the desired Evaluation of a certain type.

      # boolEvaluation(String evaluationId, boolean defaultValue)

      ```Kotlin
      //get boolean evaluation
      val evaluation: Boolean = CfClient.getInstance().boolVariation("demo_evaluation", false)
      ```

      # numberEvaluation(String evaluationId, double defaultValue)

      ```Kotlin
      //get number evaluation
      val numberEvaluation: Double = CfClient.getInstance().numberVariation("demo_number_evaluation", 0)
      ```

      # stringEvaluation(String evaluationId, String defaultValue)

      ```Kotlin
      //get String evaluation
      val stringEvaluation: String = CfClient.getInstance().stringVariation("demo_string_evaluation", "demo_value")
      ```

      # Register for events

      This method provides a way to register a listener for different events that might be triggered by SDK, indicating specific change in SDK itself.

      ```Kotlin
      private final EventsListener eventsListener = statusEvent -> {
          if (statusEvent.getEventType() == EVALUATION_CHANGE) {
              Evaluation evaluation = statusEvent.extractPayload();
          }
      }

      CfClient.getInstance().registerEventsListener(eventsListener)
      ```

      Triggered event will have one of the following types:

      ```Java
      public enum EVENT_TYPE {
              SSE_START,
              SSE_END,
              EVALUATION_CHANGE,
              EVALUATION_RELOAD
          }
      ```

      Following table provides summary on possible event types and corresponding responses.

      ```
      | EVENT_TYPE        | Response          |
      | -------------     |:-------:          |
      | SSE_START         | -                 |
      | SSE_END           | -                 |
      | EVALUATION_CHANGE | `Evaluation`      |
      | EVALUATION_RELOAD | `List<Evaluation>`|
      ```

      To avoid unexpected behaviour, when listener is not needed anymore, a caller should call
      `CfClient.getInstance().unregisterEventsListener(eventsListener)`. This way the sdk will remove desired listener from internal list.

      # Shutting down the SDK

      To avoid potential memory leak, when SDK is no longer needed (when the app is closed, for example), a caller should call this method

      ```Kotlin
      CfClient.getInstance().destroy()
      ```

      # Using SDK in unit tests

      To be able to use the SDK in unit tests it is required to set SDKs logging to the console output:

      ```Kotlin
      CfLog.testModeOn()
      ```

      `testModeOn` will turn on the use of the system output logging strategy.
      On the other hand, to turn on the usage of the Android <a href="https://developer.android.com/reference/android/util/Log">log class</a> use:

      ```Kotlin
      CfLog.runtimeModeOn()
      ```

      Standard Android logging is the default logging strategy so turning on runtime mode is not required.
    ios: |
      # Installing the `ff-ios-client-sdk`

      Installing ff-ios-client-sdk is possible with `Swift Package Manager (SPM), CocoaPods and Carthage`

      # Swift Package Manager (SPM)

      The [Swift Package Manager](https://swift.org/package-manager/) is a dependency manager integrated into the `swift` compiler and `Xcode`.

      To integrate `ff-ios-client-sdk` into an Xcode project, go to the project editor, and select `Swift Packages`. From here hit the `+` button and follow the prompts using  `https://github.com/drone/ff-ios-client-sdk.git` as the URL.

      To include `ff-ios-client-sdk` in a Swift package, simply add it to the dependencies section of your `Package.swift` file. And add the product `ff-ios-client-sdk` as a dependency for your targets.

      ```Swift
      dependencies: [
          .package(url: "https://github.com/drone/ff-ios-client-sdk.git", .upToNextMinor(from: "1.0.2"))
      ]
      ```

      # CocoaPods

      [CocoaPods](https://cocoapods.org//) is a dependency manager for Swift and Objective-C Cocoa projects. It has over 81 thousand libraries and is used in over 3 million apps. CocoaPods can help you scale your projects elegantly.

      CocoaPods is built with Ruby and it will be installable with the default Ruby available on macOS. You can use a Ruby Version manager, however we recommend that you use the standard Ruby available on macOS unless you know what you're doing.

      Using the default Ruby install will require you to use sudo when installing gems. (This is only an issue for the duration of the gem installation, though.)

      ```Swift
      $ sudo gem install cocoapods
      ```

      Once Cocoapods is installed, from your root project folder, create a `Podfile`, which will be located in your project's root folder, by entering the next command in your terminal:

      ```Swift
      $ pod init
      ```

      To import `ff-ios-client-sdk` to your `.xcproject`, simply add `ff-ios-client-sdk` to your newly created Podfile and save the Podfile changes.

      ```Swift
      platform :ios, '10.0'
      use_frameworks!

      target 'MyApp' do
        pod 'ff-ios-client-sdk'
      end
      ```

      Only thing left to do is to install your packages by running the next command.

      ```Swift
      $ pod install
      ```

      NOTE: A new `.xcworkspace` will be created and you should use that, instead of your `.xcodeproj` from now on in order to utilize the imported Pods.

      # Carthage

      Carthage is intended to be the simplest way to add frameworks to your Cocoa application. Carthage builds your dependencies and provides you with binary frameworks, but you retain full control over your project structure and setup. Carthage does not automatically modify your project files or your build settings.

      In order to integrate `ff-ios-client-sdk` into your app, there are a few steps to follow.

      Navigate to the root folder of your project and create a `Cartfile`. This is the file where you would input all of your dependencies that you plan to use with Carthage. You can create it by entering

      ```Swift
      $ touch Cartfile
      ```

      in Terminal at your project's root folder. Once you open the `Cartfile`, you can copy/paste below line and save the changes.

      ```Swift
      github "drone/ff-ios-client-sdk"
      ```

      Now, you need to run

      ```Swift
      $ carthage update --no-build
      ```

      This command will fetch the source for `ff-ios-client-sdk` from the repository specified in the `Cartfile`.

      You will now have a new folder, named `Carthage` at the same location your `Cartfile` and your `.xcodeproj` are.

      Within the `Carthage` folder, you will see another `Checkout` folder where the source code is located.

      Next, we need to create a project for `ff-ios-client-sdk` dependency. We can do this easily by entering the following in the termial.

      ```Swift
      //From your project's root folder
      $ cd Carthage/Checkouts/ff-ios-client-sdk
      ```

      followed by

      ```Swift
      $ swift package generate-xcodeproj
      ```
      or you can enter it all on the same line.

      ```Swift
      // From your project's root folder
      $ cd Carthage/Checkouts/ff-ios-client-sdk && swift package generate-xcodeproj
      ```

      Go back into your project's root folder and enter the next command:

      ```Swift
      $ carthage build --use-xcframeworks --platform iOS
      ```

      This command will build the project and place it in the `Build` folder next to `Checkouts`. On your application targets’ `General` settings tab, in the `Frameworks, Libraries, and Embedded Content` section, drag and drop the `.xcframework` file from the `Carthage/Build` folder. In the `"Embed"` section, select `"Embed & Sign"`.

      Only thing left to do is:

      ```Swift
      import ff_ios_client_sdk
      ```

      wherever you need to use `ff-ios-client-sdk`

      When a new version of `ff-ios-client-sdk` is available and you wish to update this dependency, run

      ```Swift
      $ carthage update --use-xcframeworks --platform iOS
      ```
      And your embedded library will be updated.

      # Using the `ff-ios-client-sdk`

      In order to use `ff-ios-client-sdk` in your application, there are a few steps that you would need to take.

      # Initialization

      1. Setup your configuration by calling `CfConfiguration`'s static method `builder()` and pass-in your prefered configuration settings through possible chaining methods. The chaining needs to be ended with `build()` method. (See the `build()`'s description for possible chaining methods and their default values.)

      2. Setup your target by calling `CfTarget`'s static method `builder()` and pass-in your prefered target settings through possible chaining methods. The chaining needs to be ended with `build()` method. (See the `build()`'s description for possible chaining methods and their default values). Target's `identifier` is mandatory and represents the `Account` from which you wish to receive evaluations.

      3. Call `CfClient.sharedInstance.initialize(apiKey:configuration:target:cache:onCompletion:)` and pass in your Harness CF `apiKey`, previously created configuration object, target and an optional cache object adopting `StorageRepositoryProtocol`.

      If `cache` object is omitted, internal built-in cache will be used. You can also omitt `onCompletion` parameter if you don't need initialization/authorization information.

      **Your `ff-ios-client-sdk` is now initialized. Congratulations!!!**

      Upon successful initialization and authorization, the completion block of `CfClient.sharedInstance.initialize(apiKey:configuration:target:cache:onCompletion:)` will deliver `Swift.Result<Void, CFError>` object. You can then switch through it's `.success(Void)` and `.failure(CFError)` cases and decide on further steps depending on a result.

      # initialize(apiKey:configuration:cache:onCompletion:)

      ```Swift
      let configuration = CfConfiguration.builder().setStreamEnabled(true).build()
      let target = CfTarget.builder().setIdentifier("YOUR_ACCOUNT_IDENTIFIER").build()
      CfClient.sharedInstance.initialize(apiKey: '{{apiKey}}', configuration: configuration, target: target) { (result) in
          switch result {
              case .failure(let error):
                  //Do something to gracefully handle initialization/authorization failure
              case .success:
                  //Continue to the next step after successful initialization/authorization
          }
      }
      ```

      ## Implementation

      The Public API exposes few methods that you can utilize. Please note that all of the below methods are called on `CfClient.sharedInstance`

      ```
      public func initialize(apiKey:configuration:target:cache:onCompletion:)` -> Called first as described above in the **_initialization_** section. `(Mandatory)

      public func registerEventsListener(events:onCompletion:)` -> Called in the ViewController where you would like to receive the events. `(Mandatory)

      public func destroy()

      // Fetching from cache methods

      public func stringVariation(evaluationId:defaultValue:completion:)

      public func boolVariation(evaluationId:defaultValue:completion:)

      public func numberVariation(evaluationId:defaultValue:completion:)

      public func jsonVariation(evaluationId:defaultValue:completion:)
      ```

      # registerEventsListener(events:onCompletion:)

      `events` is an array of events that you would like to subscribe to. It defaults to `*`, which means ALL events.
      In order to be notified of the SSE events sent from the server, you need to call `CfClient.sharedInstance.registerEventsListener()` method

      **NOTE**: Registering to events is usually done in `viewDidLoad()` method when events are required in only one ViewController _OR_ `viewDidAppear()` if there are more than one registration calls throughout the app, so the events could be re-registered for the currently visible ViewController.

      The completion block of this method will deliver `Swift.Result<EventType, CFError>` object. You can use `switch` statement within it's `.success(EventType)` case to distinguish which event has been received and act accordingly as in the example below or handle the error gracefully from it's `.failure(CFError)` case.

      ```Swift
      CfClient.sharedInstance.registerEventsListener() { (result) in
          switch result {
              case .failure(let error):
                  //Gracefully handle error
              case .success(let eventType):
                  switch eventType {
                      case .onPolling(let evaluations):
                          //Received all evaluation flags -> [Evaluation]
                      case .onEventListener(let evaluation):
                          //Received an evaluation flag -> Evaluation
                      case .onComplete:
                          //Received a completion event, meaning that the
                          //SSE has been disconnected
                      case .onOpen(_):
                          //SSE connection has been established and is active
                      case .onMessage(let messageObj):
                          //An empty Message object has been received
                  }
              }
          }
      }
      ```

      ## Fetching from cache methods

      The following methods can be used to fetch an Evaluation from cache, by it's known key. Completion handler delivers `Evaluation` result. If `defaultValue` is specified, it will be returned if key does not exist. If `defaultValue` is omitted, `nil` will be delivered in the completion block. Fetching is done for specified target identifier during initialize() call.

      Use appropriate method to fetch the desired Evaluation of a certain type.

      # stringVariation(forKey:defaultValue:completion:)

      ```Swift
      CfClient.sharedInstance.stringVariation("your_evaluation_id", defaultValue: String?) { (evaluation) in
          //Make use of the fetched `String` Evaluation
      }
      ```

      # boolVariation(forKey:defaultValue:completion:)

      ```Swift
      CfClient.sharedInstance.boolVariation("your_evaluation_id", defaultValue: Bool?) { (evaluation) in
          //Make use of the fetched `Bool` Evaluation
      }
      ```

      # numberVariation(forKey:defaultValue:completion:)

      ```Swift
      CfClient.sharedInstance.numberVariation("your_evaluation_id", defaultValue: Int?) { (evaluation) in
          //Make use of the fetched `Int` Evaluation
      }
      ```

      # jsonVariation(forKey:defaultValue:completion:)

      ```Swift
      CfClient.sharedInstance.jsonVariation("your_evaluation_id", defaultValue: [String:ValueType]?) { (evaluation) in
          //Make use of the fetched `[String:ValueType]` Evaluation
      }
      ```

      `ValueType` can be one of the following:

      ValueType.bool(Bool)`
      ValueType.string(String)
      ValueType.int(Int)
      ValueType.object([String:ValueType])

      ## Shutting down the SDK

      To avoid potential memory leak, when SDK is no longer needed (when the app is closed, for example), a caller should call this method.
      Also, you need to call this method when changing accounts through `CfTarget` object, in order to re-initialize and fetch Evaluations for the right account.

      ```Swift
      CfClient.sharedInstance.destroy()
      ```
    dotnet: |
      # Install

      You can reference the SDK in your project using NuGet package. Package is published to default package repository (nuget.org).
      Package name is 
      ```
      ff-netF48-server-sdk --version 1.0.8
      ```

      More information can be found <a href="https://docs.microsoft.com/en-us/nuget/quickstart/install-and-use-a-package-using-the-dotnet-cli">here</>

      After the dependency has been added, the SDK elements, primarily `CfClient`, should be accessible in the main application.

      # Use

      `CfClient` is a base class that provides all features of the SDK.

      ```
      using io.harness.cfsdk.client.dto;
      using io.harness.cfsdk.client.api;

      /**
       * Put the API Key here from your environment
       */
      String API_KEY = '{{apiKey}}';

      config = Config.Builder()
                      .SetPollingInterval(60000)
                      .SetAnalyticsEnabled()
                      .SetStreamEnabled(true)
                      .Build();

      CfClient cfClient = await CfClient.getInstance(API_KEY, config);

      /**
       * Define the target for which you would like to evaluate
       * the featureFlag
       */

      Target target = io.harness.cfsdk.client.dto.Target.builder()
                      .Name("User1") //can change with your target name
                      .Identifier("user1@example.com") //can change with your target identifier
                      .build();
      ```

      `target` represents the desired target for which we want features to be evaluated.

      # Your Harness SDK is now initialized. Congratulations!

      # Public API Methods 

      The Public API exposes a few methods that you can utilize:

      ```
      public async Task<bool> boolVariation(string key, dto.Target target, bool defaultValue)

      public async Task<string> stringVariation(string key, dto.Target target, string defaultValue)

      public async Task<double> numberVariation(string key, dto.Target target, int defaultValue)

      public async Task<JObject> jsonVariation(string key, dto.Target target, JObject defaultValue)
      ```

      # Fetch evaluation's value

      It is possible to fetch a value for a given evaluation. Evaluation is performed based on a different type. In case there
      is no evaluation with the provided id, the default value is returned.

      Use the appropriate method to fetch the desired Evaluation of a certain type.

      # Bool variation

      ```
      boolean result = await cfClient.boolVariation("sample_boolean_flag", target, false);
      ```

      # Number variation

      ```
      double result = await cfClient.numberVariation("sample_number_flag", target, 0);
      ```

      # String variation

      ```
      string result = await cfClient.stringVariation("sample_string_flag", target, "");
      ```

      # Using feature flags metrics

      The Metrics API endpoint can be changed like this:

      ```
      Config.builder()
                    .EventUrl("METRICS_API_EVENTS_URL")
                    .build();
      ```

      Otherwise, the default metrics endpoint URL will be used.
    nodejs: |
      # Setup

      You can use npm or yarn to install <a href="https://www.npmjs.com/package/@harnessio/ff-nodejs-server-sdk">ff-nodejs-server-sdk</a> into your project:

      ```
      npm install @harnessio/ff-nodejs-server-sdk
      ```

      # Import the package (CommonJS)

      ```
      const { Client } = require('@harnessio/ff-nodejs-server-sdk');
      ```

      # Initialize

      This is the most simple way to initialize SDK using only a server type key

      ```
      const client = new Client('your server type SDK key');
      ```

      Advanced initialization can be done using options

      ```
      const client = new Client('your server type SDK key', {
      enableStream: false,
      });
      ```

      # Define a target

      ```
      const target = {
      identifier: 'harness',
      name: 'Harness',
      attributes: {}
      };
      ```

      # Evaluate the flag with default value set to false

      ```
      const value = await client.boolVariation('test', target, false);
      ```

      # Shutting down SDK

      ```
      client.close();
      ```

      # Available public methods

      ```
      function boolVariation(
      identifier: string,
      target: Target,
      defaultValue: boolean = true,
      ): Promise<boolean>;

      function stringVariation(
      identifier: string,
      target: Target,
      defaultValue: boolean = '',
      ): Promise<string>;

      function numberVariation(
        identifier: string,
        target: Target,
        defaultValue: boolean = 1.0,
      ): Promise<number>;

      function jsonVariation(
        identifier: string,
        target: Target,
        defaultValue: boolean = {},
      ): Promise<Record<string, unknown>>;

      function close(): void;
      ```

      # Available options

      ```
      baseUrl: string;             // baseUrl is where the flag configurations are located
      eventsUrl: string;           // eventsUrl is where we send summarized target events
      pollInterval: number;        // pollInterval (default 60s)
      eventsSyncInterval: number;  // Metrics push event (default 60s)
      enableStream: boolean;       // enable server sent events
      enableAnalytics: boolean;    // enable analytics
      cache: KeyValueStore;        // set custom cache (default lru cache)
      store: AsyncKeyValueStore;   // set custom persistent store (default file store)
      logger: Logger;              // set logger (default console)
      ```

      # Singleton example

      ```
      import CfClient from '@harnessio/ff-nodejs-server-sdk';

      CfClient.init('your server type SDK key');

      const FLAG_KEY = 'test_bool';
      const target = {
        identifier: 'harness',
        name: 'Harness',
        attributes: {}
      };
      const defaultValue = false;

      setInterval(async() => {
          const value = await CfClient.boolVariation(FLAG_KEY, target, defaultValue);
          console.log("Evaluation for flag test and target none: ", value);
      }, 10000);
      ```

      # Wait for initialization example

      ```
      const { Client } = require('@harnessio/ff-nodejs-server-sdk');

      console.log('Starting application');
      const client = new Client('1c100d25-4c3f-487b-b198-3b3d01df5794');
      client
        .waitForInitialization()
        .then(() => {
          setInterval(async () => {
            const target = {
              identifier: 'harness',
            };
            const value = await client.boolVariation('test', target, false);
            console.log('Evaluation for flag test and target: ', value, target);
          }, 10000);

          console.log('Application started');
        })
        .catch((error) => {
          console.log('Error', error);
        });
      ```

      # Listening on events

      You can listen on these events:

      Event.READY - SDK successfully initialized
      Event.FAILED - SDK throws an error
      Event.CHANGED - any new version of flag or segment triggers this event, if segment is changed then it will find all flags with segment match operator

      Methods:

      ```
      on(Event.READY, () => {
        console.log('READY');
      });

      on(Event.FAILED, () => {
        console.log('FAILED');
      });

      on(Event.CHANGED, (identifier) => {
        console.log('Changed', identifier);
      });
      ```

      and if you want to remove the functionReference listener for Event.READY:

      ```
      off(Event.READY, functionReference);
      ```

      or if you want to remove all listeners on Event.READY:

      ```
      off(Event.READY);
      ```

      or if you call off() without params it will close the client.
      All events are applicable to off() function.
    python: |
      # Setup

      Using terminal install the SDK with:

      ```
      pip install harness-featureflags
      ```

      After the package has been added, the SDK elements, primarily CfClient should be accessible in the main application.


      # Initialization

      CfClient is a base class that provides all features of the SDK.

      Put the API Key here from your environment

      ```
      api_key = '{{apiKey}}';

      cf = CfClient(api_key);
      ```

      Define the target on which you would like to evaluate the feature flag

      ```
      target = Target(identifier="user1", name="user1")
      ```

      'target' represents the desired target for which we want features to be evaluated.


      # Your Harness SDK is now initialized. Congratulations!


      # Public API Methods

      The Public API exposes a few methods that you can utilize:

      ```
      bool_variation(key: str, target: Target, default: bool) -> bool
      ```

      ```
      string_variation(key: str, target: Target, default: str) -> str
      ```

      ```
      number_variation(key: str, target: Target, default: float) -> float
      ```

      ```
      json_variation(String key, Target target, default: dict) -> dict
      ```

      ```
      close()
      ```

      # Fetch evaluation's value
      It is possible to fetch a value for a given evaluation. Evaluation is performed based on a different type. In case there is no evaluation with provided id, the default value is returned.

      Use the appropriate method to fetch the desired Evaluation of a certain type.

      # Bool variation

      ```
      result = cf.bool_variation("sample_boolean_flag", target, False);
      ```

      # Number variation
      ```
      result = cf.number_variation("sample_number_flag", target, 0);
      ```

      # String variation
      ```
      result = cf.string_variation("sample_string_flag", target, "");
      ```

      # Using feature flags metrics

      Metrics API endpoint can be changed like this:
      ```
      cf = CfClient(api_key, with_events_url('METRICS_API_EVENTS_URL'));
      ```

      Otherwise, the default metrics endpoint URL will be used.
      ```
      https://events.ff.harness.io/api/1.0
      ```

      # Shutting down the SDK

      To avoid potential memory leak, when SDK is no longer needed (when the app is closed, for example), a caller should call this method:

      ```
      cf.close();
      ```
learnMore: '{{ $.cf.homepage.learnMore }}'
cfTrialHomePage:
  startTrial:
    description: Take your feature release processes to the next level using our Harness Feature Flags.
    startBtn:
      description: Start 14 day FF Enterprise trial
percentageRollout:
  toTargetGroup: 'To Target Group:'
  invalidTotalError: Variation weights must add up to 100%
  bucketBy: Bucket targets by
