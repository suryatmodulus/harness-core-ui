/*
 * Copyright 2022 Harness Inc. All rights reserved.
 * Use of this source code is governed by the PolyForm Shield 1.0.0 license
 * that can be found in the licenses directory at the root of this repository, also available at
 * https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt.
 */

/* Generated by restful-react */

import React from 'react'
import { Get, GetProps, useGet, UseGetProps, Mutate, MutateProps, useMutate, UseMutateProps } from 'restful-react'

import { getConfig } from '../config'
export const SPEC_VERSION = '1.0'
export interface AlertThreshold {
  alertsSent?: number
  basedOn?: 'ACTUAL_COST' | 'FORECASTED_COST'
  crossedAt?: number
  emailAddresses?: string[]
  percentage?: number
  slackWebhooks?: string[]
  userGroupIds?: string[]
}

export type AppDynamicsConnectorDTO = ConnectorConfigDTO & {
  accountname: string
  authType?: 'UsernamePassword' | 'ApiClientToken'
  clientId?: string
  clientSecretRef?: string
  controllerUrl: string
  delegateSelectors?: string[]
  passwordRef?: string
  username?: string
}

export type ApplicationBudgetScope = BudgetScope & {
  applicationIds?: string[]
  environmentType?: 'PROD' | 'NON_PROD' | 'ALL'
}

export interface ArtifactoryAuthCredentials {
  [key: string]: any
}

export interface ArtifactoryAuthentication {
  spec?: ArtifactoryAuthCredentials
  type: 'UsernamePassword' | 'Anonymous'
}

export type ArtifactoryConnector = ConnectorConfigDTO & {
  artifactoryServerUrl: string
  auth?: ArtifactoryAuthentication
  delegateSelectors?: string[]
}

export type ArtifactoryUsernamePasswordAuth = ArtifactoryAuthCredentials & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface AwsAccountConnectionDetail {
  cloudFormationTemplateLink?: string
  externalId?: string
  harnessAccountId?: string
  stackLaunchTemplateLink?: string
}

export interface AwsCodeCommitAuthenticationDTO {
  spec: AwsCodeCommitCredentialsDTO
  type: 'HTTPS'
}

export type AwsCodeCommitConnectorDTO = ConnectorConfigDTO & {
  authentication: AwsCodeCommitAuthenticationDTO
  delegateSelectors?: string[]
  type: 'Repo' | 'Region'
  url: string
}

export interface AwsCodeCommitCredentialsDTO {
  [key: string]: any
}

export type AwsCodeCommitHttpsCredentialsDTO = AwsCodeCommitCredentialsDTO & {
  spec: AwsCodeCommitHttpsCredentialsSpecDTO
  type: 'AWSCredentials'
}

export interface AwsCodeCommitHttpsCredentialsSpecDTO {
  [key: string]: any
}

export type AwsCodeCommitSecretKeyAccessKeyDTO = AwsCodeCommitHttpsCredentialsSpecDTO & {
  accessKey?: string
  accessKeyRef?: string
  secretKeyRef: string
}

export type AwsConnector = ConnectorConfigDTO & {
  credential: AwsCredential
  delegateSelectors?: string[]
}

export interface AwsCredential {
  crossAccountAccess?: CrossAccountAccess
  spec?: AwsCredentialSpec
  type: 'InheritFromDelegate' | 'ManualConfig' | 'Irsa'
}

export interface AwsCredentialSpec {
  [key: string]: any
}

export interface AwsCurAttributes {
  region?: string
  reportName: string
  s3BucketName: string
  s3Prefix?: string
}

export interface AwsKmsConnectorCredential {
  spec?: AwsKmsCredentialSpec
  type: 'AssumeIAMRole' | 'AssumeSTSRole' | 'ManualConfig'
}

export type AwsKmsConnectorDTO = ConnectorConfigDTO & {
  credential?: AwsKmsConnectorCredential
  default?: boolean
  delegateSelectors?: string[]
  kmsArn: string
  region?: string
}

export interface AwsKmsCredentialSpec {
  [key: string]: any
}

export type AwsKmsCredentialSpecAssumeIAM = AwsKmsCredentialSpec & {
  delegateSelectors: string[]
}

export type AwsKmsCredentialSpecAssumeSTS = AwsKmsCredentialSpec & {
  assumeStsRoleDuration?: number
  delegateSelectors: string[]
  externalName?: string
  roleArn: string
}

export type AwsKmsCredentialSpecManualConfig = AwsKmsCredentialSpec & {
  accessKey: string
  secretKey: string
}

export type AwsManualConfigSpec = AwsCredentialSpec & {
  accessKey?: string
  accessKeyRef?: string
  secretKeyRef: string
}

export type AwsSMCredentialSpecAssumeIAM = AwsSecretManagerCredentialSpec & { [key: string]: any }

export type AwsSMCredentialSpecAssumeSTS = AwsSecretManagerCredentialSpec & {
  assumeStsRoleDuration?: number
  externalId?: string
  roleArn: string
}

export type AwsSMCredentialSpecManualConfig = AwsSecretManagerCredentialSpec & {
  accessKey: string
  secretKey: string
}

export interface AwsSecretManagerCredential {
  spec?: AwsSecretManagerCredentialSpec
  type: 'AssumeIAMRole' | 'AssumeSTSRole' | 'ManualConfig'
}

export interface AwsSecretManagerCredentialSpec {
  [key: string]: any
}

export type AwsSecretManagerDTO = ConnectorConfigDTO & {
  credential: AwsSecretManagerCredential
  default?: boolean
  delegateSelectors?: string[]
  region: string
  secretNamePrefix?: string
}

export type AzureKeyVaultConnectorDTO = ConnectorConfigDTO & {
  azureEnvironmentType?: 'AZURE' | 'AZURE_US_GOVERNMENT'
  clientId: string
  default?: boolean
  delegateSelectors?: string[]
  secretKey: string
  subscription: string
  tenantId: string
  vaultName: string
}

export interface BillingExportSpec {
  containerName: string
  directoryName: string
  reportName: string
  storageAccountName: string
  subscriptionId: string
}

export interface BitbucketApiAccess {
  spec: BitbucketApiAccessSpecDTO
  type: 'UsernameToken'
}

export interface BitbucketApiAccessSpecDTO {
  [key: string]: any
}

export interface BitbucketAuthentication {
  spec: BitbucketCredentialsDTO
  type: 'Http' | 'Ssh'
}

export type BitbucketConnector = ConnectorConfigDTO & {
  apiAccess?: BitbucketApiAccess
  authentication: BitbucketAuthentication
  delegateSelectors?: string[]
  type: 'Account' | 'Repo'
  url: string
  validationRepo?: string
}

export interface BitbucketCredentialsDTO {
  [key: string]: any
}

export type BitbucketHttpCredentials = BitbucketCredentialsDTO & {
  spec: BitbucketHttpCredentialsSpecDTO
  type: 'UsernamePassword'
}

export interface BitbucketHttpCredentialsSpecDTO {
  [key: string]: any
}

export type BitbucketSshCredentials = BitbucketCredentialsDTO & {
  sshKeyRef: string
}

export type BitbucketUsernamePassword = BitbucketHttpCredentialsSpecDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type BitbucketUsernameTokenApiAccess = BitbucketApiAccessSpecDTO & {
  tokenRef: string
  username?: string
  usernameRef?: string
}

export interface Budget {
  accountId?: string
  actualCost?: number
  alertThresholds?: AlertThreshold[]
  budgetAmount?: number
  createdAt?: number
  emailAddresses?: string[]
  endTime?: number
  forecastCost?: number
  growthRate?: number
  lastMonthCost?: number
  lastUpdatedAt?: number
  name?: string
  notifyOnSlack?: boolean
  period?: 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'QUARTERLY' | 'YEARLY'
  scope?: BudgetScope
  startTime?: number
  type?: 'SPECIFIED_AMOUNT' | 'PREVIOUS_MONTH_SPEND' | 'PREVIOUS_PERIOD_SPEND'
  userGroupIds?: string[]
  uuid?: string
}

export interface BudgetCostData {
  actualCost?: number
  budgetVariance?: number
  budgetVariancePercentage?: number
  budgeted?: number
  time?: number
}

export interface BudgetData {
  costData?: BudgetCostData[]
  forecastCost?: number
}

export interface BudgetScope {
  budgetScopeType?: string
  entityIds?: string[]
  entityNames?: string[]
}

export interface BusinessMapping {
  accountId?: string
  costTargets?: CostTarget[]
  createdAt?: number
  createdBy?: EmbeddedUser
  lastUpdatedAt?: number
  lastUpdatedBy?: EmbeddedUser
  name?: string
  sharedCosts?: SharedCost[]
  uuid?: string
}

export type CEAwsConnector = ConnectorConfigDTO & {
  awsAccountId?: string
  crossAccountAccess: CrossAccountAccess
  curAttributes?: AwsCurAttributes
  featuresEnabled?: ('BILLING' | 'OPTIMIZATION' | 'VISIBILITY')[]
}

export type CEAzureConnector = ConnectorConfigDTO & {
  billingExportSpec?: BillingExportSpec
  featuresEnabled?: ('BILLING' | 'OPTIMIZATION' | 'VISIBILITY')[]
  subscriptionId: string
  tenantId: string
}

export type CEKubernetesClusterConfig = ConnectorConfigDTO & {
  connectorRef: string
  featuresEnabled?: ('BILLING' | 'OPTIMIZATION' | 'VISIBILITY')[]
}

export interface CELicenseUsageDTO {
  accountIdentifier?: string
  activeSpend?: UsageDataDTO
  module?: string
  timestamp?: number
}

export interface CEReportSchedule {
  accountId?: string
  createdAt?: number
  createdBy?: EmbeddedUser
  description?: string
  enabled?: boolean
  lastUpdatedAt?: number
  lastUpdatedBy?: EmbeddedUser
  name?: string
  nextExecution?: string
  recipients?: string[]
  userCron?: string
  userCronTimeZone?: string
  uuid?: string
  viewsId: string[]
}

export interface CEView {
  accountId?: string
  createdAt?: number
  createdBy?: EmbeddedUser
  dataSources?: ('CLUSTER' | 'AWS' | 'GCP' | 'AZURE' | 'COMMON' | 'CUSTOM' | 'BUSINESS_MAPPING' | 'LABEL')[]
  lastUpdatedAt?: number
  lastUpdatedBy?: EmbeddedUser
  name?: string
  totalCost?: number
  uuid?: string
  viewRules?: ViewRule[]
  viewState?: 'DRAFT' | 'COMPLETED'
  viewTimeRange?: ViewTimeRange
  viewType?: 'SAMPLE' | 'CUSTOMER' | 'DEFAULT_AZURE' | 'DEFAULT'
  viewVersion?: string
  viewVisualization?: ViewVisualization
}

export type ClusterBudgetScope = BudgetScope & {
  clusterIds?: string[]
}

export interface ConnectorActivityDetails {
  lastActivityTime?: number
}

export interface ConnectorConfigDTO {
  [key: string]: any
}

export interface ConnectorConnectivityDetails {
  errorSummary?: string
  errors?: ErrorDetail[]
  lastConnectedAt?: number
  lastTestedAt?: number
  status?: 'SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN'
  testedAt?: number
}

export interface ConnectorInfoDTO {
  description?: string
  identifier: string
  name: string
  orgIdentifier?: string
  projectIdentifier?: string
  spec: ConnectorConfigDTO
  tags?: {
    [key: string]: string
  }
  type:
    | 'K8sCluster'
    | 'Git'
    | 'Splunk'
    | 'AppDynamics'
    | 'Prometheus'
    | 'Dynatrace'
    | 'Vault'
    | 'AzureKeyVault'
    | 'DockerRegistry'
    | 'Local'
    | 'AwsKms'
    | 'GcpKms'
    | 'AwsSecretManager'
    | 'Gcp'
    | 'Aws'
    | 'Artifactory'
    | 'Jira'
    | 'Nexus'
    | 'Github'
    | 'Gitlab'
    | 'Bitbucket'
    | 'Codecommit'
    | 'CEAws'
    | 'CEAzure'
    | 'GcpCloudCost'
    | 'CEK8sCluster'
    | 'HttpHelmRepo'
    | 'NewRelic'
    | 'Datadog'
    | 'SumoLogic'
    | 'PagerDuty'
    | 'CustomHealth'
}

export interface ConnectorResponse {
  activityDetails?: ConnectorActivityDetails
  connector?: ConnectorInfoDTO
  createdAt?: number
  entityValidityDetails?: EntityValidityDetails
  gitDetails?: EntityGitDetails
  harnessManaged?: boolean
  lastModifiedAt?: number
  status?: ConnectorConnectivityDetails
}

export interface ConnectorValidationResult {
  delegateId?: string
  errorSummary?: string
  errors?: ErrorDetail[]
  status?: 'SUCCESS' | 'FAILURE' | 'PARTIAL' | 'UNKNOWN'
  testedAt?: number
}

export interface CostTarget {
  name?: string
  rules?: ViewRule[]
}

export interface CrossAccountAccess {
  crossAccountRoleArn: string
  externalId?: string
}

export type CustomHealthConnectorDTO = ConnectorConfigDTO & {
  baseURL: string
  delegateSelectors?: string[]
  headers?: CustomHealthKeyAndValue[]
  method: 'GET' | 'POST'
  params?: CustomHealthKeyAndValue[]
  validationBody?: string
  validationPath?: string
}

export interface CustomHealthKeyAndValue {
  encryptedValueRef?: SecretRefData
  key: string
  value?: string
  valueEncrypted?: boolean
}

export type DatadogConnectorDTO = ConnectorConfigDTO & {
  apiKeyRef: string
  applicationKeyRef: string
  delegateSelectors?: string[]
  url: string
}

export interface DockerAuthCredentialsDTO {
  [key: string]: any
}

export interface DockerAuthenticationDTO {
  spec?: DockerAuthCredentialsDTO
  type: 'UsernamePassword' | 'Anonymous'
}

export type DockerConnectorDTO = ConnectorConfigDTO & {
  auth?: DockerAuthenticationDTO
  delegateSelectors?: string[]
  dockerRegistryUrl: string
  providerType: 'DockerHub' | 'Harbor' | 'Quay' | 'Other'
}

export type DockerUserNamePasswordDTO = DockerAuthCredentialsDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type DynatraceConnectorDTO = ConnectorConfigDTO & {
  apiTokenRef: string
  delegateSelectors?: string[]
  url: string
}

export interface EmbeddedUser {
  email?: string
  name?: string
  uuid?: string
}

export interface EntityGitDetails {
  branch?: string
  filePath?: string
  objectId?: string
  repoIdentifier?: string
  rootFolder?: string
}

export interface EntityValidityDetails {
  invalidYaml?: string
  valid?: boolean
}

export interface Error {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'JIRA_STEP_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
  correlationId?: string
  detailedMessage?: string
  message?: string
  metadata?: ErrorMetadataDTO
  responseMessages?: ResponseMessage[]
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ErrorDetail {
  code?: number
  message?: string
  reason?: string
}

export interface ErrorMetadataDTO {
  type?: string
}

export interface Failure {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'JIRA_STEP_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
  correlationId?: string
  errors?: ValidationError[]
  message?: string
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface GcpBillingExportSpec {
  datasetId: string
}

export type GcpCloudCostConnector = ConnectorConfigDTO & {
  billingExportSpec?: GcpBillingExportSpec
  featuresEnabled?: ('BILLING' | 'OPTIMIZATION' | 'VISIBILITY')[]
  projectId: string
  serviceAccountEmail: string
}

export type GcpConnector = ConnectorConfigDTO & {
  credential?: GcpConnectorCredential
  delegateSelectors?: string[]
}

export interface GcpConnectorCredential {
  spec?: GcpCredentialSpec
  type: 'InheritFromDelegate' | 'ManualConfig'
}

export interface GcpCredentialSpec {
  [key: string]: any
}

export type GcpKmsConnectorDTO = ConnectorConfigDTO & {
  credentials: string
  default?: boolean
  delegateSelectors?: string[]
  keyName?: string
  keyRing?: string
  projectId?: string
  region?: string
}

export type GcpManualDetails = GcpCredentialSpec & {
  secretKeyRef: string
}

export interface GitAuthenticationDTO {
  [key: string]: any
}

export type GitConfigDTO = ConnectorConfigDTO & {
  branchName?: string
  connectionType: 'Account' | 'Repo'
  delegateSelectors?: string[]
  spec: GitAuthenticationDTO
  type: 'Http' | 'Ssh'
  url: string
  validationRepo?: string
}

export type GitHTTPAuthenticationDTO = GitAuthenticationDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type GitSSHAuthenticationDTO = GitAuthenticationDTO & {
  sshKeyRef: string
}

export interface GithubApiAccess {
  spec?: GithubApiAccessSpecDTO
  type: 'GithubApp' | 'Token'
}

export interface GithubApiAccessSpecDTO {
  [key: string]: any
}

export type GithubAppSpec = GithubApiAccessSpecDTO & {
  applicationId: string
  installationId: string
  privateKeyRef: string
}

export interface GithubAuthentication {
  spec: GithubCredentialsDTO
  type: 'Http' | 'Ssh'
}

export type GithubConnector = ConnectorConfigDTO & {
  apiAccess?: GithubApiAccess
  authentication: GithubAuthentication
  delegateSelectors?: string[]
  executeOnDelegate?: boolean
  type: 'Account' | 'Repo'
  url: string
  validationRepo?: string
}

export interface GithubCredentialsDTO {
  [key: string]: any
}

export type GithubHttpCredentials = GithubCredentialsDTO & {
  spec: GithubHttpCredentialsSpecDTO
  type: 'UsernamePassword' | 'UsernameToken'
}

export interface GithubHttpCredentialsSpecDTO {
  [key: string]: any
}

export type GithubSshCredentials = GithubCredentialsDTO & {
  sshKeyRef: string
}

export type GithubTokenSpec = GithubApiAccessSpecDTO & {
  tokenRef: string
}

export type GithubUsernamePassword = GithubHttpCredentialsSpecDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type GithubUsernameToken = GithubHttpCredentialsSpecDTO & {
  tokenRef: string
  username?: string
  usernameRef?: string
}

export interface GitlabApiAccess {
  spec?: GitlabApiAccessSpecDTO
  type: 'Token'
}

export interface GitlabApiAccessSpecDTO {
  [key: string]: any
}

export interface GitlabAuthentication {
  spec: GitlabCredentialsDTO
  type: 'Http' | 'Ssh'
}

export type GitlabConnector = ConnectorConfigDTO & {
  apiAccess?: GitlabApiAccess
  authentication: GitlabAuthentication
  delegateSelectors?: string[]
  type: 'Account' | 'Repo'
  url: string
  validationRepo?: string
}

export interface GitlabCredentialsDTO {
  [key: string]: any
}

export type GitlabHttpCredentials = GitlabCredentialsDTO & {
  spec: GitlabHttpCredentialsSpecDTO
  type: 'UsernamePassword' | 'UsernameToken' | 'Kerberos'
}

export interface GitlabHttpCredentialsSpecDTO {
  [key: string]: any
}

export type GitlabKerberos = GitlabHttpCredentialsSpecDTO & {
  kerberosKeyRef: string
}

export type GitlabSshCredentials = GitlabCredentialsDTO & {
  sshKeyRef: string
}

export type GitlabTokenSpec = GitlabApiAccessSpecDTO & {
  tokenRef: string
}

export type GitlabUsernamePassword = GitlabHttpCredentialsSpecDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type GitlabUsernameToken = GitlabHttpCredentialsSpecDTO & {
  tokenRef: string
  username?: string
  usernameRef?: string
}

export interface GraphQLQuery {
  operationName?: string
  query?: string
  variables?: {
    [key: string]: { [key: string]: any }
  }
}

export interface HttpHelmAuthCredentialsDTO {
  [key: string]: any
}

export interface HttpHelmAuthenticationDTO {
  spec?: HttpHelmAuthCredentialsDTO
  type: 'UsernamePassword' | 'Anonymous'
}

export type HttpHelmConnectorDTO = ConnectorConfigDTO & {
  auth?: HttpHelmAuthenticationDTO
  delegateSelectors?: string[]
  helmRepoUrl: string
}

export type HttpHelmUsernamePasswordDTO = HttpHelmAuthCredentialsDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type JiraConnector = ConnectorConfigDTO & {
  delegateSelectors?: string[]
  jiraUrl: string
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface K8sClusterSetupRequest {
  ccmConnectorIdentifier?: string
  connectorIdentifier?: string
  featuresEnabled?: ('BILLING' | 'OPTIMIZATION' | 'VISIBILITY')[]
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface KubernetesAuthCredentialDTO {
  [key: string]: any
}

export interface KubernetesAuthDTO {
  spec: KubernetesAuthCredentialDTO
  type: 'UsernamePassword' | 'ClientKeyCert' | 'ServiceAccount' | 'OpenIdConnect'
}

export type KubernetesClientKeyCertDTO = KubernetesAuthCredentialDTO & {
  caCertRef?: string
  clientCertRef: string
  clientKeyAlgo?: string
  clientKeyPassphraseRef?: string
  clientKeyRef: string
}

export type KubernetesClusterConfigDTO = ConnectorConfigDTO & {
  credential: KubernetesCredentialDTO
  delegateSelectors?: string[]
}

export type KubernetesClusterDetailsDTO = KubernetesCredentialSpecDTO & {
  auth: KubernetesAuthDTO
  masterUrl: string
}

export interface KubernetesCredentialDTO {
  spec?: KubernetesCredentialSpecDTO
  type: 'InheritFromDelegate' | 'ManualConfig'
}

export interface KubernetesCredentialSpecDTO {
  [key: string]: any
}

export type KubernetesOpenIdConnectDTO = KubernetesAuthCredentialDTO & {
  oidcClientIdRef: string
  oidcIssuerUrl?: string
  oidcPasswordRef: string
  oidcScopes?: string
  oidcSecretRef?: string
  oidcUsername?: string
  oidcUsernameRef?: string
}

export type KubernetesServiceAccountDTO = KubernetesAuthCredentialDTO & {
  serviceAccountTokenRef: string
}

export type KubernetesUserNamePasswordDTO = KubernetesAuthCredentialDTO & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export interface LicenseUsageDTO {
  accountIdentifier?: string
  module?: string
  timestamp?: number
}

export type LocalConnectorDTO = ConnectorConfigDTO & {
  default?: boolean
}

export type NewRelicConnectorDTO = ConnectorConfigDTO & {
  apiKeyRef: string
  delegateSelectors?: string[]
  newRelicAccountId: string
  url: string
}

export interface NexusAuthCredentials {
  [key: string]: any
}

export interface NexusAuthentication {
  spec?: NexusAuthCredentials
  type: 'UsernamePassword' | 'Anonymous'
}

export type NexusConnector = ConnectorConfigDTO & {
  auth?: NexusAuthentication
  delegateSelectors?: string[]
  nexusServerUrl: string
  version: string
}

export type NexusUsernamePasswordAuth = NexusAuthCredentials & {
  passwordRef: string
  username?: string
  usernameRef?: string
}

export type PagerDutyConnectorDTO = ConnectorConfigDTO & {
  apiTokenRef: string
  delegateSelectors?: string[]
}

export type PerspectiveBudgetScope = BudgetScope & {
  viewId?: string
  viewName?: string
}

export type PrometheusConnectorDTO = ConnectorConfigDTO & {
  delegateSelectors?: string[]
  url: string
}

export interface QueryStat {
  avgExecutionTime?: number
  count?: number
  maxExecutionTime?: number
  secondMaxExecutionTime?: number
}

export interface ReferenceDTO {
  accountIdentifier?: string
  identifier?: string
  name?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export interface Response {
  correlationId?: string
  data?: { [key: string]: any }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseAwsAccountConnectionDetail {
  correlationId?: string
  data?: AwsAccountConnectionDetail
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBudget {
  correlationId?: string
  data?: Budget
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseBudgetData {
  correlationId?: string
  data?: BudgetData
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCELicenseUsageDTO {
  correlationId?: string
  data?: CELicenseUsageDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseCEView {
  correlationId?: string
  data?: CEView
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseConnectorValidationResult {
  correlationId?: string
  data?: ConnectorValidationResult
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseDouble {
  correlationId?: string
  data?: number
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseLicenseUsageDTO {
  correlationId?: string
  data?: LicenseUsageDTO
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListBudget {
  correlationId?: string
  data?: Budget[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseListCEReportSchedule {
  correlationId?: string
  data?: CEReportSchedule[]
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMapStringQueryStat {
  correlationId?: string
  data?: {
    [key: string]: QueryStat
  }
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface ResponseMessage {
  code?:
    | 'DEFAULT_ERROR_CODE'
    | 'INVALID_ARGUMENT'
    | 'INVALID_EMAIL'
    | 'DOMAIN_NOT_ALLOWED_TO_REGISTER'
    | 'COMMNITY_EDITION_NOT_FOUND'
    | 'DEPLOY_MODE_IS_NOT_ON_PREM'
    | 'USER_ALREADY_REGISTERED'
    | 'USER_INVITATION_DOES_NOT_EXIST'
    | 'USER_DOES_NOT_EXIST'
    | 'USER_INVITE_OPERATION_FAILED'
    | 'USER_DISABLED'
    | 'ACCOUNT_DOES_NOT_EXIST'
    | 'INACTIVE_ACCOUNT'
    | 'ACCOUNT_MIGRATED'
    | 'USER_DOMAIN_NOT_ALLOWED'
    | 'MAX_FAILED_ATTEMPT_COUNT_EXCEEDED'
    | 'RESOURCE_NOT_FOUND'
    | 'ROLE_DOES_NOT_EXIST'
    | 'EMAIL_NOT_VERIFIED'
    | 'EMAIL_VERIFICATION_TOKEN_NOT_FOUND'
    | 'INVALID_TOKEN'
    | 'REVOKED_TOKEN'
    | 'INVALID_CAPTCHA_TOKEN'
    | 'NOT_ACCOUNT_MGR_NOR_HAS_ALL_APP_ACCESS'
    | 'EXPIRED_TOKEN'
    | 'TOKEN_ALREADY_REFRESHED_ONCE'
    | 'ACCESS_DENIED'
    | 'NG_ACCESS_DENIED'
    | 'INVALID_CREDENTIAL'
    | 'INVALID_CREDENTIALS_THIRD_PARTY'
    | 'INVALID_KEY'
    | 'INVALID_CONNECTOR_TYPE'
    | 'INVALID_KEYPATH'
    | 'INVALID_VARIABLE'
    | 'UNKNOWN_HOST'
    | 'UNREACHABLE_HOST'
    | 'INVALID_PORT'
    | 'SSH_SESSION_TIMEOUT'
    | 'SOCKET_CONNECTION_ERROR'
    | 'CONNECTION_ERROR'
    | 'SOCKET_CONNECTION_TIMEOUT'
    | 'CONNECTION_TIMEOUT'
    | 'SSH_CONNECTION_ERROR'
    | 'USER_GROUP_ERROR'
    | 'INVALID_EXECUTION_ID'
    | 'ERROR_IN_GETTING_CHANNEL_STREAMS'
    | 'UNEXPECTED'
    | 'UNKNOWN_ERROR'
    | 'UNKNOWN_EXECUTOR_TYPE_ERROR'
    | 'DUPLICATE_STATE_NAMES'
    | 'TRANSITION_NOT_LINKED'
    | 'TRANSITION_TO_INCORRECT_STATE'
    | 'TRANSITION_TYPE_NULL'
    | 'STATES_WITH_DUP_TRANSITIONS'
    | 'BARRIERS_NOT_RUNNING_CONCURRENTLY'
    | 'NON_FORK_STATES'
    | 'NON_REPEAT_STATES'
    | 'INITIAL_STATE_NOT_DEFINED'
    | 'FILE_INTEGRITY_CHECK_FAILED'
    | 'INVALID_URL'
    | 'FILE_DOWNLOAD_FAILED'
    | 'PLATFORM_SOFTWARE_DELETE_ERROR'
    | 'INVALID_CSV_FILE'
    | 'INVALID_REQUEST'
    | 'SCHEMA_VALIDATION_FAILED'
    | 'FILTER_CREATION_ERROR'
    | 'INVALID_YAML_ERROR'
    | 'PLAN_CREATION_ERROR'
    | 'INVALID_INFRA_STATE'
    | 'PIPELINE_ALREADY_TRIGGERED'
    | 'NON_EXISTING_PIPELINE'
    | 'DUPLICATE_COMMAND_NAMES'
    | 'INVALID_PIPELINE'
    | 'COMMAND_DOES_NOT_EXIST'
    | 'DUPLICATE_ARTIFACTSTREAM_NAMES'
    | 'DUPLICATE_HOST_NAMES'
    | 'STATE_NOT_FOR_TYPE'
    | 'STATE_MACHINE_ISSUE'
    | 'STATE_DISCONTINUE_FAILED'
    | 'STATE_PAUSE_FAILED'
    | 'PAUSE_ALL_ALREADY'
    | 'RESUME_ALL_ALREADY'
    | 'ROLLBACK_ALREADY'
    | 'ABORT_ALL_ALREADY'
    | 'EXPIRE_ALL_ALREADY'
    | 'RETRY_FAILED'
    | 'UNKNOWN_ARTIFACT_TYPE'
    | 'UNKNOWN_STAGE_ELEMENT_WRAPPER_TYPE'
    | 'INIT_TIMEOUT'
    | 'LICENSE_EXPIRED'
    | 'NOT_LICENSED'
    | 'REQUEST_TIMEOUT'
    | 'WORKFLOW_ALREADY_TRIGGERED'
    | 'JENKINS_ERROR'
    | 'INVALID_ARTIFACT_SOURCE'
    | 'INVALID_ARTIFACT_SERVER'
    | 'INVALID_CLOUD_PROVIDER'
    | 'UPDATE_NOT_ALLOWED'
    | 'DELETE_NOT_ALLOWED'
    | 'APPDYNAMICS_CONFIGURATION_ERROR'
    | 'APM_CONFIGURATION_ERROR'
    | 'SPLUNK_CONFIGURATION_ERROR'
    | 'ELK_CONFIGURATION_ERROR'
    | 'LOGZ_CONFIGURATION_ERROR'
    | 'SUMO_CONFIGURATION_ERROR'
    | 'INSTANA_CONFIGURATION_ERROR'
    | 'APPDYNAMICS_ERROR'
    | 'STACKDRIVER_ERROR'
    | 'STACKDRIVER_CONFIGURATION_ERROR'
    | 'NEWRELIC_CONFIGURATION_ERROR'
    | 'NEWRELIC_ERROR'
    | 'DYNA_TRACE_CONFIGURATION_ERROR'
    | 'DYNA_TRACE_ERROR'
    | 'CLOUDWATCH_ERROR'
    | 'CLOUDWATCH_CONFIGURATION_ERROR'
    | 'PROMETHEUS_CONFIGURATION_ERROR'
    | 'DATA_DOG_CONFIGURATION_ERROR'
    | 'SERVICE_GUARD_CONFIGURATION_ERROR'
    | 'ENCRYPTION_NOT_CONFIGURED'
    | 'UNAVAILABLE_DELEGATES'
    | 'WORKFLOW_EXECUTION_IN_PROGRESS'
    | 'PIPELINE_EXECUTION_IN_PROGRESS'
    | 'AWS_ACCESS_DENIED'
    | 'AWS_CLUSTER_NOT_FOUND'
    | 'AWS_SERVICE_NOT_FOUND'
    | 'IMAGE_NOT_FOUND'
    | 'ILLEGAL_ARGUMENT'
    | 'IMAGE_TAG_NOT_FOUND'
    | 'DELEGATE_NOT_AVAILABLE'
    | 'INVALID_YAML_PAYLOAD'
    | 'AUTHENTICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'UNRECOGNIZED_YAML_FIELDS'
    | 'COULD_NOT_MAP_BEFORE_YAML'
    | 'MISSING_BEFORE_YAML'
    | 'MISSING_YAML'
    | 'NON_EMPTY_DELETIONS'
    | 'GENERAL_YAML_ERROR'
    | 'GENERAL_YAML_INFO'
    | 'YAML_GIT_SYNC_ERROR'
    | 'GIT_CONNECTION_ERROR'
    | 'GIT_ERROR'
    | 'ARTIFACT_SERVER_ERROR'
    | 'ENCRYPT_DECRYPT_ERROR'
    | 'SECRET_MANAGEMENT_ERROR'
    | 'SECRET_NOT_FOUND'
    | 'KMS_OPERATION_ERROR'
    | 'GCP_KMS_OPERATION_ERROR'
    | 'VAULT_OPERATION_ERROR'
    | 'AWS_SECRETS_MANAGER_OPERATION_ERROR'
    | 'AZURE_KEY_VAULT_OPERATION_ERROR'
    | 'CYBERARK_OPERATION_ERROR'
    | 'UNSUPPORTED_OPERATION_EXCEPTION'
    | 'FEATURE_UNAVAILABLE'
    | 'GENERAL_ERROR'
    | 'BASELINE_CONFIGURATION_ERROR'
    | 'SAML_IDP_CONFIGURATION_NOT_AVAILABLE'
    | 'INVALID_AUTHENTICATION_MECHANISM'
    | 'INVALID_SAML_CONFIGURATION'
    | 'INVALID_OAUTH_CONFIGURATION'
    | 'INVALID_LDAP_CONFIGURATION'
    | 'USER_GROUP_SYNC_FAILURE'
    | 'USER_GROUP_ALREADY_EXIST'
    | 'INVALID_TWO_FACTOR_AUTHENTICATION_CONFIGURATION'
    | 'EXPLANATION'
    | 'HINT'
    | 'NOT_WHITELISTED_IP'
    | 'INVALID_TOTP_TOKEN'
    | 'EMAIL_FAILED'
    | 'SSL_HANDSHAKE_FAILED'
    | 'NO_APPS_ASSIGNED'
    | 'INVALID_INFRA_CONFIGURATION'
    | 'TEMPLATES_LINKED'
    | 'USER_HAS_NO_PERMISSIONS'
    | 'USER_NOT_AUTHORIZED'
    | 'USER_ALREADY_PRESENT'
    | 'INVALID_USAGE_RESTRICTION'
    | 'USAGE_RESTRICTION_ERROR'
    | 'STATE_EXECUTION_INSTANCE_NOT_FOUND'
    | 'DELEGATE_TASK_RETRY'
    | 'KUBERNETES_API_TASK_EXCEPTION'
    | 'KUBERNETES_TASK_EXCEPTION'
    | 'KUBERNETES_YAML_ERROR'
    | 'SAVE_FILE_INTO_GCP_STORAGE_FAILED'
    | 'READ_FILE_FROM_GCP_STORAGE_FAILED'
    | 'FILE_NOT_FOUND_ERROR'
    | 'USAGE_LIMITS_EXCEEDED'
    | 'EVENT_PUBLISH_FAILED'
    | 'JIRA_ERROR'
    | 'EXPRESSION_EVALUATION_FAILED'
    | 'KUBERNETES_VALUES_ERROR'
    | 'KUBERNETES_CLUSTER_ERROR'
    | 'INCORRECT_SIGN_IN_MECHANISM'
    | 'OAUTH_LOGIN_FAILED'
    | 'INVALID_TERRAFORM_TARGETS_REQUEST'
    | 'TERRAFORM_EXECUTION_ERROR'
    | 'FILE_READ_FAILED'
    | 'FILE_SIZE_EXCEEDS_LIMIT'
    | 'CLUSTER_NOT_FOUND'
    | 'MARKETPLACE_TOKEN_NOT_FOUND'
    | 'INVALID_MARKETPLACE_TOKEN'
    | 'INVALID_TICKETING_SERVER'
    | 'SERVICENOW_ERROR'
    | 'PASSWORD_EXPIRED'
    | 'USER_LOCKED'
    | 'PASSWORD_STRENGTH_CHECK_FAILED'
    | 'ACCOUNT_DISABLED'
    | 'INVALID_ACCOUNT_PERMISSION'
    | 'PAGERDUTY_ERROR'
    | 'HEALTH_ERROR'
    | 'SAML_TEST_SUCCESS_MECHANISM_NOT_ENABLED'
    | 'DOMAIN_WHITELIST_FILTER_CHECK_FAILED'
    | 'INVALID_DASHBOARD_UPDATE_REQUEST'
    | 'DUPLICATE_FIELD'
    | 'INVALID_AZURE_VAULT_CONFIGURATION'
    | 'USER_NOT_AUTHORIZED_DUE_TO_USAGE_RESTRICTIONS'
    | 'INVALID_ROLLBACK'
    | 'DATA_COLLECTION_ERROR'
    | 'SUMO_DATA_COLLECTION_ERROR'
    | 'DEPLOYMENT_GOVERNANCE_ERROR'
    | 'BATCH_PROCESSING_ERROR'
    | 'GRAPHQL_ERROR'
    | 'FILE_CREATE_ERROR'
    | 'ILLEGAL_STATE'
    | 'GIT_DIFF_COMMIT_NOT_IN_ORDER'
    | 'FAILED_TO_ACQUIRE_PERSISTENT_LOCK'
    | 'FAILED_TO_ACQUIRE_NON_PERSISTENT_LOCK'
    | 'POD_NOT_FOUND_ERROR'
    | 'COMMAND_EXECUTION_ERROR'
    | 'REGISTRY_EXCEPTION'
    | 'ENGINE_INTERRUPT_PROCESSING_EXCEPTION'
    | 'ENGINE_IO_EXCEPTION'
    | 'ENGINE_OUTCOME_EXCEPTION'
    | 'ENGINE_SWEEPING_OUTPUT_EXCEPTION'
    | 'CACHE_NOT_FOUND_EXCEPTION'
    | 'ENGINE_ENTITY_UPDATE_EXCEPTION'
    | 'SHELL_EXECUTION_EXCEPTION'
    | 'TEMPLATE_NOT_FOUND'
    | 'AZURE_SERVICE_EXCEPTION'
    | 'AZURE_CLIENT_EXCEPTION'
    | 'GIT_UNSEEN_REMOTE_HEAD_COMMIT'
    | 'TIMEOUT_ENGINE_EXCEPTION'
    | 'NO_AVAILABLE_DELEGATES'
    | 'NO_INSTALLED_DELEGATES'
    | 'DUPLICATE_DELEGATE_EXCEPTION'
    | 'GCP_MARKETPLACE_EXCEPTION'
    | 'MISSING_DEFAULT_GOOGLE_CREDENTIALS'
    | 'INCORRECT_DEFAULT_GOOGLE_CREDENTIALS'
    | 'OPTIMISTIC_LOCKING_EXCEPTION'
    | 'NG_PIPELINE_EXECUTION_EXCEPTION'
    | 'NG_PIPELINE_CREATE_EXCEPTION'
    | 'RESOURCE_NOT_FOUND_EXCEPTION'
    | 'PMS_INITIALIZE_SDK_EXCEPTION'
    | 'UNEXPECTED_SNIPPET_EXCEPTION'
    | 'UNEXPECTED_SCHEMA_EXCEPTION'
    | 'CONNECTOR_VALIDATION_EXCEPTION'
    | 'TIMESCALE_NOT_AVAILABLE'
    | 'MIGRATION_EXCEPTION'
    | 'REQUEST_PROCESSING_INTERRUPTED'
    | 'GCP_SECRET_MANAGER_OPERATION_ERROR'
    | 'GCP_SECRET_OPERATION_ERROR'
    | 'GIT_OPERATION_ERROR'
    | 'TASK_FAILURE_ERROR'
    | 'INSTANCE_STATS_PROCESS_ERROR'
    | 'INSTANCE_STATS_MIGRATION_ERROR'
    | 'DEPLOYMENT_MIGRATION_ERROR'
    | 'INSTANCE_STATS_AGGREGATION_ERROR'
    | 'UNRESOLVED_EXPRESSIONS_ERROR'
    | 'KRYO_HANDLER_NOT_FOUND_ERROR'
    | 'DELEGATE_ERROR_HANDLER_EXCEPTION'
    | 'UNEXPECTED_TYPE_ERROR'
    | 'EXCEPTION_HANDLER_NOT_FOUND'
    | 'CONNECTOR_NOT_FOUND_EXCEPTION'
    | 'GCP_SERVER_ERROR'
    | 'HTTP_RESPONSE_EXCEPTION'
    | 'SCM_NOT_FOUND_ERROR'
    | 'SCM_CONFLICT_ERROR'
    | 'SCM_UNPROCESSABLE_ENTITY'
    | 'PROCESS_EXECUTION_EXCEPTION'
    | 'SCM_UNAUTHORIZED'
    | 'DATA'
    | 'CONTEXT'
    | 'PR_CREATION_ERROR'
    | 'URL_NOT_REACHABLE'
    | 'URL_NOT_PROVIDED'
    | 'ENGINE_EXPRESSION_EVALUATION_ERROR'
    | 'ENGINE_FUNCTOR_ERROR'
    | 'JIRA_CLIENT_ERROR'
    | 'SCM_NOT_MODIFIED'
    | 'APPROVAL_STEP_NG_ERROR'
    | 'BUCKET_SERVER_ERROR'
    | 'GIT_SYNC_ERROR'
    | 'TEMPLATE_EXCEPTION'
  exception?: Throwable
  failureTypes?: (
    | 'EXPIRED'
    | 'DELEGATE_PROVISIONING'
    | 'CONNECTIVITY'
    | 'AUTHENTICATION'
    | 'VERIFICATION_FAILURE'
    | 'APPLICATION_ERROR'
    | 'AUTHORIZATION_ERROR'
    | 'TIMEOUT_ERROR'
  )[]
  level?: 'INFO' | 'ERROR'
  message?: string
}

export interface ResponseString {
  correlationId?: string
  data?: string
  metaData?: { [key: string]: any }
  status?: 'SUCCESS' | 'FAILURE' | 'ERROR'
}

export interface RestResponse {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: { [key: string]: any }
  responseMessages?: ResponseMessage[]
}

export interface RestResponseBoolean {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: boolean
  responseMessages?: ResponseMessage[]
}

export interface RestResponseBusinessMapping {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: BusinessMapping
  responseMessages?: ResponseMessage[]
}

export interface RestResponseListBusinessMapping {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: BusinessMapping[]
  responseMessages?: ResponseMessage[]
}

export interface RestResponseString {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: string
  responseMessages?: ResponseMessage[]
}

export interface RestResponseViewCustomField {
  metaData?: {
    [key: string]: { [key: string]: any }
  }
  resource?: ViewCustomField
  responseMessages?: ResponseMessage[]
}

export type SampleErrorMetadataDTO = ErrorMetadataDTO & {
  sampleMap?: {
    [key: string]: string
  }
}

export interface SecretRefData {
  decryptedValue?: string[]
  identifier?: string
  null?: boolean
  scope?: 'account' | 'org' | 'project' | 'unknown'
}

export interface SharedCost {
  name?: string
  rules?: ViewRule[]
  splits?: SharedCostSplit[]
  strategy?: 'FIXED' | 'PROPORTIONAL'
}

export interface SharedCostSplit {
  costTargetName?: string
  percentageContribution?: number
}

export type SplunkConnectorDTO = ConnectorConfigDTO & {
  accountId: string
  delegateSelectors?: string[]
  passwordRef: string
  splunkUrl: string
  username?: string
}

export interface StackTraceElement {
  className?: string
  fileName?: string
  lineNumber?: number
  methodName?: string
  nativeMethod?: boolean
}

export type SumoLogicConnectorDTO = ConnectorConfigDTO & {
  accessIdRef: string
  accessKeyRef: string
  delegateSelectors?: string[]
  url: string
}

export interface TemplateInputsErrorDTO {
  fieldName?: string
  identifierOfErrorSource?: string
  message?: string
}

export type TemplateInputsErrorMetadataDTO = ErrorMetadataDTO & {
  errorMap?: {
    [key: string]: TemplateInputsErrorDTO
  }
  errorYaml?: string
}

export interface Throwable {
  cause?: Throwable
  localizedMessage?: string
  message?: string
  stackTrace?: StackTraceElement[]
  suppressed?: Throwable[]
}

export interface UsageDataDTO {
  count?: number
  displayName?: string
  references?: ReferenceDTO[]
}

export interface ValidationError {
  error?: string
  fieldId?: string
}

export type VaultConnectorDTO = ConnectorConfigDTO & {
  accessType?: 'APP_ROLE' | 'TOKEN' | 'VAULT_AGENT'
  appRoleId?: string
  authToken?: string
  basePath?: string
  default?: boolean
  delegateSelectors?: string[]
  namespace?: string
  readOnly?: boolean
  renewalIntervalMinutes?: number
  secretEngineManuallyConfigured?: boolean
  secretEngineName?: string
  secretEngineVersion?: number
  secretId?: string
  sinkPath?: string
  useVaultAgent?: boolean
  vaultUrl?: string
}

export interface ViewCondition {
  type?: string
}

export interface ViewCustomField {
  accountId?: string
  createdAt?: number
  description?: string
  displayFormula?: string
  lastUpdatedAt?: number
  name?: string
  sqlFormula?: string
  userDefinedExpression?: string
  uuid?: string
  viewFields?: ViewField[]
  viewId?: string
}

export interface ViewField {
  fieldId?: string
  fieldName?: string
  identifier?: 'CLUSTER' | 'AWS' | 'GCP' | 'AZURE' | 'COMMON' | 'CUSTOM' | 'BUSINESS_MAPPING' | 'LABEL'
  identifierName?: string
}

export type ViewIdCondition = ViewCondition & {
  values?: string[]
  viewField?: ViewField
  viewOperator?: 'IN' | 'NOT_IN' | 'NOT_NULL' | 'NULL'
}

export interface ViewRule {
  viewConditions?: ViewCondition[]
}

export interface ViewTimeRange {
  endTime?: number
  startTime?: number
  viewTimeRangeType?: 'LAST_7' | 'LAST_30' | 'LAST_MONTH' | 'CURRENT_MONTH' | 'CUSTOM'
}

export interface ViewVisualization {
  chartType?: 'STACKED_TIME_SERIES' | 'STACKED_LINE_CHART'
  granularity?: 'DAY' | 'MONTH'
  groupBy?: ViewField
}

export type BudgetRequestBody = Budget

export type BusinessMappingRequestBody = BusinessMapping

export type CEReportScheduleRequestBody = CEReportSchedule

export type CEViewRequestBody = CEView

export type K8sClusterSetupRequestRequestBody = K8sClusterSetupRequest

export type ViewCustomFieldRequestBody = ViewCustomField

export interface ListBudgetsForAccountQueryParams {
  accountIdentifier: string
}

export type ListBudgetsForAccountProps = Omit<
  GetProps<ResponseListBudget, unknown, ListBudgetsForAccountQueryParams, void>,
  'path'
>

/**
 * List budgets for account
 */
export const ListBudgetsForAccount = (props: ListBudgetsForAccountProps) => (
  <Get<ResponseListBudget, unknown, ListBudgetsForAccountQueryParams, void>
    path={`/budgets`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseListBudgetsForAccountProps = Omit<
  UseGetProps<ResponseListBudget, unknown, ListBudgetsForAccountQueryParams, void>,
  'path'
>

/**
 * List budgets for account
 */
export const useListBudgetsForAccount = (props: UseListBudgetsForAccountProps) =>
  useGet<ResponseListBudget, unknown, ListBudgetsForAccountQueryParams, void>(`/budgets`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface CreateBudgetQueryParams {
  accountIdentifier: string
}

export type CreateBudgetProps = Omit<
  MutateProps<ResponseString, unknown, CreateBudgetQueryParams, BudgetRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create budget
 */
export const CreateBudget = (props: CreateBudgetProps) => (
  <Mutate<ResponseString, unknown, CreateBudgetQueryParams, BudgetRequestBody, void>
    verb="POST"
    path={`/budgets`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseCreateBudgetProps = Omit<
  UseMutateProps<ResponseString, unknown, CreateBudgetQueryParams, BudgetRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create budget
 */
export const useCreateBudget = (props: UseCreateBudgetProps) =>
  useMutate<ResponseString, unknown, CreateBudgetQueryParams, BudgetRequestBody, void>('POST', `/budgets`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface GetForecastCostQueryParams {
  accountIdentifier?: string
  perspectiveId?: string
}

export type GetForecastCostProps = Omit<GetProps<ResponseDouble, unknown, GetForecastCostQueryParams, void>, 'path'>

/**
 * Deprecated use /perspective/forecastCost instead, Get forecast cost for perspective.
 */
export const GetForecastCost = (props: GetForecastCostProps) => (
  <Get<ResponseDouble, unknown, GetForecastCostQueryParams, void>
    path={`/budgets/forecastCost`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetForecastCostProps = Omit<
  UseGetProps<ResponseDouble, unknown, GetForecastCostQueryParams, void>,
  'path'
>

/**
 * Deprecated use /perspective/forecastCost instead, Get forecast cost for perspective.
 */
export const useGetForecastCost = (props: UseGetForecastCostProps) =>
  useGet<ResponseDouble, unknown, GetForecastCostQueryParams, void>(`/budgets/forecastCost`, {
    base: getConfig('ccm/api'),
    ...props
  })
export interface GetLastPeriodCostQueryParams {
  accountIdentifier: string
  perspectiveId: string
  startTime: number
  period: 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'QUARTERLY' | 'YEARLY'
}

export type GetLastPeriodCostProps = Omit<GetProps<ResponseDouble, unknown, GetLastPeriodCostQueryParams, void>, 'path'>

/**
 * Get last period cost for perspective
 */
export const GetLastPeriodCost = (props: GetLastPeriodCostProps) => (
  <Get<ResponseDouble, unknown, GetLastPeriodCostQueryParams, void>
    path={`/perspective/lastPeriodCost`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetLastPeriodCostProps = Omit<
  UseGetProps<ResponseDouble, unknown, GetLastPeriodCostQueryParams, void>,
  'path'
>

/**
 * Get last period cost for perspective
 */
export const useGetLastPeriodCost = (props: UseGetLastPeriodCostProps) =>
  useGet<ResponseDouble, unknown, GetLastPeriodCostQueryParams, void>(`/perspective/lastPeriodCost`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface GetForecastCostForPeriodQueryParams {
  accountIdentifier: string
  perspectiveId: string
  startTime: number
  period: 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'QUARTERLY' | 'YEARLY'
}

export type GetForecastCostForPeriodProps = Omit<
  GetProps<ResponseDouble, unknown, GetForecastCostForPeriodQueryParams, void>,
  'path'
>

/**
 * Get forecast cost for perspective for given period
 */
export const GetForecastCostForPeriod = (props: GetForecastCostForPeriodProps) => (
  <Get<ResponseDouble, unknown, GetForecastCostForPeriodQueryParams, void>
    path={`/perspective/forecastCostForPeriod`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetForecastCostForPeriodProps = Omit<
  UseGetProps<ResponseDouble, unknown, GetForecastCostForPeriodQueryParams, void>,
  'path'
>

/**
 * Get forecast cost for perspective for given period
 */
export const useGetForecastCostForPeriod = (props: UseGetForecastCostForPeriodProps) =>
  useGet<ResponseDouble, unknown, GetForecastCostForPeriodQueryParams, void>(`/perspective/forecastCostForPeriod`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface GetLastMonthCostQueryParams {
  accountIdentifier: string
  perspectiveId?: string
}

export type GetLastMonthCostProps = Omit<GetProps<ResponseDouble, unknown, GetLastMonthCostQueryParams, void>, 'path'>

/**
 * Deprecated use /perspective/lastMonthCost instead, Get last month cost for perspective.
 */
export const GetLastMonthCost = (props: GetLastMonthCostProps) => (
  <Get<ResponseDouble, unknown, GetLastMonthCostQueryParams, void>
    path={`/budgets/lastMonthCost`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetLastMonthCostProps = Omit<
  UseGetProps<ResponseDouble, unknown, GetLastMonthCostQueryParams, void>,
  'path'
>

/**
 * Deprecated use /perspective/lastMonthCost instead, Get last month cost for perspective.
 */
export const useGetLastMonthCost = (props: UseGetLastMonthCostProps) =>
  useGet<ResponseDouble, unknown, GetLastMonthCostQueryParams, void>(`/budgets/lastMonthCost`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface ListBudgetsForPerspectiveQueryParams {
  accountIdentifier: string
  perspectiveId?: string
}

export type ListBudgetsForPerspectiveProps = Omit<
  GetProps<ResponseListBudget, unknown, ListBudgetsForPerspectiveQueryParams, void>,
  'path'
>

/**
 * List budgets for perspective
 */
export const ListBudgetsForPerspective = (props: ListBudgetsForPerspectiveProps) => (
  <Get<ResponseListBudget, unknown, ListBudgetsForPerspectiveQueryParams, void>
    path={`/budgets/perspectiveBudgets`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseListBudgetsForPerspectiveProps = Omit<
  UseGetProps<ResponseListBudget, unknown, ListBudgetsForPerspectiveQueryParams, void>,
  'path'
>

/**
 * List budgets for perspective
 */
export const useListBudgetsForPerspective = (props: UseListBudgetsForPerspectiveProps) =>
  useGet<ResponseListBudget, unknown, ListBudgetsForPerspectiveQueryParams, void>(`/budgets/perspectiveBudgets`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface DeleteBudgetQueryParams {
  accountIdentifier: string
}

export type DeleteBudgetProps = Omit<
  MutateProps<ResponseString, unknown, DeleteBudgetQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete budget
 */
export const DeleteBudget = (props: DeleteBudgetProps) => (
  <Mutate<ResponseString, unknown, DeleteBudgetQueryParams, string, void>
    verb="DELETE"
    path={`/budgets`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseDeleteBudgetProps = Omit<
  UseMutateProps<ResponseString, unknown, DeleteBudgetQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete budget
 */
export const useDeleteBudget = (props: UseDeleteBudgetProps) =>
  useMutate<ResponseString, unknown, DeleteBudgetQueryParams, string, void>('DELETE', `/budgets`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface GetBudgetQueryParams {
  accountIdentifier: string
}

export interface GetBudgetPathParams {
  id: string
}

export type GetBudgetProps = Omit<
  GetProps<ResponseBudget, unknown, GetBudgetQueryParams, GetBudgetPathParams>,
  'path'
> &
  GetBudgetPathParams

/**
 * Get budget
 */
export const GetBudget = ({ id, ...props }: GetBudgetProps) => (
  <Get<ResponseBudget, unknown, GetBudgetQueryParams, GetBudgetPathParams>
    path={`/budgets/${id}`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetBudgetProps = Omit<
  UseGetProps<ResponseBudget, unknown, GetBudgetQueryParams, GetBudgetPathParams>,
  'path'
> &
  GetBudgetPathParams

/**
 * Get budget
 */
export const useGetBudget = ({ id, ...props }: UseGetBudgetProps) =>
  useGet<ResponseBudget, unknown, GetBudgetQueryParams, GetBudgetPathParams>(
    (paramsInPath: GetBudgetPathParams) => `/budgets/${paramsInPath.id}`,
    { base: getConfig('ccm/api'), pathParams: { id }, ...props }
  )

export interface CloneBudgetQueryParams {
  accountIdentifier: string
  cloneName?: string
}

export interface CloneBudgetPathParams {
  id: string
}

export type CloneBudgetProps = Omit<
  MutateProps<ResponseString, unknown, CloneBudgetQueryParams, void, CloneBudgetPathParams>,
  'path' | 'verb'
> &
  CloneBudgetPathParams

/**
 * Clone budget
 */
export const CloneBudget = ({ id, ...props }: CloneBudgetProps) => (
  <Mutate<ResponseString, unknown, CloneBudgetQueryParams, void, CloneBudgetPathParams>
    verb="POST"
    path={`/budgets/${id}`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseCloneBudgetProps = Omit<
  UseMutateProps<ResponseString, unknown, CloneBudgetQueryParams, void, CloneBudgetPathParams>,
  'path' | 'verb'
> &
  CloneBudgetPathParams

/**
 * Clone budget
 */
export const useCloneBudget = ({ id, ...props }: UseCloneBudgetProps) =>
  useMutate<ResponseString, unknown, CloneBudgetQueryParams, void, CloneBudgetPathParams>(
    'POST',
    (paramsInPath: CloneBudgetPathParams) => `/budgets/${paramsInPath.id}`,
    { base: getConfig('ccm/api'), pathParams: { id }, ...props }
  )

export interface UpdateBudgetQueryParams {
  accountIdentifier: string
}

export interface UpdateBudgetPathParams {
  id: string
}

export type UpdateBudgetProps = Omit<
  MutateProps<ResponseString, unknown, UpdateBudgetQueryParams, BudgetRequestBody, UpdateBudgetPathParams>,
  'path' | 'verb'
> &
  UpdateBudgetPathParams

/**
 * Update budget
 */
export const UpdateBudget = ({ id, ...props }: UpdateBudgetProps) => (
  <Mutate<ResponseString, unknown, UpdateBudgetQueryParams, BudgetRequestBody, UpdateBudgetPathParams>
    verb="PUT"
    path={`/budgets/${id}`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseUpdateBudgetProps = Omit<
  UseMutateProps<ResponseString, unknown, UpdateBudgetQueryParams, BudgetRequestBody, UpdateBudgetPathParams>,
  'path' | 'verb'
> &
  UpdateBudgetPathParams

/**
 * Update budget
 */
export const useUpdateBudget = ({ id, ...props }: UseUpdateBudgetProps) =>
  useMutate<ResponseString, unknown, UpdateBudgetQueryParams, BudgetRequestBody, UpdateBudgetPathParams>(
    'PUT',
    (paramsInPath: UpdateBudgetPathParams) => `/budgets/${paramsInPath.id}`,
    { base: getConfig('ccm/api'), pathParams: { id }, ...props }
  )

export interface GetCostDetailsQueryParams {
  accountIdentifier: string
}

export interface GetCostDetailsPathParams {
  id: string
}

export type GetCostDetailsProps = Omit<
  GetProps<ResponseBudgetData, unknown, GetCostDetailsQueryParams, GetCostDetailsPathParams>,
  'path'
> &
  GetCostDetailsPathParams

/**
 * Get cost details for budget
 */
export const GetCostDetails = ({ id, ...props }: GetCostDetailsProps) => (
  <Get<ResponseBudgetData, unknown, GetCostDetailsQueryParams, GetCostDetailsPathParams>
    path={`/budgets/${id}/costDetails`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetCostDetailsProps = Omit<
  UseGetProps<ResponseBudgetData, unknown, GetCostDetailsQueryParams, GetCostDetailsPathParams>,
  'path'
> &
  GetCostDetailsPathParams

/**
 * Get cost details for budget
 */
export const useGetCostDetails = ({ id, ...props }: UseGetCostDetailsProps) =>
  useGet<ResponseBudgetData, unknown, GetCostDetailsQueryParams, GetCostDetailsPathParams>(
    (paramsInPath: GetCostDetailsPathParams) => `/budgets/${paramsInPath.id}/costDetails`,
    { base: getConfig('ccm/api'), pathParams: { id }, ...props }
  )

export interface GetBusinessMappingListQueryParams {
  accountIdentifier?: string
}

export type GetBusinessMappingListProps = Omit<
  GetProps<RestResponseListBusinessMapping, unknown, GetBusinessMappingListQueryParams, void>,
  'path'
>

/**
 * Get List Of Business Mappings
 */
export const GetBusinessMappingList = (props: GetBusinessMappingListProps) => (
  <Get<RestResponseListBusinessMapping, unknown, GetBusinessMappingListQueryParams, void>
    path={`/business-mapping`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetBusinessMappingListProps = Omit<
  UseGetProps<RestResponseListBusinessMapping, unknown, GetBusinessMappingListQueryParams, void>,
  'path'
>

/**
 * Get List Of Business Mappings
 */
export const useGetBusinessMappingList = (props: UseGetBusinessMappingListProps) =>
  useGet<RestResponseListBusinessMapping, unknown, GetBusinessMappingListQueryParams, void>(`/business-mapping`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface CreateBusinessMappingQueryParams {
  accountIdentifier?: string
}

export type CreateBusinessMappingProps = Omit<
  MutateProps<RestResponseBoolean, unknown, CreateBusinessMappingQueryParams, BusinessMappingRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create Business Mapping
 */
export const CreateBusinessMapping = (props: CreateBusinessMappingProps) => (
  <Mutate<RestResponseBoolean, unknown, CreateBusinessMappingQueryParams, BusinessMappingRequestBody, void>
    verb="POST"
    path={`/business-mapping`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseCreateBusinessMappingProps = Omit<
  UseMutateProps<RestResponseBoolean, unknown, CreateBusinessMappingQueryParams, BusinessMappingRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create Business Mapping
 */
export const useCreateBusinessMapping = (props: UseCreateBusinessMappingProps) =>
  useMutate<RestResponseBoolean, unknown, CreateBusinessMappingQueryParams, BusinessMappingRequestBody, void>(
    'POST',
    `/business-mapping`,
    { base: getConfig('ccm/api'), ...props }
  )

export interface UpdateBusinessMappingQueryParams {
  accountIdentifier?: string
}

export type UpdateBusinessMappingProps = Omit<
  MutateProps<RestResponseString, unknown, UpdateBusinessMappingQueryParams, BusinessMappingRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update Business Mapping
 */
export const UpdateBusinessMapping = (props: UpdateBusinessMappingProps) => (
  <Mutate<RestResponseString, unknown, UpdateBusinessMappingQueryParams, BusinessMappingRequestBody, void>
    verb="PUT"
    path={`/business-mapping`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseUpdateBusinessMappingProps = Omit<
  UseMutateProps<RestResponseString, unknown, UpdateBusinessMappingQueryParams, BusinessMappingRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update Business Mapping
 */
export const useUpdateBusinessMapping = (props: UseUpdateBusinessMappingProps) =>
  useMutate<RestResponseString, unknown, UpdateBusinessMappingQueryParams, BusinessMappingRequestBody, void>(
    'PUT',
    `/business-mapping`,
    { base: getConfig('ccm/api'), ...props }
  )

export interface DeleteBusinessMappingQueryParams {
  accountIdentifier?: string
}

export type DeleteBusinessMappingProps = Omit<
  MutateProps<RestResponseString, unknown, DeleteBusinessMappingQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete Business Mapping
 */
export const DeleteBusinessMapping = (props: DeleteBusinessMappingProps) => (
  <Mutate<RestResponseString, unknown, DeleteBusinessMappingQueryParams, string, void>
    verb="DELETE"
    path={`/business-mapping`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseDeleteBusinessMappingProps = Omit<
  UseMutateProps<RestResponseString, unknown, DeleteBusinessMappingQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete Business Mapping
 */
export const useDeleteBusinessMapping = (props: UseDeleteBusinessMappingProps) =>
  useMutate<RestResponseString, unknown, DeleteBusinessMappingQueryParams, string, void>(
    'DELETE',
    `/business-mapping`,
    { base: getConfig('ccm/api'), ...props }
  )

export interface GetBusinessMappingQueryParams {
  accountIdentifier?: string
}

export interface GetBusinessMappingPathParams {
  id: string
}

export type GetBusinessMappingProps = Omit<
  GetProps<RestResponseBusinessMapping, unknown, GetBusinessMappingQueryParams, GetBusinessMappingPathParams>,
  'path'
> &
  GetBusinessMappingPathParams

/**
 * Get Business Mapping
 */
export const GetBusinessMapping = ({ id, ...props }: GetBusinessMappingProps) => (
  <Get<RestResponseBusinessMapping, unknown, GetBusinessMappingQueryParams, GetBusinessMappingPathParams>
    path={`/business-mapping/${id}`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetBusinessMappingProps = Omit<
  UseGetProps<RestResponseBusinessMapping, unknown, GetBusinessMappingQueryParams, GetBusinessMappingPathParams>,
  'path'
> &
  GetBusinessMappingPathParams

/**
 * Get Business Mapping
 */
export const useGetBusinessMapping = ({ id, ...props }: UseGetBusinessMappingProps) =>
  useGet<RestResponseBusinessMapping, unknown, GetBusinessMappingQueryParams, GetBusinessMappingPathParams>(
    (paramsInPath: GetBusinessMappingPathParams) => `/business-mapping/${paramsInPath.id}`,
    { base: getConfig('ccm/api'), pathParams: { id }, ...props }
  )

export interface AwsaccountconnectiondetailQueryParams {
  accountIdentifier?: string
}

export type AwsaccountconnectiondetailProps = Omit<
  GetProps<ResponseAwsAccountConnectionDetail, unknown, AwsaccountconnectiondetailQueryParams, void>,
  'path'
>

/**
 * Get Aws account connection details
 */
export const Awsaccountconnectiondetail = (props: AwsaccountconnectiondetailProps) => (
  <Get<ResponseAwsAccountConnectionDetail, unknown, AwsaccountconnectiondetailQueryParams, void>
    path={`/connector/awsaccountconnectiondetail`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseAwsaccountconnectiondetailProps = Omit<
  UseGetProps<ResponseAwsAccountConnectionDetail, unknown, AwsaccountconnectiondetailQueryParams, void>,
  'path'
>

/**
 * Get Aws account connection details
 */
export const useAwsaccountconnectiondetail = (props: UseAwsaccountconnectiondetailProps) =>
  useGet<ResponseAwsAccountConnectionDetail, unknown, AwsaccountconnectiondetailQueryParams, void>(
    `/connector/awsaccountconnectiondetail`,
    { base: getConfig('ccm/api'), ...props }
  )

export type AzureappclientidProps = Omit<GetProps<ResponseString, unknown, void, void>, 'path'>

/**
 * Get Azure application client Id
 */
export const Azureappclientid = (props: AzureappclientidProps) => (
  <Get<ResponseString, unknown, void, void>
    path={`/connector/azureappclientid`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseAzureappclientidProps = Omit<UseGetProps<ResponseString, unknown, void, void>, 'path'>

/**
 * Get Azure application client Id
 */
export const useAzureappclientid = (props: UseAzureappclientidProps) =>
  useGet<ResponseString, unknown, void, void>(`/connector/azureappclientid`, { base: getConfig('ccm/api'), ...props })

export interface GcpserviceaccountQueryParams {
  accountIdentifier?: string
}

export type GcpserviceaccountProps = Omit<GetProps<ResponseString, unknown, GcpserviceaccountQueryParams, void>, 'path'>

/**
 * Provision and Get GCP Service Account
 */
export const Gcpserviceaccount = (props: GcpserviceaccountProps) => (
  <Get<ResponseString, unknown, GcpserviceaccountQueryParams, void>
    path={`/connector/gcpserviceaccount`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGcpserviceaccountProps = Omit<
  UseGetProps<ResponseString, unknown, GcpserviceaccountQueryParams, void>,
  'path'
>

/**
 * Provision and Get GCP Service Account
 */
export const useGcpserviceaccount = (props: UseGcpserviceaccountProps) =>
  useGet<ResponseString, unknown, GcpserviceaccountQueryParams, void>(`/connector/gcpserviceaccount`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface Execute1Response {
  [key: string]: { [key: string]: any }
}

export interface Execute1QueryParams {
  accountIdentifier?: string
  orgIdentifier?: string
  projectIdentifier?: string
}

export type Execute1Props = Omit<
  MutateProps<Execute1Response, unknown, Execute1QueryParams, GraphQLQuery, void>,
  'path' | 'verb'
>

export const Execute1 = (props: Execute1Props) => (
  <Mutate<Execute1Response, unknown, Execute1QueryParams, GraphQLQuery, void>
    verb="POST"
    path={`/graphql`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseExecute1Props = Omit<
  UseMutateProps<Execute1Response, unknown, Execute1QueryParams, GraphQLQuery, void>,
  'path' | 'verb'
>

export const useExecute1 = (props: UseExecute1Props) =>
  useMutate<Execute1Response, unknown, Execute1QueryParams, GraphQLQuery, void>('POST', `/graphql`, {
    base: getConfig('ccm/api'),
    ...props
  })

export type GetSchemaProps = Omit<GetProps<void, void, void, void>, 'path'>

export const GetSchema = (props: GetSchemaProps) => (
  <Get<void, void, void, void> path={`/graphql/schema`} base={getConfig('ccm/api')} {...props} />
)

export type UseGetSchemaProps = Omit<UseGetProps<void, void, void, void>, 'path'>

export const useGetSchema = (props: UseGetSchemaProps) =>
  useGet<void, void, void, void>(`/graphql/schema`, { base: getConfig('ccm/api'), ...props })

export type GetCENGMicroserviceHealthStatusProps = Omit<GetProps<ResponseString, unknown, void, void>, 'path'>

/**
 * Get CE-NG Manager health
 */
export const GetCENGMicroserviceHealthStatus = (props: GetCENGMicroserviceHealthStatusProps) => (
  <Get<ResponseString, unknown, void, void> path={`/health`} base={getConfig('ccm/api')} {...props} />
)

export type UseGetCENGMicroserviceHealthStatusProps = Omit<UseGetProps<ResponseString, unknown, void, void>, 'path'>

/**
 * Get CE-NG Manager health
 */
export const useGetCENGMicroserviceHealthStatus = (props: UseGetCENGMicroserviceHealthStatusProps) =>
  useGet<ResponseString, unknown, void, void>(`/health`, { base: getConfig('ccm/api'), ...props })

export interface GetCCMLicenseUsageQueryParams {
  accountIdentifier?: string
  timestamp?: number
}

export type GetCCMLicenseUsageProps = Omit<
  GetProps<ResponseCELicenseUsageDTO, unknown, GetCCMLicenseUsageQueryParams, void>,
  'path'
>

/**
 * Gets License Usage from a Particular Timestamp
 */
export const GetCCMLicenseUsage = (props: GetCCMLicenseUsageProps) => (
  <Get<ResponseCELicenseUsageDTO, unknown, GetCCMLicenseUsageQueryParams, void>
    path={`/license-util`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetCCMLicenseUsageProps = Omit<
  UseGetProps<ResponseCELicenseUsageDTO, unknown, GetCCMLicenseUsageQueryParams, void>,
  'path'
>

/**
 * Gets License Usage from a Particular Timestamp
 */
export const useGetCCMLicenseUsage = (props: UseGetCCMLicenseUsageProps) =>
  useGet<ResponseCELicenseUsageDTO, unknown, GetCCMLicenseUsageQueryParams, void>(`/license-util`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface TimescaleSqlQueriesStatsQueryParams {
  accountIdentifier?: string
}

export type TimescaleSqlQueriesStatsProps = Omit<
  GetProps<ResponseMapStringQueryStat, unknown, TimescaleSqlQueriesStatsQueryParams, void>,
  'path'
>

/**
 * timescale
 */
export const TimescaleSqlQueriesStats = (props: TimescaleSqlQueriesStatsProps) => (
  <Get<ResponseMapStringQueryStat, unknown, TimescaleSqlQueriesStatsQueryParams, void>
    path={`/metrics/timescale`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseTimescaleSqlQueriesStatsProps = Omit<
  UseGetProps<ResponseMapStringQueryStat, unknown, TimescaleSqlQueriesStatsQueryParams, void>,
  'path'
>

/**
 * timescale
 */
export const useTimescaleSqlQueriesStats = (props: UseTimescaleSqlQueriesStatsProps) =>
  useGet<ResponseMapStringQueryStat, unknown, TimescaleSqlQueriesStatsQueryParams, void>(`/metrics/timescale`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface DeletePerspectiveQueryParams {
  accountIdentifier: string
  perspectiveId: string
}

export type DeletePerspectiveProps = Omit<
  MutateProps<ResponseString, unknown, DeletePerspectiveQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete perspective
 */
export const DeletePerspective = (props: DeletePerspectiveProps) => (
  <Mutate<ResponseString, unknown, DeletePerspectiveQueryParams, void, void>
    verb="DELETE"
    path={`/perspective`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseDeletePerspectiveProps = Omit<
  UseMutateProps<ResponseString, unknown, DeletePerspectiveQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Delete perspective
 */
export const useDeletePerspective = (props: UseDeletePerspectiveProps) =>
  useMutate<ResponseString, unknown, DeletePerspectiveQueryParams, void, void>('DELETE', `/perspective`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface GetPerspectiveQueryParams {
  accountIdentifier: string
  perspectiveId?: string
}

export type GetPerspectiveProps = Omit<GetProps<ResponseCEView, unknown, GetPerspectiveQueryParams, void>, 'path'>

/**
 * Get perspective
 */
export const GetPerspective = (props: GetPerspectiveProps) => (
  <Get<ResponseCEView, unknown, GetPerspectiveQueryParams, void>
    path={`/perspective`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetPerspectiveProps = Omit<UseGetProps<ResponseCEView, unknown, GetPerspectiveQueryParams, void>, 'path'>

/**
 * Get perspective
 */
export const useGetPerspective = (props: UseGetPerspectiveProps) =>
  useGet<ResponseCEView, unknown, GetPerspectiveQueryParams, void>(`/perspective`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface CreatePerspectiveQueryParams {
  accountIdentifier: string
  clone?: boolean
}

export type CreatePerspectiveProps = Omit<
  MutateProps<ResponseCEView, unknown, CreatePerspectiveQueryParams, CEViewRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create perspective
 */
export const CreatePerspective = (props: CreatePerspectiveProps) => (
  <Mutate<ResponseCEView, unknown, CreatePerspectiveQueryParams, CEViewRequestBody, void>
    verb="POST"
    path={`/perspective`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseCreatePerspectiveProps = Omit<
  UseMutateProps<ResponseCEView, unknown, CreatePerspectiveQueryParams, CEViewRequestBody, void>,
  'path' | 'verb'
>

/**
 * Create perspective
 */
export const useCreatePerspective = (props: UseCreatePerspectiveProps) =>
  useMutate<ResponseCEView, unknown, CreatePerspectiveQueryParams, CEViewRequestBody, void>('POST', `/perspective`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface UpdatePerspectiveQueryParams {
  accountIdentifier: string
}

export type UpdatePerspectiveProps = Omit<
  MutateProps<ResponseCEView, unknown, UpdatePerspectiveQueryParams, CEViewRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update perspective
 */
export const UpdatePerspective = (props: UpdatePerspectiveProps) => (
  <Mutate<ResponseCEView, unknown, UpdatePerspectiveQueryParams, CEViewRequestBody, void>
    verb="PUT"
    path={`/perspective`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseUpdatePerspectiveProps = Omit<
  UseMutateProps<ResponseCEView, unknown, UpdatePerspectiveQueryParams, CEViewRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update perspective
 */
export const useUpdatePerspective = (props: UseUpdatePerspectiveProps) =>
  useMutate<ResponseCEView, unknown, UpdatePerspectiveQueryParams, CEViewRequestBody, void>('PUT', `/perspective`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface DeleteCustomFieldQueryParams {
  accountIdentifier?: string
  customFieldId?: string
}

export type DeleteCustomFieldProps = Omit<
  MutateProps<RestResponseString, unknown, DeleteCustomFieldQueryParams, CEViewRequestBody, void>,
  'path' | 'verb'
>

/**
 * Delete customField
 */
export const DeleteCustomField = (props: DeleteCustomFieldProps) => (
  <Mutate<RestResponseString, unknown, DeleteCustomFieldQueryParams, CEViewRequestBody, void>
    verb="DELETE"
    path={`/perspective-custom-field`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseDeleteCustomFieldProps = Omit<
  UseMutateProps<RestResponseString, unknown, DeleteCustomFieldQueryParams, CEViewRequestBody, void>,
  'path' | 'verb'
>

/**
 * Delete customField
 */
export const useDeleteCustomField = (props: UseDeleteCustomFieldProps) =>
  useMutate<RestResponseString, unknown, DeleteCustomFieldQueryParams, CEViewRequestBody, void>(
    'DELETE',
    `/perspective-custom-field`,
    { base: getConfig('ccm/api'), ...props }
  )

export interface GetCustomFieldQueryParams {
  accountIdentifier?: string
  customFieldId?: string
}

export type GetCustomFieldProps = Omit<
  GetProps<RestResponseViewCustomField, unknown, GetCustomFieldQueryParams, void>,
  'path'
>

/**
 * Get customField
 */
export const GetCustomField = (props: GetCustomFieldProps) => (
  <Get<RestResponseViewCustomField, unknown, GetCustomFieldQueryParams, void>
    path={`/perspective-custom-field`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetCustomFieldProps = Omit<
  UseGetProps<RestResponseViewCustomField, unknown, GetCustomFieldQueryParams, void>,
  'path'
>

/**
 * Get customField
 */
export const useGetCustomField = (props: UseGetCustomFieldProps) =>
  useGet<RestResponseViewCustomField, unknown, GetCustomFieldQueryParams, void>(`/perspective-custom-field`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface SaveCustomFieldQueryParams {
  accountIdentifier?: string
}

export type SaveCustomFieldProps = Omit<
  MutateProps<RestResponseViewCustomField, unknown, SaveCustomFieldQueryParams, ViewCustomFieldRequestBody, void>,
  'path' | 'verb'
>

/**
 * Save customField
 */
export const SaveCustomField = (props: SaveCustomFieldProps) => (
  <Mutate<RestResponseViewCustomField, unknown, SaveCustomFieldQueryParams, ViewCustomFieldRequestBody, void>
    verb="POST"
    path={`/perspective-custom-field`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseSaveCustomFieldProps = Omit<
  UseMutateProps<RestResponseViewCustomField, unknown, SaveCustomFieldQueryParams, ViewCustomFieldRequestBody, void>,
  'path' | 'verb'
>

/**
 * Save customField
 */
export const useSaveCustomField = (props: UseSaveCustomFieldProps) =>
  useMutate<RestResponseViewCustomField, unknown, SaveCustomFieldQueryParams, ViewCustomFieldRequestBody, void>(
    'POST',
    `/perspective-custom-field`,
    { base: getConfig('ccm/api'), ...props }
  )

export interface UpdateCustomFieldQueryParams {
  accountIdentifier?: string
}

export type UpdateCustomFieldProps = Omit<
  MutateProps<RestResponseViewCustomField, unknown, UpdateCustomFieldQueryParams, ViewCustomFieldRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update customField
 */
export const UpdateCustomField = (props: UpdateCustomFieldProps) => (
  <Mutate<RestResponseViewCustomField, unknown, UpdateCustomFieldQueryParams, ViewCustomFieldRequestBody, void>
    verb="PUT"
    path={`/perspective-custom-field`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseUpdateCustomFieldProps = Omit<
  UseMutateProps<RestResponseViewCustomField, unknown, UpdateCustomFieldQueryParams, ViewCustomFieldRequestBody, void>,
  'path' | 'verb'
>

/**
 * Update customField
 */
export const useUpdateCustomField = (props: UseUpdateCustomFieldProps) =>
  useMutate<RestResponseViewCustomField, unknown, UpdateCustomFieldQueryParams, ViewCustomFieldRequestBody, void>(
    'PUT',
    `/perspective-custom-field`,
    { base: getConfig('ccm/api'), ...props }
  )

export interface ValidateCustomFieldQueryParams {
  accountIdentifier?: string
}

export type ValidateCustomFieldProps = Omit<
  MutateProps<RestResponseString, unknown, ValidateCustomFieldQueryParams, ViewCustomFieldRequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate customField
 */
export const ValidateCustomField = (props: ValidateCustomFieldProps) => (
  <Mutate<RestResponseString, unknown, ValidateCustomFieldQueryParams, ViewCustomFieldRequestBody, void>
    verb="POST"
    path={`/perspective-custom-field/validate`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseValidateCustomFieldProps = Omit<
  UseMutateProps<RestResponseString, unknown, ValidateCustomFieldQueryParams, ViewCustomFieldRequestBody, void>,
  'path' | 'verb'
>

/**
 * Validate customField
 */
export const useValidateCustomField = (props: UseValidateCustomFieldProps) =>
  useMutate<RestResponseString, unknown, ValidateCustomFieldQueryParams, ViewCustomFieldRequestBody, void>(
    'POST',
    `/perspective-custom-field/validate`,
    { base: getConfig('ccm/api'), ...props }
  )

export interface GetForecastCostNextQueryParams {
  accountIdentifier: string
  perspectiveId: string
}

export type GetForecastCostNextProps = Omit<
  GetProps<ResponseDouble, unknown, GetForecastCostNextQueryParams, void>,
  'path'
>

/**
 * Get forecast cost for perspective
 */
export const GetForecastCostNext = (props: GetForecastCostNextProps) => (
  <Get<ResponseDouble, unknown, GetForecastCostNextQueryParams, void>
    path={`/perspective/forecastCost`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetForecastCostNextProps = Omit<
  UseGetProps<ResponseDouble, unknown, GetForecastCostNextQueryParams, void>,
  'path'
>

/**
 * Get forecast cost for perspective
 */
export const useGetForecastCostNext = (props: UseGetForecastCostNextProps) =>
  useGet<ResponseDouble, unknown, GetForecastCostNextQueryParams, void>(`/perspective/forecastCost`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface GetLastMonthCostNextQueryParams {
  accountIdentifier: string
  perspectiveId: string
}

export type GetLastMonthCostNextProps = Omit<
  GetProps<ResponseDouble, unknown, GetLastMonthCostNextQueryParams, void>,
  'path'
>

/**
 * Get last month cost for perspective
 */
export const GetLastMonthCostNext = (props: GetLastMonthCostNextProps) => (
  <Get<ResponseDouble, unknown, GetLastMonthCostNextQueryParams, void>
    path={`/perspective/lastMonthCost`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetLastMonthCostNextProps = Omit<
  UseGetProps<ResponseDouble, unknown, GetLastMonthCostNextQueryParams, void>,
  'path'
>

/**
 * Get last month cost for perspective
 */
export const useGetLastMonthCostNext = (props: UseGetLastMonthCostNextProps) =>
  useGet<ResponseDouble, unknown, GetLastMonthCostNextQueryParams, void>(`/perspective/lastMonthCost`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface DeleteReportSettingQueryParams {
  reportId?: string
  perspectiveId?: string
}

export type DeleteReportSettingProps = Omit<
  MutateProps<ResponseString, unknown, DeleteReportSettingQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete perspective reports
 */
export const DeleteReportSetting = (props: DeleteReportSettingProps) => (
  <Mutate<ResponseString, unknown, DeleteReportSettingQueryParams, string, void>
    verb="DELETE"
    path={`/perspectiveReport`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseDeleteReportSettingProps = Omit<
  UseMutateProps<ResponseString, unknown, DeleteReportSettingQueryParams, string, void>,
  'path' | 'verb'
>

/**
 * Delete perspective reports
 */
export const useDeleteReportSetting = (props: UseDeleteReportSettingProps) =>
  useMutate<ResponseString, unknown, DeleteReportSettingQueryParams, string, void>('DELETE', `/perspectiveReport`, {
    base: getConfig('ccm/api'),
    ...props
  })

export interface GetReportSettingQueryParams {
  perspectiveId?: string
  reportId?: string
}

export interface GetReportSettingPathParams {
  accountIdentifier: string
}

export type GetReportSettingProps = Omit<
  GetProps<ResponseListCEReportSchedule, unknown, GetReportSettingQueryParams, GetReportSettingPathParams>,
  'path'
> &
  GetReportSettingPathParams

/**
 * Get perspective reports
 */
export const GetReportSetting = ({ accountIdentifier, ...props }: GetReportSettingProps) => (
  <Get<ResponseListCEReportSchedule, unknown, GetReportSettingQueryParams, GetReportSettingPathParams>
    path={`/perspectiveReport/${accountIdentifier}`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetReportSettingProps = Omit<
  UseGetProps<ResponseListCEReportSchedule, unknown, GetReportSettingQueryParams, GetReportSettingPathParams>,
  'path'
> &
  GetReportSettingPathParams

/**
 * Get perspective reports
 */
export const useGetReportSetting = ({ accountIdentifier, ...props }: UseGetReportSettingProps) =>
  useGet<ResponseListCEReportSchedule, unknown, GetReportSettingQueryParams, GetReportSettingPathParams>(
    (paramsInPath: GetReportSettingPathParams) => `/perspectiveReport/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ccm/api'), pathParams: { accountIdentifier }, ...props }
  )

export interface CreateReportSettingPathParams {
  accountIdentifier: string
}

export type CreateReportSettingProps = Omit<
  MutateProps<ResponseListCEReportSchedule, unknown, void, CEReportScheduleRequestBody, CreateReportSettingPathParams>,
  'path' | 'verb'
> &
  CreateReportSettingPathParams

/**
 * Create perspective reports
 */
export const CreateReportSetting = ({ accountIdentifier, ...props }: CreateReportSettingProps) => (
  <Mutate<ResponseListCEReportSchedule, unknown, void, CEReportScheduleRequestBody, CreateReportSettingPathParams>
    verb="POST"
    path={`/perspectiveReport/${accountIdentifier}`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseCreateReportSettingProps = Omit<
  UseMutateProps<
    ResponseListCEReportSchedule,
    unknown,
    void,
    CEReportScheduleRequestBody,
    CreateReportSettingPathParams
  >,
  'path' | 'verb'
> &
  CreateReportSettingPathParams

/**
 * Create perspective reports
 */
export const useCreateReportSetting = ({ accountIdentifier, ...props }: UseCreateReportSettingProps) =>
  useMutate<ResponseListCEReportSchedule, unknown, void, CEReportScheduleRequestBody, CreateReportSettingPathParams>(
    'POST',
    (paramsInPath: CreateReportSettingPathParams) => `/perspectiveReport/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ccm/api'), pathParams: { accountIdentifier }, ...props }
  )

export interface UpdateReportSettingPathParams {
  accountIdentifier: string
}

export type UpdateReportSettingProps = Omit<
  MutateProps<ResponseListCEReportSchedule, unknown, void, CEReportScheduleRequestBody, UpdateReportSettingPathParams>,
  'path' | 'verb'
> &
  UpdateReportSettingPathParams

/**
 * Update perspective reports
 */
export const UpdateReportSetting = ({ accountIdentifier, ...props }: UpdateReportSettingProps) => (
  <Mutate<ResponseListCEReportSchedule, unknown, void, CEReportScheduleRequestBody, UpdateReportSettingPathParams>
    verb="PUT"
    path={`/perspectiveReport/${accountIdentifier}`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseUpdateReportSettingProps = Omit<
  UseMutateProps<
    ResponseListCEReportSchedule,
    unknown,
    void,
    CEReportScheduleRequestBody,
    UpdateReportSettingPathParams
  >,
  'path' | 'verb'
> &
  UpdateReportSettingPathParams

/**
 * Update perspective reports
 */
export const useUpdateReportSetting = ({ accountIdentifier, ...props }: UseUpdateReportSettingProps) =>
  useMutate<ResponseListCEReportSchedule, unknown, void, CEReportScheduleRequestBody, UpdateReportSettingPathParams>(
    'PUT',
    (paramsInPath: UpdateReportSettingPathParams) => `/perspectiveReport/${paramsInPath.accountIdentifier}`,
    { base: getConfig('ccm/api'), pathParams: { accountIdentifier }, ...props }
  )

export interface ValidateConnectorQueryParams {
  accountIdentifier?: string
}

export type ValidateConnectorProps = Omit<
  MutateProps<ResponseConnectorValidationResult, unknown, ValidateConnectorQueryParams, ConnectorResponse, void>,
  'path' | 'verb'
>

/**
 * Validate connector
 */
export const ValidateConnector = (props: ValidateConnectorProps) => (
  <Mutate<ResponseConnectorValidationResult, unknown, ValidateConnectorQueryParams, ConnectorResponse, void>
    verb="POST"
    path={`/testconnection`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseValidateConnectorProps = Omit<
  UseMutateProps<ResponseConnectorValidationResult, unknown, ValidateConnectorQueryParams, ConnectorResponse, void>,
  'path' | 'verb'
>

/**
 * Validate connector
 */
export const useValidateConnector = (props: UseValidateConnectorProps) =>
  useMutate<ResponseConnectorValidationResult, unknown, ValidateConnectorQueryParams, ConnectorResponse, void>(
    'POST',
    `/testconnection`,
    { base: getConfig('ccm/api'), ...props }
  )

export interface GetLicenseUsageQueryParams {
  accountIdentifier?: string
  timestamp?: number
  CDLicenseType?: string
}

export interface GetLicenseUsagePathParams {
  module: string
}

export type GetLicenseUsageProps = Omit<
  GetProps<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>,
  'path'
> &
  GetLicenseUsagePathParams

/**
 * Gets License Usage By Module and Timestamp
 */
export const GetLicenseUsage = ({ module, ...props }: GetLicenseUsageProps) => (
  <Get<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>
    path={`/usage/${module}`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetLicenseUsageProps = Omit<
  UseGetProps<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>,
  'path'
> &
  GetLicenseUsagePathParams

/**
 * Gets License Usage By Module and Timestamp
 */
export const useGetLicenseUsage = ({ module, ...props }: UseGetLicenseUsageProps) =>
  useGet<ResponseLicenseUsageDTO, Failure | Error, GetLicenseUsageQueryParams, GetLicenseUsagePathParams>(
    (paramsInPath: GetLicenseUsagePathParams) => `/usage/${paramsInPath.module}`,
    { base: getConfig('ccm/api'), pathParams: { module }, ...props }
  )

export interface CloudCostCapabilityCheckQueryParams {
  accountIdentifier?: string
}

export type CloudCostCapabilityCheckProps = Omit<
  MutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    CloudCostCapabilityCheckQueryParams,
    K8sClusterSetupRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * check if the existing k8s cloud provider have necessary permissions to enable Cloud Cost Visibility
 */
export const CloudCostCapabilityCheck = (props: CloudCostCapabilityCheckProps) => (
  <Mutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    CloudCostCapabilityCheckQueryParams,
    K8sClusterSetupRequestRequestBody,
    void
  >
    verb="POST"
    path={`/yaml/cloudCostCapabilityCheck`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseCloudCostCapabilityCheckProps = Omit<
  UseMutateProps<
    ResponseConnectorValidationResult,
    Failure | Error,
    CloudCostCapabilityCheckQueryParams,
    K8sClusterSetupRequestRequestBody,
    void
  >,
  'path' | 'verb'
>

/**
 * check if the existing k8s cloud provider have necessary permissions to enable Cloud Cost Visibility
 */
export const useCloudCostCapabilityCheck = (props: UseCloudCostCapabilityCheckProps) =>
  useMutate<
    ResponseConnectorValidationResult,
    Failure | Error,
    CloudCostCapabilityCheckQueryParams,
    K8sClusterSetupRequestRequestBody,
    void
  >('POST', `/yaml/cloudCostCapabilityCheck`, { base: getConfig('ccm/api'), ...props })

export interface CloudCostK8sClusterSetupQueryParams {
  accountIdentifier?: string
}

export type CloudCostK8sClusterSetupProps = Omit<
  MutateProps<void, Failure | Error, CloudCostK8sClusterSetupQueryParams, K8sClusterSetupRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * get k8s cluster setup yaml based on features enabled
 */
export const CloudCostK8sClusterSetup = (props: CloudCostK8sClusterSetupProps) => (
  <Mutate<void, Failure | Error, CloudCostK8sClusterSetupQueryParams, K8sClusterSetupRequestRequestBody, void>
    verb="POST"
    path={`/yaml/cloudCostK8sClusterSetup`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseCloudCostK8sClusterSetupProps = Omit<
  UseMutateProps<void, Failure | Error, CloudCostK8sClusterSetupQueryParams, K8sClusterSetupRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * get k8s cluster setup yaml based on features enabled
 */
export const useCloudCostK8sClusterSetup = (props: UseCloudCostK8sClusterSetupProps) =>
  useMutate<void, Failure | Error, CloudCostK8sClusterSetupQueryParams, K8sClusterSetupRequestRequestBody, void>(
    'POST',
    `/yaml/cloudCostK8sClusterSetup`,
    { base: getConfig('ccm/api'), ...props }
  )

export interface CloudCostK8sClusterSetupV2QueryParams {
  accountIdentifier?: string
  includeVisibility?: boolean
  includeOptimization?: boolean
}

export type CloudCostK8sClusterSetupV2Props = Omit<
  MutateProps<void, Failure | Error, CloudCostK8sClusterSetupV2QueryParams, K8sClusterSetupRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * get k8s cluster setup yaml based on requirement
 */
export const CloudCostK8sClusterSetupV2 = (props: CloudCostK8sClusterSetupV2Props) => (
  <Mutate<void, Failure | Error, CloudCostK8sClusterSetupV2QueryParams, K8sClusterSetupRequestRequestBody, void>
    verb="POST"
    path={`/yaml/cloudCostK8sClusterSetupV2`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseCloudCostK8sClusterSetupV2Props = Omit<
  UseMutateProps<void, Failure | Error, CloudCostK8sClusterSetupV2QueryParams, K8sClusterSetupRequestRequestBody, void>,
  'path' | 'verb'
>

/**
 * get k8s cluster setup yaml based on requirement
 */
export const useCloudCostK8sClusterSetupV2 = (props: UseCloudCostK8sClusterSetupV2Props) =>
  useMutate<void, Failure | Error, CloudCostK8sClusterSetupV2QueryParams, K8sClusterSetupRequestRequestBody, void>(
    'POST',
    `/yaml/cloudCostK8sClusterSetupV2`,
    { base: getConfig('ccm/api'), ...props }
  )

export interface GetCostOptimisationYamlTemplateQueryParams {
  accountIdentifier?: string
  connectorIdentifier?: string
}

export type GetCostOptimisationYamlTemplateProps = Omit<
  MutateProps<void, Failure | Error, GetCostOptimisationYamlTemplateQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Get Cost Optimisation Yaml
 */
export const GetCostOptimisationYamlTemplate = (props: GetCostOptimisationYamlTemplateProps) => (
  <Mutate<void, Failure | Error, GetCostOptimisationYamlTemplateQueryParams, void, void>
    verb="POST"
    path={`/yaml/generate-cost-optimisation-yaml`}
    base={getConfig('ccm/api')}
    {...props}
  />
)

export type UseGetCostOptimisationYamlTemplateProps = Omit<
  UseMutateProps<void, Failure | Error, GetCostOptimisationYamlTemplateQueryParams, void, void>,
  'path' | 'verb'
>

/**
 * Get Cost Optimisation Yaml
 */
export const useGetCostOptimisationYamlTemplate = (props: UseGetCostOptimisationYamlTemplateProps) =>
  useMutate<void, Failure | Error, GetCostOptimisationYamlTemplateQueryParams, void, void>(
    'POST',
    `/yaml/generate-cost-optimisation-yaml`,
    { base: getConfig('ccm/api'), ...props }
  )
